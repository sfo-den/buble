<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 8. The Forms of Resource Descriptions</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><meta name="keywords" content="form, abstract models, metamodels, controlled vocabulary, data structures, MESH, constraints, JSON, XML Information Set, Semantic Web, RDF, mixed content, triples, predicate, subject, object, schemas, writing systems, syntax, grammar, encoding scheme, notation, transclusion"/><meta name="keywords" content="organizing, information, resources, metadata, resource description"/><link rel="up" href="index.html" title="The Discipline of Organizing"/><link rel="prev" href="ch07.html" title="Chapter 7. Classification: Assigning Resources to Categories"/><link rel="next" href="ch09.html" title="Chapter 9. Interactions with Resources"/></head><body><section class="chapter" title="Chapter 8. The Forms of Resource Descriptions" epub:type="chapter" id="chapter-8"><div class="titlepage"><div><div><h2 class="title">Chapter 8. The Forms of Resource Descriptions</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Ryan</span> <span class="surname">Shaw</span></h3></div></div><div><div class="author"><h3 class="author"><span class="firstname">Murray</span> <span class="surname">Maloney</span></h3></div></div></div></div><div class="sect1" title="Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="section-8.1">Introduction</h2></div></div></div><p>Throughout this book, we have emphasized the importance of separately considering
            fundamental organizing principles, application-specific concepts, and details of
            implementation. The three-tier architecture we introduced in <a class="xref" href="ch01.html#section-1.2.3.1" title="The Concept of “Organizing Principle”">The Concept of <span class="quote">“<span class="quote">Organizing Principle</span>”</span></a> is one way to conceptualize this separation. In <a class="xref" href="ch05.html#section-5.7" title="The Implementation Perspective">The Implementation Perspective </a>, we contrasted the implementation-focused perspective for
            analyzing relationships with other perspectives that focus on the meaning and abstract
            structure of relationships. In this chapter, we present this contrast between
            conceptualization and implementation in terms of separating the
                <span class="emphasis"><em>content</em></span> and <span class="emphasis"><em><a class="glossterm" href="go01.html#gloss_form"><em class="glossterm">form</em></a></em></span> of resource descriptions.</p><p>In the previous chapters, we have considered principles and concepts of organizing in
            many different contexts, ranging from personal organizing systems to cultural and
            institutional ones. We have noted that some organizing systems have limited scope and
            expected lifetime, such as a task-oriented personal organizing system, like a shopping
            list. Other organizing systems support broad uses that rely on standard categories
            developed through rigorous processes, like a product catalog.</p><p>By this point you should have a good sense of the various conceptual issues you need
            to consider when deciding how to describe a resource in order to meet the goals of your
            organizing system. Considering those issues will give you some sense of what the content
            of your descriptions should be. In order to focus on the conceptual issues, we have
            deferred discussion of specific implementation issues. Implementation involves choosing
            the specific form of your descriptions, and that is the topic of this chapter.</p><p>We can approach the problem of how to form resource descriptions from two
            perspectives: structuring and writing. From one perspective, resource descriptions are
            things that are <span class="emphasis"><em>used</em></span> by both people and computational agents. From
            this perspective, choosing the form of resource descriptions is a kind of design. This
            is easy to see for certain kinds of resource descriptions, like the signs and maps found
            in physical environments like airport terminals, public libraries, and malls. In these
            spaces, resource descriptions are quite literally designed to help people orient
            themselves and find their way. But any kind of resource description, not just those
            embedded in the built environment, can be viewed as a designed object. Designing an
            object involves making decisions about how it should be structured so that it can best
            be used for its intended purpose. From a design perspective, choosing the form of a
            resource description means making decisions about its
            <span class="emphasis"><em>structure</em></span>.</p><p>In <a class="xref" href="ch05.html#section-5.5" title="The Structural Perspective">The Structural Perspective</a>, we took a structural perspective on resources and
            the relationships among them. In this chapter, we will take a structural perspective on
            resource <span class="emphasis"><em>descriptions</em></span>. The difference is subtle but important. A
            structural perspective on resource <span class="emphasis"><em>relationships</em></span> focuses on how
            people or computational processes associate, arrange, and connect those resources. A
            structural perspective on resource <span class="emphasis"><em>descriptions</em></span> focuses on how
            those associations, arrangements, and connections are explicitly represented or
            implemented in the descriptions we create. Mismatches between the structure imposed on
            the resources being organized and the structure of the descriptions used to implement
            that organization could result in an organizing system that is complex, inefficient, and
            difficult to maintain, as you will see in our first example.</p><p>The structures of resource descriptions enable or inhibit particular ways of
            interacting with those descriptions, just as the descriptions themselves enable or
            inhibit particular ways of interacting with the described resources (see <a class="xref" href="ch02.html#section-2.4" title="Designing Resource-Based Interactions">Designing Resource-Based Interactions</a>, and <a class="xref" href="ch09.html" title="Chapter 9. Interactions with Resources">Chapter 9</a>). Keep in mind that
            resource descriptions are themselves information resources. So, much of what we will say
            in this chapter is applicable to the structures and forms of information resources in
            general. Put another way, the structure and form of information resources informs the
            design of resource descriptions.</p><p>From another perspective, creating resource descriptions is a kind of
                <span class="quote">“<span class="quote">writing.</span>”</span> I may describe something to you orally, but such a
            description might not be very useful to an organizing system unless it were transcribed.
            Organizing systems need persistent descriptions, and that means they need to be written.
            In that sense, choosing the form of a resource description means making decisions about
                <span class="emphasis"><em>notation</em></span> and <span class="emphasis"><em>syntax</em></span>.</p><p>Modern Western culture tends to make a sharp distinction between designing and
            writing, but there are areas where this distinction breaks down, and the creation of
            resource descriptions in organizing systems is one of them. In the following sections,
            we will use designing and writing as two lenses for looking at the problem of how to
            choose the form of resource descriptions. Specifically, we will examine the spectrum of
            options we have for structuring descriptions, and the kinds of syntaxes we have for
            writing those descriptions.</p></div><div class="sect1" title="Structuring Descriptions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="section-8.2">Structuring Descriptions</h2></div></div></div><p>Choosing how to structure resource descriptions is a matter of making principled and
            purposeful design decisions in order to solve specific problems, serve specific
            purposes, or bring about some desirable property in the descriptions. Most of these
            decisions are specific to a <span class="emphasis"><em>domain</em></span>: the particular context of
            application for the organizing system being designed and the kinds of interactions with
            resources it will enable. Making these kinds of context-specific decisions results in a
            model of that domain (see <a class="xref" href="ch04.html#section-4.3.1.2" title="Abstraction in Resource Description">Abstraction in Resource Description</a>).</p><p>Over time, many people have built similar kinds of descriptions. They have had similar
            purposes, desired similar properties, and faced similar problems. Unsurprisingly, they
            have converged on some of the same decisions. <a id="id651619" class="indexterm"/><a id="id651622" class="indexterm"/><span><a id="def_metamodels"/>When common sets of design decisions can be
                identified that are not specific to any one domain, they often become systematized
                in textbooks and in design practices, and may eventually be designed into standard
                formats and architectures for creating organizing systems. These formally recognized
                sets of design decisions are known as <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_abstract_models"><em class="glossterm">abstract
                        models</em></a></strong></span> or <span class="strong"><strong><a class="glossterm" id="term_metamodels" href="go01.html#gloss_metamodels"><em class="glossterm">metamodels</em></a></strong></span>. Metamodels describe structures commonly
                found in resource descriptions and other information resources, regardless of the
                specific domain.</span> While any designer of an organizing system will usually
            create a model of her specific domain, she usually will not create an entirely new
            metamodel but will instead make choices from among the metamodels that have been
            formally recognized and incorporated into existing standards. The resulting model is
            sometimes called a <span class="quote">“<span class="quote">domain-specific language.</span>”</span> Reusing
            standard metamodels can bring great economical advantages, as developers can reuse tools
            designed for and knowledge about these metamodels, rather than having to start from
            scratch.</p><p>In the following sections, we examine some common kinds of structures used as the
            basis for metamodels. But first, we consider a concrete example of how the
            structure of resource descriptions supports or inhibits particular uses. As we explained
            in <a class="xref" href="ch01.html" title="Chapter 1. Foundations for Organizing Systems">Chapter 1</a>, the concept of a resource
            de-emphasizes the differences between physical and digital things in favor of focusing
            on how things, in general, are used to support goal-oriented activity. Different kinds
            of books can be treated as information resources regardless of the particular mix of
            tangible and intangible properties they may have. Since resource descriptions are also
            information resources, we can similarly consider how their structures support particular
            uses, independent of whether they are physical, digital, or a mix of both.</p><p><a id="id651835" class="indexterm"/>During World War II, a British chemist named <span class="personname"><span class="firstname">W. E.</span> <span class="surname">Batten</span></span> developed a system for organizing patents.<sup>[<a id="chapter-8-endnote-01" href="#ftn.chapter-8-endnote-01" epub:type="noteref" class="footnote">439</a>]</sup> The system consisted of a language for describing the product, process, use,
            and apparatus of a patent, and a way of using punched cards to record these
            descriptions. Batten used cards printed with matrices of 800 positions (see <a class="xref" href="ch08.html#chapter-8-figure-8-1" title="Figure 8-1. A Batten Card.">Figure 8-1</a>). Each card represented a
            specific value from the vocabulary of the description language, and each position
            corresponded to a particular patent. To describe patent #256 as covering
                <span class="emphasis"><em>extrusion of polythene to produce cable coverings</em></span>, one would
            first select the cards for the values <span class="emphasis"><em>polythene</em></span>,
                <span class="emphasis"><em>extrusion</em></span>, and <span class="emphasis"><em>cable coverings</em></span>, and then
            punch each card at the 256<sup>th</sup> position. The description of
            patent #256 would thus extend over these three cards.</p><div class="figure-float"><div class="figure"><a id="chapter-8-figure-8-1"/><div class="figure-contents"><div class="mediaobject"><a id="chapter-8-figure-8-1a"/><img src="figs/print/ch8.1-350dpi.png" alt="An example of a punch card used by Batten to describe a particular patent in a patent collection.&#10;                    Each card represented an individual description term, &#10;                    and each punch position on a card represented a particular patent."/></div></div><div class="figure-title">Figure 8-1. A Batten Card.</div></div></div><p>The advantage of this structure is that to find patents covering <span class="emphasis"><em>extrusion
                of polythene</em></span> (for any purpose), one needs only to select the two cards
            corresponding to those values, lay one on top of the other, and hold them up to a light.
            Light will shine through wherever there is a position corresponding to a patent
            described using those values. Patents meeting a certain description are easily found due
            to the structure of the cards designed to describe the patents.</p><p>Of course, this system has clear disadvantages as well. Finding the concepts
            associated with a particular patent is tedious, because every card must be inspected.
            Adding a new patent is relatively easy as long as there is an index that allows the
            cards for specific concepts to be located quickly. However, once the cards run out of
            space for punching holes, the whole set of cards must be duplicated to accommodate more
            patents: a very expensive operation. Adding new concepts is potentially easy: simply add
            a new card. But if we want to be able to find existing patents using the new concept,
            all the existing patents would have to be re-examined to determine whether their
            positions on the new card should be punched: also an expensive operation.</p><p><a id="id651947" class="indexterm"/>The structure of Batten’s cards supported rapid selection of resources given a partial
            description. The kinds of structures we will examine in the following sections are not
            quite so elaborate as Batten’s cards. But like the cards, each kind of structure
            supports more efficient mechanical execution of certain operations, at the cost of less
            efficient execution of others.</p><div class="sect2" title="Kinds of Structures"><div class="titlepage"><div><div><h3 class="title" id="section-8.2.1">Kinds of Structures</h3></div></div></div><p><a id="id652053" class="indexterm"/>Sets, lists, dictionaries, trees, and graphs are kinds of structures that can be
                used to form resource descriptions. As we shall see, each of these kinds is actually
                a family of related structures. These structures are
                    <span class="emphasis"><em>abstractions</em></span>: they describe formal structural properties in
                a general way, rather than specifying an exact physical or textual form.
                Abstractions are useful because they help us to see common properties shared by
                different specific ways of organizing information. By focusing on these common
                properties, we can more easily reason about the operations that different forms
                support and the affordances that they provide, without being distracted by less
                relevant details.</p><div class="sect3" title="Blobs"><div class="titlepage"><div><div><h4 class="title" id="section-8.2.1.1">Blobs</h4></div></div></div><p>The simplest kind of structure is no structure at all. Consider the following
                    description of a book: <span class="emphasis"><em>Sebald’s novel uses a walking tour in East
                        Anglia to meditate on links between past and present, East and
                        West.</em></span><sup>[<a id="chapter-8-endnote-02" href="#ftn.chapter-8-endnote-02" epub:type="noteref" class="footnote">440</a>]</sup> This description is an unstructured text expression with no clearly
                    defined internal parts, and we can consider it to be a <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_blob"><em class="glossterm">blob</em></a></strong></span>. Or, more precisely, it has structure, but that
                    structure is the underlying grammatical structure of the English language, and
                    none of that grammatical structure is explicitly represented in a surface
                    structure when the sentence is expressed. As readers of English we can interpret
                    the sentence as a description of the subject of the book, but to do this
                    mechanically is difficult.<sup>[<a id="chapter-8-endnote-03" href="#ftn.chapter-8-endnote-03" epub:type="noteref" class="footnote">441</a>]</sup> On the other hand, such a written description is relatively easy to
                    create, as the describer can simply use natural language.</p><p>A blob need not be a blob of text. It could be a photograph of a resource, or
                    a recording of a spoken description of a resource. Like blobs of text, blobs of
                    pixels or sound have underlying structure that any person with normal vision or
                    hearing can understand easily.<sup>[<a id="chapter-8-endnote-04" href="#ftn.chapter-8-endnote-04" epub:type="noteref" class="footnote">442</a>]</sup> But we can treat these blobs as unstructured, because none of the
                    underlying structure in the visual or auditory input is explicit, and we are
                    concerned with the ways that the structures of resource descriptions support or
                    inhibit mechanical or computational operations.<sup>[<a id="chapter-8-endnote-05" href="#ftn.chapter-8-endnote-05" epub:type="noteref" class="footnote">443</a>]</sup></p></div><div class="sect3" title="Sets"><div class="titlepage"><div><div><h4 class="title" id="section-8.2.1.2">Sets</h4></div></div></div><p><a id="id652255" class="indexterm"/><a id="id652262" class="indexterm"/><span><a id="def_set"/>The simplest way to structure a description is
                        to give it parts and treat them as a <span class="strong"><strong><a class="glossterm" id="term_set" href="go01.html#gloss_set"><em class="glossterm">set</em></a></strong></span>.</span> For example, the description of
                    Sebald’s novel might be reformulated as a set of terms:
                        <span class="emphasis"><em>Sebald</em></span>, <span class="emphasis"><em>novel, East Anglia, walking,
                        history</em></span>. Doing this has lost much of the meaning, but something
                    has been gained: we now can easily distinguish <span class="emphasis"><em>Sebald</em></span> and
                        <span class="emphasis"><em>walking</em></span> as separate items in the description.<sup>[<a id="chapter-8-endnote-06" href="#ftn.chapter-8-endnote-06" epub:type="noteref" class="footnote">444</a>]</sup> This makes it easier to find, for example, all the descriptions
                    which include the term <span class="emphasis"><em>walking</em></span>. (Note that this is
                    different from simply searching through blob-of-text descriptions for the word
                        <span class="emphasis"><em>walking</em></span>. When treated as a set, the description
                        <span class="emphasis"><em>Fiji, fire walking, memoir</em></span> does not include the term
                        <span class="emphasis"><em>walking</em></span>, though it does include the term <span class="emphasis"><em>fire
                        walking</em></span>.)</p><p>Sets make it easy to find intersections among descriptions. Sets are also easy
                    to create. In <a class="xref" href="ch07.html#section-7.1.2" title="Classification vs. Tagging">Classification vs. Tagging</a> we looked at
                        <span class="quote">“<span class="quote">folksonomies,</span>”</span> organizing systems in which non-professional
                    users create resource descriptions. In these systems, descriptions are
                    structured as sets of <span class="quote">“<span class="quote">tags.</span>”</span> To find resources, users can specify
                    a set of tags to obtain resources having descriptions that intersect at those
                    tags. This is more valuable if the tags come from a <a class="glossterm" href="go01.html#gloss_controlled_vocabulary"><em class="glossterm">controlled vocabulary</em></a>,
                    making intersections more likely. But enforcing vocabulary control adds
                    complexity to the description process, so a balance must be struck between
                    maximizing potential intersections and making description as simple as
                        practical.<sup>[<a id="chapter-8-endnote-07" href="#ftn.chapter-8-endnote-07" epub:type="noteref" class="footnote">445</a>]</sup></p><p><a id="id652491" class="indexterm"/><a id="id652482" class="indexterm"/><span><a id="def_constraint"/>A set is a type or class of structure.
                        We can refine the definition of different kinds of sets by introducing
                            <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_constraint"><em class="glossterm">constraints</em></a></strong></span>. For example, we might introduce
                        the constraint that a given set has a maximum number of items. Or we might
                        constrain a set to always have the same number of items, giving us a
                        fixed-size set. We can also remove constraints. Sets do not contain
                        duplicate items (think of a tagging system in which it does not make sense
                        to assign the same tag more than once to the same resource). If we remove
                        this <a class="glossterm" href="go01.html#gloss_uniqueness_principle"><em class="glossterm">uniqueness</em></a>
                        constraint, we have a different structure known as a <span class="quote">“<span class="quote">bag</span>”</span> or
                            <span class="quote">“<span class="quote">multiset.</span>”</span></span></p></div><div class="sect3" title="Lists"><div class="titlepage"><div><div><h4 class="title" id="section-8.2.1.3">Lists</h4></div></div></div><p><a id="id652577" class="indexterm"/><a id="id652587" class="indexterm"/><a id="id652601" class="indexterm"/>Constraints are what distinguish lists from sets. <span><a id="def_list"/>A <span class="strong"><strong><a class="glossterm" id="term_list" href="go01.html#gloss_list"><em class="glossterm">list</em></a></strong></span>, like a
                            <a class="glossterm" href="go01.html#gloss_set"><em class="glossterm">set</em></a>, is a collection of items
                        with an additional constraint: their items are
                        <span class="emphasis"><em>ordered</em></span>.</span> If we were designing a tagging system
                    in which it was important that the order of the tags be maintained, we would
                    want to use lists, not sets. Unlike sets, lists may contain duplicate items. In
                    a list, two items that are otherwise the same can be distinguished by their
                    position in the ordering, but in a set this is not possible. For example, we
                    might want to organize the tags assigned to a resource, listing the most used
                    tag first, the least frequently used last, and the rest ordered according their
                    according to their frequency of use.</p><p><a id="id652656" class="indexterm"/>Again, we can introduce constraints to refine the definition of different
                    kinds of lists such as fixed-length lists. If we constrain a list to contain
                    only items that are themselves lists, and further specify that these contained
                    lists do not themselves contains lists, then we have a
                        <span class="emphasis"><em>table</em></span> (a list of lists of items). A spreadsheet is a
                    list of lists.</p></div><div class="sect3" title="Dictionaries"><div class="titlepage"><div><div><h4 class="title" id="section-8.2.1.4">Dictionaries</h4></div></div></div><p>One major limitation of lists and sets is that, although items can be
                    individually addressed, there is no way to distinguish the items except by
                    comparing their values (or, in a list, their positions in the ordering). In a
                    set of tags like <span class="emphasis"><em>Sebald</em></span>, <span class="emphasis"><em>novel, East Anglia,
                        walking, history</em></span>, for example, one cannot easily tell that
                        <span class="emphasis"><em>Sebald</em></span> refers to the author of the book while
                        <span class="emphasis"><em>East Anglia</em></span> and <span class="emphasis"><em>walking</em></span> refer to
                    what it is about. One-way of addressing this problem is to break each item in a
                    set into two parts: a <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_property"><em class="glossterm">property</em></a></strong></span> and a <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_value"><em class="glossterm">value</em></a></strong></span>.
                    So, for example, our simple set of tags might become <span class="emphasis"><em>author: Sebald,
                        type: novel, subject: East Anglia, subject: walking, subject:
                        history</em></span>. Now we can say that <span class="emphasis"><em>author</em></span>,
                        <span class="emphasis"><em>type</em></span>, and <span class="emphasis"><em>subject</em></span> are the
                    properties, and the original items in the set are the values.</p><p>This kind of structure is called a <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_dictionary"><em class="glossterm">dictionary</em></a></strong></span>, also known as a <span class="emphasis"><em><a class="glossterm" href="go01.html#gloss_map"><em class="glossterm">map</em></a></em></span> or an
                            <span class="emphasis"><em><a class="glossterm" href="go01.html#gloss_associative_array"><em class="glossterm">associative array</em></a></em></span>.
                        <a id="id652813" class="indexterm"/><a id="id652823" class="indexterm"/><span><a id="def_dictionary_structure"/>A dictionary is a set of
                        property-value pairs or <span class="emphasis"><em>entries</em></span>. It is a set of
                        entries, not a list of entries, because the pairs are not ordered and
                        because each entry must have a unique key.</span><sup>[<a id="chapter-8-endnote-08" href="#ftn.chapter-8-endnote-08" epub:type="noteref" class="footnote">446</a>]</sup>
                    <span><a id="def_dictionary"/>Note that this specialized meaning of
                            <span class="quote">“<span class="quote">dictionary</span>”</span> is different from the more common meaning of
                            <span class="quote">“<span class="quote">dictionary</span>”</span> as an alphabetized list of terms accompanied
                        by sentences that define them.</span> The two meanings are related,
                    however. Like a <span class="quote">“<span class="quote">real</span>”</span> dictionary, a dictionary structure allows us
                    to easily find the value (such as a definition) associated with a particular
                    property or <span class="emphasis"><em>key</em></span> (such as a word). But unlike a real
                    dictionary, which orders its keys alphabetically, a dictionary structure does
                    not specify an order for its keys.<sup>[<a id="chapter-8-endnote-09" href="#ftn.chapter-8-endnote-09" epub:type="noteref" class="footnote">447</a>]</sup></p><p>Dictionaries are found everywhere in resource descriptions. Structured
                    descriptions entered using a form are easily represented as dictionaries, where
                    the labels of the form items are the properties and the data entered are the
                    values. Tabular data with a <span class="quote">“<span class="quote">header row</span>”</span> can be thought of as a set
                    of dictionaries, where the column headers are the properties for each
                    dictionary, and each row is a set of corresponding values. Dictionaries are also
                    a basic type of data structure found in nearly all programming languages (where
                    they usually are referred to as associative arrays).</p><p><a id="id652934" class="indexterm"/>Again, we can introduce or remove constraints to define specialized types of
                    dictionaries. A sorted dictionary adds an ordering over entries; in other words,
                    it is a list of entries rather than a set. A <span class="emphasis"><em>multimap</em></span> is a
                    dictionary in which multiple entries may have the same key.</p></div><div class="sect3" title="Trees"><div class="titlepage"><div><div><h4 class="title" id="section-8.2.1.5">Trees</h4></div></div></div><p><a id="id653020" class="indexterm"/>In dictionaries as they are commonly understood, properties are terms and
                    values are their corresponding definitions. The terms and values are usually
                    words, phrases, or other expressions that can be ordered alphabetically. But if
                    generalize the notion of a dictionary as abstract sets of property-value pairs,
                    the values can be anything at all. In particular, the values can themselves be
                    dictionaries. When a dictionary structure has values that are themselves
                    dictionaries, we say that the dictionaries are <span class="emphasis"><em>nested</em></span>.
                    Nesting is very useful for resource descriptions that need more structure than
                    what a (non-nested) dictionary can provide.</p><p><a class="xref" href="ch08.html#chapter-8-figure-8-2" title="Figure 8-2. Four Nested Dictionaries.">Figure 8-2</a> presents an example of nested
                    dictionaries. At the top level there is one dictionary with a single entry
                    having the property <span class="emphasis"><em>a</em></span>. The value associated with
                        <span class="emphasis"><em>a</em></span> is a dictionary consisting of two entries, the first
                    having property <span class="emphasis"><em>b</em></span> and the second having property
                        <span class="emphasis"><em>c</em></span>. The values associated with <span class="emphasis"><em>b</em></span>
                    and with <span class="emphasis"><em>c</em></span> are also dictionaries.</p><p>If we nest dictionaries like this, and our <span class="quote">“<span class="quote">top</span>”</span> dictionary (the
                    one that contains all the others) has only one entry, then we have a kind of
                        <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_tree"><em class="glossterm">tree</em></a></strong></span> structure. 
                    <a class="xref" href="ch08.html#chapter-8-figure-8-3" title="Figure 8-3. A Tree of Properties and Values.">Figure 8-3</a> shows the same properties
                    and values as <a class="xref" href="ch08.html#chapter-8-figure-8-2" title="Figure 8-2. Four Nested Dictionaries.">Figure 8-2</a>, this
                    time arranged to make the tree structure more visible. Trees consist of
                        <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_node"><em class="glossterm">nodes</em></a></strong></span> (the letters and numbers in <a class="xref" href="ch08.html#chapter-8-figure-8-3" title="Figure 8-3. A Tree of Properties and Values.">Figure 8-3</a>) joined by <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_edge"><em class="glossterm">edges</em></a></strong></span>
                    (the arrows). Each node in the tree with a circle around it is a property, and
                    the value of each property consists of the nodes below (to the right of) it in
                    the tree. A node is referred to as the <span class="emphasis"><em>parent</em></span> of the nodes
                    below it, which in turn are referred to as the <span class="emphasis"><em>children</em></span> of
                    that node. The edges show these <span class="quote">“<span class="quote">parent of</span>”</span> relationships between
                    the nodes. The node with no parent is called the <span class="emphasis"><em>root</em></span> of
                    the tree. Nodes with no children are called <span class="emphasis"><em>leaf</em></span>
                    nodes.</p><div class="figure"><a id="chapter-8-figure-8-2"/><div class="figure-contents"><div class="mediaobject"><a id="chapter-8-figure-8-2a"/><img src="figs/print/ch8.2-350dpi.png" alt="When a dictionary contains other dictionaries, they are said to be nested."/></div></div><div class="figure-title">Figure 8-2. Four Nested Dictionaries.</div></div><div class="figure"><a id="chapter-8-figure-8-3"/><div class="figure-contents"><div class="mediaobject"><a id="chapter-8-figure-8-3a"/><img src="figs/print/ch8.3-350dpi.png" alt="An alternative representation of nested dictionaries is as a tree.  &#10;                            The lowest level or leaf nodes of the tree contain property values."/></div></div><div class="figure-title">Figure 8-3. A Tree of Properties and Values.</div></div><p><a id="id653218" class="indexterm"/>As with the other types of structures we have considered, we can define
                    different kinds of trees by introducing different types of constraints. For
                    example, the predominant metamodel for <abbr class="abbrev">XML</abbr> is documents is a
                    kind of tree called the <em class="firstterm"><a id="first_XML_Infoset"/><span class="bold"><strong><a class="glossterm" href="go01.html#gloss_XML_Infoset"><em class="glossterm">XML Information
                                Set</em></a></strong></span></em> or Infoset. <sup>[<a id="chapter-8-endnote-11" href="#ftn.chapter-8-endnote-11" epub:type="noteref" class="footnote">448</a>]</sup></p><p><a id="id653308" class="indexterm"/>The <a class="glossterm" href="go01.html#gloss_XML_Infoset"><em class="glossterm">XML Information Set</em></a>
                    defines a specific kind of tree structure by adding very specific constraints,
                    including ordering of child nodes, to the basic definition of a tree. The
                    addition of an ordering constraint distinguishes <abbr class="abbrev">XML</abbr> trees from
                    nested dictionaries, in which child nodes do not have any order (because
                    dictionary entries do not have an ordering). Ordering is an important constraint
                    for resource descriptions, since without ordering it is impossible to (for
                    example) list multiple authors while guaranteeing that the order of authors will
                    be maintained. <a class="xref" href="ch08.html#chapter-8-figure-8-3" title="Figure 8-3. A Tree of Properties and Values.">Figure 8-3</a>
                    depicts a kind of tree with a different set of constraints: all non-leaf nodes
                    are properties, and all leafs are values. We could also define a tree in which
                    every node has both a property and a value. Trees exist in a large variety of
                    flavors, but they all share a common topology: the edges between nodes are
                    directed (one node is the parent and the other is the child), and every node
                    except the root has exactly one parent.</p><p>Trees provide a way to group statements describing different but related
                    resources. For example, consider the description structured as a dictionary
                    here:</p><div class="example"><a id="chapter-8-example-1"/><div class="example-title">Example 8-1. Description structured as a dictionary.</div><div class="example-contents"><div class="literallayout"><p>                    <span class="strong"><strong>author given names <span class="symbol">→</span> Winfried Georg</strong></span><br/>
                    <span class="strong"><strong>author surname <span class="symbol">→</span> Sebald</strong></span><br/>
                    <span class="strong"><strong>title <span class="symbol">→</span> Die Ringe des Saturn</strong></span><br/>
                    <span class="strong"><strong>pages <span class="symbol">→</span> 371</strong></span></p></div></div></div><p>The dictionary groups together four property-value pairs describing a
                    particular book. (The arrows are simply a schematic way to indicate
                    property-value relations. Later in the chapter we look at ways to
                        <span class="quote">“<span class="quote">write</span>”</span> these relations using some specific syntax.)</p><p>But really the first two entries are not describing the book; they are
                    describing the book’s author. So, it would be better to group those two
                    statements somehow. We can do this by nesting the entries describing the author
                    within the book description, creating a tree structure:</p><div class="example"><a id="chapter-8-example-2"/><div class="example-title">Example 8-2. Nesting an author description within a book description</div><div class="example-contents"><div class="literallayout"><p>                    <span class="strong"><strong>author <span class="symbol">→</span></strong></span><br/>
                            <span class="strong"><strong>given names <span class="symbol">→</span> Winfried Georg</strong></span><br/>
                            <span class="strong"><strong>surname <span class="symbol">→</span> Sebald</strong></span><br/>
                    <span class="strong"><strong>title <span class="symbol">→</span> Die Ringe des Saturn</strong></span><br/>
                    <span class="strong"><strong>pages <span class="symbol">→</span> 371</strong></span></p></div></div></div><p>Using a tree works well in this case because we can treat the book as the
                    primary resource being described, making it the root of our tree, and adding on
                    the author description as a <span class="quote">“<span class="quote">branch.</span>”</span></p><p>We also could have chosen to make the author the primary resource, giving us a
                    tree like the one in <a class="xref" href="ch08.html#chapter-8-example-3" title="Example 8-3. Nesting book descriptions within an author description">Example 8-3</a>.</p><div class="example"><a id="chapter-8-example-3"/><div class="example-title">Example 8-3. Nesting book descriptions within an author description</div><div class="example-contents"><div class="literallayout"><p>                    <span class="strong"><strong>given names <span class="symbol">→</span> Winfried Georg</strong></span><br/>
                    <span class="strong"><strong>surname <span class="symbol">→</span> Sebald</strong></span><br/>
                    <span class="strong"><strong>books authored <span class="symbol">→</span></strong></span><br/>
                            <span class="strong"><strong>1. title <span class="symbol">→</span> Die Ringe des Saturn</strong></span><br/>
                                <span class="strong"><strong>pages <span class="symbol">→</span> 371</strong></span><br/>
                            <span class="strong"><strong>2. title <span class="symbol">→</span> Austerlitz</strong></span><br/>
                                <span class="strong"><strong>pages <span class="symbol">→</span> 416</strong></span></p></div></div></div><p>Note that in this dictionary, the value of the <span class="emphasis"><em>books
                        authored</em></span> property is a <span class="emphasis"><em>list</em></span> of dictionaries.
                    Making the author the primary or root resource allows us to include multiple
                    book descriptions in the tree (but makes it more difficult to describe books
                    having multiple authors). A tree is a good choice for structuring descriptions
                    as long as we can clearly identify a primary resource. In some cases, however,
                    we want to connect descriptions of related resources without having to designate
                    one as primary. In these cases, we need a more flexible data structure.</p></div><div class="sect3" title="Graphs"><div class="titlepage"><div><div><h4 class="title" id="section-8.2.1.6">Graphs</h4></div></div></div><p>Suppose we were describing two books, where the author of one book is the
                    subject of the other (<a class="xref" href="ch08.html#chapter-8-example-4" title="Example 8-4. Two related descriptions.">Example 8-4</a>).</p><div class="example"><a id="chapter-8-example-4"/><div class="example-title">Example 8-4. Two related descriptions.</div><div class="example-contents"><div class="literallayout"><p>                    <span class="strong"><strong>1. author <span class="symbol">→</span> Mark Richard McCulloch</strong></span><br/>
                        <span class="strong"><strong>title <span class="symbol">→</span> Understanding W. G. Sebald</strong></span><br/>
                        <span class="strong"><strong>subject <span class="symbol">→</span> Winfried Georg Sebald</strong></span><br/>
                    <span class="strong"><strong>2. author <span class="symbol">→</span> Winfried Georg Sebald</strong></span><br/>
                        <span class="strong"><strong>title <span class="symbol">→</span> Die Ringe des Saturn</strong></span></p></div></div></div><p>By looking at these descriptions, we can guess the relationship between the
                    two books, but that relationship is not explicitly represented in the structure:
                    we just have two separate dictionaries and have inferred the relationship by
                    matching property values. It is possible that this inference could be wrong:
                    there might be two people named <span class="emphasis"><em>Winfried Georg Sebald</em></span>. How
                    can we structure these descriptions to explicitly represent the fact that the
                        <span class="emphasis"><em>Winfried Georg Sebald</em></span> that is the subject of the first
                    book is the same <span class="emphasis"><em>Winfried Georg Sebald</em></span> who authored the
                    second?</p><p>One possibility would be to make <span class="emphasis"><em>Winfried Georg Sebald</em></span>
                    the root of a tree, similar to the approach taken in <a class="xref" href="ch08.html#chapter-8-example-3" title="Example 8-3. Nesting book descriptions within an author description">Example 8-3</a>, adding a <span class="emphasis"><em>book about</em></span>
                    property alongside the <span class="emphasis"><em>books authored</em></span> one. This solution
                    would work fine if we felt that people were our primary resources, and it thus
                    made sense to structure our descriptions around them. But suppose that we had
                    decided that our descriptions should be structured around books, and that we
                    were using a vocabulary that took this perspective (with properties such as
                        <span class="emphasis"><em>author</em></span> and <span class="emphasis"><em>subject</em></span> rather than
                        <span class="emphasis"><em>books authored</em></span> and <span class="emphasis"><em>books about</em></span>).
                    We should not let a particular structure limit the organizational perspective we
                    can take, as Batten’s cards did. Instead, we should consciously choose
                    structures to suit our organizational perspective. How can we do this?</p><p>If we treat our two book descriptions as trees, we can join the two branches
                    (subject and author) that share a value. When we do this, we no longer have a
                    tree, because we now have a node with more than one parent (<a class="xref" href="ch08.html#chapter-8-figure-8-4" title="Figure 8-4. Descriptions Linked into a Graph.">Figure 8-4</a>). <a id="id653777" class="indexterm"/><a id="id653792" class="indexterm"/>The structure in <a class="xref" href="ch08.html#chapter-8-figure-8-4" title="Figure 8-4. Descriptions Linked into a Graph.">Figure 8-4</a> is a <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_graph"><em class="glossterm">graph</em></a></strong></span>. <span><a id="def_graph"/>Like a <a class="glossterm" href="go01.html#gloss_tree"><em class="glossterm">tree</em></a>, a
                            <a class="glossterm" href="go01.html#gloss_graph"><em class="glossterm">graph</em></a>
                        consists of a set of nodes connected by edges. These edges may or may not
                        have a direction (<a class="xref" href="ch05.html#section-5.6.3" title="Directionality">Directionality</a>). If they do, the graph is
                        referred to as a <span class="quote">“<span class="quote">directed graph.</span>”</span> If a graph is directed, it
                        may be possible to start at a node and follow edges in a path that leads
                        back to the starting node. Such a path is called a <span class="quote">“<span class="quote">cycle.</span>”</span> If
                        a directed graph has no cycles, it is referred to as an <span class="quote">“<span class="quote">acyclic
                            graph.</span>”</span></span></p><p><a id="id653861" class="indexterm"/>A tree is just a more constrained kind of graph. Trees are
                        <span class="emphasis"><em>directed</em></span> graphs because the <span class="quote">“<span class="quote">parent of</span>”</span>
                    relationship between nodes is asymmetric: the edges are arrows that point in a
                    certain direction (see <a class="xref" href="ch05.html#section-5.3.2.1" title="Symmetry">Symmetry</a>). Furthermore, trees
                    are <span class="emphasis"><em>acyclic</em></span> graphs, because if you follow the directed
                    edges from one node to another, you can never encounter the same node twice.
                    Finally, trees have the constraint that every node (except the root) must have
                    exactly one parent.<sup>[<a id="chapter-8-endnote-12" href="#ftn.chapter-8-endnote-12" epub:type="noteref" class="footnote">449</a>]</sup></p><p><a id="id653939" class="indexterm"/>In <a class="xref" href="ch08.html#chapter-8-figure-8-4" title="Figure 8-4. Descriptions Linked into a Graph.">Figure 8-4</a> we have violated this constraint by
                    joining our two book trees. The graph that results is still directed and
                    acyclic, but because the <span class="emphasis"><em>Winfried George Sebald</em></span> node now
                    has two parents, it is no longer a tree.</p><p>Graphs are very general and flexible structures. Many kinds of systems can be
                    conceived of as nodes connected by edges: stations connected by subway lines,
                    people connected by friendships, decisions connected by dependencies, and so on.
                    Relationships can be modeled in different ways using different kinds of graphs.
                    For example, if we assume that friendship is symmetric (see <a class="xref" href="ch05.html#section-5.3.2.1" title="Symmetry">Symmetry</a>), we would use an undirected graph to model the
                    relationship. However, in web-based social networks friendship is often
                    asymmetric (you might <span class="quote">“<span class="quote">friend</span>”</span> someone who does not reciprocate),
                    so a directed graph is more appropriate.</p><div class="figure-float"><div class="figure"><a id="chapter-8-figure-8-4"/><div class="figure-contents"><div class="mediaobject"><a id="chapter-8-figure-8-4a"/><img src="figs/print/ch8.4-350dpi.png" alt="Descriptions can be linked to form a graph when the value assigned to two different properties is the same."/></div></div><div class="figure-title">Figure 8-4. Descriptions Linked into a Graph.</div></div></div><p>Often it is useful to treat a graph as a set of pairs of nodes, where each
                    pair may or may not be directly connected by an edge. Many approaches to
                    characterizing structural relationships among resources (see <a class="xref" href="ch05.html#section-5.5.3" title="Structural Relationships between Resources">Structural Relationships between Resources</a>) are based on modeling the related resources as a
                    set of pairs of nodes, and then analyzing patterns of connectedness among them.
                    As we will see, being able to break down a graph into pairs is also useful when
                    we structure resource descriptions as graphs.</p><p>In <a class="xref" href="ch08.html#section-8.4.1" title="The Document Processing World">The Document Processing World</a> we will use
                        <abbr class="abbrev">XML</abbr> to model the graph shown in <a class="xref" href="ch08.html#chapter-8-figure-8-4" title="Figure 8-4. Descriptions Linked into a Graph.">Figure 8-4</a> by using <span class="quote">“<span class="quote">references</span>”</span> to
                    connect a book to its title, authors and subject. This will allow us to develop
                    sophisticated graphs of knowledge within a single XML document instance. (See
                    also the Sidebar, <a class="xref" href="ch08.html#sidebar_XML_Transclusion_Features" title="Inclusions and References">Inclusions and References</a>).<sup>[<a id="chapter-8-endnote-14" href="#ftn.chapter-8-endnote-14" epub:type="noteref" class="footnote">450</a>]</sup></p></div></div><div class="sect2" title="Comparing Metamodels: JSON, XML and RDF"><div class="titlepage"><div><div><h3 class="title" id="section-8.2.2">Comparing Metamodels: JSON, XML and RDF</h3></div></div></div><p>Now that we are familiar with the various <span class="emphasis"><em>kinds</em></span> of metamodels
                used to structure resource descriptions, we can take a closer look at some
                    <span class="emphasis"><em>specific</em></span> metamodels. A detailed comparison of the
                affordances of different metamodels is beyond the scope of this chapter. Here we
                will simply take a brief look at three popular
                    metamodels<span class="symbol">—</span><abbr class="abbrev">JSON</abbr>, <abbr class="abbrev">XML</abbr>,
                and <abbr class="abbrev">RDF</abbr><span class="symbol">—</span>in order to see how they further
                specify and constrain the more general kinds of metamodels introduced above.</p><div class="sect3" title="JSON"><div class="titlepage"><div><div><h4 class="title" id="section-8.2.2.1">JSON</h4></div></div></div><div class="glosslist"><dl><dt>JavaScript
                            Object Notation(JSON)</dt><dd><p><a id="id654265" class="indexterm"/><a id="id654279" class="indexterm"/><a id="id654291" class="indexterm"/><span><a id="def_JSON"/><span class="strong"><strong><a class="glossterm" href="go01.html#gloss_JSON"><em class="glossterm">JavaScript Object Notation
                                            (JSON)</em></a>
                                    </strong></span> is a textual format for exchanging data that borrows
                                    its metamodel from the JavaScript programming language.
                                    Specifically, the <abbr class="abbrev">JSON</abbr> metamodel consists of
                                    two kinds of structures found in JavaScript: lists (called
                                        <span class="emphasis"><em>arrays</em></span> in JavaScript) and dictionaries
                                    (called <span class="emphasis"><em>objects</em></span> in JavaScript). Lists and
                                    dictionaries contain values, which may be strings of text,
                                    numbers, Booleans (true or false), or the null (empty) value.
                                    Again, these types of values are taken directly from JavaScript.
                                    Lists and dictionaries can be values too, meaning lists and
                                    dictionaries can be nested within one another to produce more
                                    complex structures such as tables and trees.</span></p></dd></dl></div><p>Lists, dictionaries, and a basic set of value types constitute the
                        <abbr class="abbrev">JSON</abbr> metamodel. Because this metamodel is a subset of
                    JavaScript, the <abbr class="abbrev">JSON</abbr> metamodel is very easy to work with in
                    JavaScript. Since JavaScript is the only programming language that is available
                    in all web browsers, <abbr class="abbrev">JSON</abbr> has become a popular choice for
                    developers who need to work with data and resource descriptions on the web (see
                        <a class="xref" href="ch08.html#section-8.3.2" title="Writing Systems">Writing Systems</a> later in this chapter). Furthermore, many
                    modern programming languages provide data structures and value types equivalent
                    to those provided by JavaScript. So, data represented as <abbr class="abbrev">JSON</abbr>
                    is easy to work with in many programming languages, not just JavaScript.</p></div><div class="sect3" title="XML Information Set"><div class="titlepage"><div><div><h4 class="title" id="section-8.2.2.2">XML Information Set</h4></div></div></div><p>The <a class="glossterm" href="go01.html#gloss_XML_Infoset"><em class="glossterm">XML Information Set</em></a>
                    metamodel is derived from data structures used for document markup (see <a class="xref" href="ch04.html#section-4.2.2.2" title="Metadata">Metadata</a>). These markup
                        structures<span class="symbol">—</span><span class="strong"><strong><a class="glossterm" href="go01.html#gloss_element"><em class="glossterm">elements</em></a></strong></span> and <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_attribute"><em class="glossterm">attributes</em></a></strong></span><span class="symbol">—</span>are well suited
                    for programmatically manipulating the structure of documents and data
                        together.<sup>[<a id="id654439" href="#ftn.id654439" class="footnote">451</a>]</sup></p><div class="glosslist"><dl><dt>XML Infoset</dt><dd><p><a id="id654474" class="indexterm"/><a id="id654486" class="indexterm"/><span><a id="def_XML_Infoset"/>The <span class="bold"><strong><a class="glossterm" href="go01.html#gloss_XML_Infoset"><em class="glossterm">XML
                                        Infoset</em></a></strong></span> is a tree structure, where
                                    each node of the tree is defined to be an <span class="emphasis"><em>information
                                        item</em></span> of a particular type. Each information item
                                    has a set of type-specific properties associated with it. At the
                                    root of the tree is a document item, which has exactly one
                                    element item as its child. <a id="id654520" class="indexterm"/><a id="id654513" class="indexterm"/><span><a id="def_element"/>An element item has a set
                                        of attribute items, and a list of child nodes. These child
                                        nodes may include other element items, or they may be
                                        character items.</span> (See <a class="xref" href="ch08.html#section-8.2.1" title="Kinds of Structures">Kinds of Structures</a> below for more on characters.) Attribute items may contain
                                    character items, or they may contain typed data, such as name
                                    tokens, identifiers and references. Element identifiers and
                                    references (ID/IDREF) may be used to connect nodes, thereby
                                    transforming a tree into a graph. (See the Sidebar, <a class="xref" href="ch08.html#sidebar_XML_Transclusion_Features" title="Inclusions and References">Inclusions and References</a>).</span><sup>[<a id="id654501" href="#ftn.id654501" epub:type="noteref" class="footnote">452</a>]</sup></p></dd></dl></div><p><a id="id654634" class="indexterm"/></p><p><a class="xref" href="ch08.html#chapter-8-figure-8-5" title="Figure 8-5. A Description Structure.">Figure 8-5</a> is a graphical representation of how an
                        <abbr class="abbrev">XML</abbr> document might be used to structure part of a
                    description of an author and his works. This example demonstrates how we might
                    use element items to model the domain of the description, by giving them names
                    such as author and title. The character items that are the children of these
                    elements hold the content of the description: author names, book titles, and so
                    on. Attribute items are used to hold auxiliary information about this content,
                    such as its language.</p><div class="figure"><a id="chapter-8-figure-8-5"/><div class="figure-contents"><div class="mediaobject"><a id="chapter-8-figure-8-5a"/><img src="figs/print/ch8.5-350dpi.png" alt="An XML document can be described as a tree &#10;                            in which elements are nodes that can contain character content directly &#10;                            or attributes that contain character content."/></div></div><div class="figure-title">Figure 8-5. A Description Structure.</div></div><p>This example also demonstrates how the <abbr class="abbrev">XML</abbr> Infoset supports
                        <span class="quote">“<span class="quote">mixed content</span>”</span> by allowing element items and character items
                    to be <span class="quote">“<span class="quote">siblings</span>”</span> of the same parent element. In this case, the
                    Infoset structure allows us to specify that the book description can be
                    displayed as a line of text consisting of the original title and the translated
                    title in parentheses. The elements and attributes are used to indicate that this
                    line of text consists of two titles written in different languages, not a single
                    title containing parentheses.</p><p>If not for mixed content, we could not write narrative text with <a class="glossterm" href="go01.html#gloss_hypertext_link"><em class="glossterm">hypertext links</em></a> embedded in the
                    middle of a sentence. It gives us the ability to identify the subcomponents of a
                    sentence, so that we could distinguish the terms <span class="quote">“<span class="quote">Sebald,</span>”</span>
                        <span class="quote">“<span class="quote">walking</span>”</span> and <span class="quote">“<span class="quote">East Anglia</span>”</span> as an author and two
                    subjects.</p><p><a id="id654682" class="indexterm"/></p><div class="sidebar"><a id="sidebar_XML_Transclusion_Features"/><div class="sidebar-title">Inclusions and References</div><p>An <abbr class="abbrev">XML</abbr> Infoset is typically the result of processing a
                        well-formed <abbr class="abbrev">XML</abbr> document instance.<sup>[<a id="chapter-8-endnote-16" href="#ftn.chapter-8-endnote-16" class="footnote">453</a>]</sup> Schemas associated with <abbr class="abbrev">XML</abbr> document instances
                            <span class="quote">“<span class="quote">inform</span>”</span> the corresponding <abbr class="abbrev">XML</abbr> Infoset.
                        Thus, the <span class="quote">“<span class="quote">truth value</span>”</span> of any XML Infoset is dependent upon
                        its related schemas.<sup>[<a id="chapter-8-endnote-17" href="#ftn.chapter-8-endnote-17" epub:type="noteref" class="footnote">454</a>]</sup> Traditionally, any documentation that is related to the schema
                        is considered to be part of the schema definition and, at least notionally,
                        informs human understanding and interpretation of corresponding
                            documents.<sup>[<a id="chapter-8-endnote-18" href="#ftn.chapter-8-endnote-18" epub:type="noteref" class="footnote">455</a>]</sup></p><p>The <abbr class="abbrev">XML</abbr> family offers several mechanisms to create
                        inclusion relationships: by employing element references; by way of entity
                        definition and reference; by using XInclude or XLink. These inclusions and
                        references can also inform the XML Infoset, if they are processed.</p><p>Any <abbr class="abbrev">XML</abbr> node may refer to another node simply by
                        referencing it by its assigned ID. Assuming attributes are declared, the
                        Infoset exposes this information as a <span class="italic">references</span> property as an ordered list of element
                        information items. That is to say that an element may contain other element
                        nodes by subordination, or by reference.<sup>[<a id="id654993" href="#ftn.id654993" epub:type="noteref" class="footnote">456</a>]</sup></p><p>XInclude <span class="quote">“<span class="quote">specifies a processing model and syntax for general
                            purpose inclusion. Inclusion is accomplished by merging a number of XML
                            information sets into a single composite infoset.</span>”</span> XInclude
                        offers the most versatile mechanism for addressing whole documents, specific
                        information items, ranges of information items, and even parts of
                        information items, which has led to its widespread adoption in document processing.<sup>[<a id="id655098" href="#ftn.id655098" epub:type="noteref" class="footnote">457</a>]</sup></p><p>XLink <span class="quote">“<span class="quote">allows elements to be inserted into XML documents in order to
                            create and describe links between resources. It uses XML syntax to
                            create structures that can describe links similar to the simple
                            unidirectional hyperlinks of today’s HTML, as well as more sophisticated
                            links.</span>”</span><sup>[<a id="id655115" href="#ftn.id655115" epub:type="noteref" class="footnote">458</a>]</sup></p><p>Entities are similar to macros found in many programming languages; a
                        value is assigned to a token, the token is referenced wherever the value is
                        needed, and macro expansion happens when the XML document instance is read
                        into the Infoset.<sup>[<a id="id655141" href="#ftn.id655141" epub:type="noteref" class="footnote">459</a>]</sup> Entities are a handy feature, but since they are expanded on
                        their way in, entities do not survive as information items in the
                            <abbr class="abbrev">XML</abbr> Infoset. The ID/IDREF feature is more popular than
                        the use of entities because it carries more information into the
                            <abbr class="abbrev">XML</abbr> Infoset.</p></div><p><a id="id655202" class="indexterm"/>Using schemas to define data representation formats is a good practice that
                    facilitates shared understanding and contributes to long-term maintainability in
                    institutional or business contexts. An <abbr class="abbrev">XML</abbr> schema represents a
                    contract among the parties subscribing to its definitions, whereas
                        <abbr class="abbrev">JSON</abbr> depends on out-of-band communication among
                    programmers. The notion that <span class="quote">“<span class="quote">the code is the documentation</span>”</span> may be
                    fashionable among programmers, but modelers prefer to design at a higher level
                    of abstraction and then implement.</p><p>The <abbr class="abbrev">XML</abbr> Infoset presents a strong contrast to
                        <abbr class="abbrev">JSON</abbr> and does not always map in a straightforward way to
                    the data structures used in popular web scripting languages. Whereas
                        <abbr class="abbrev">JSON</abbr>’s structures make it easier for object-oriented
                    programmers to readily exchange data, they lack any formal schema language and
                    cannot easily handle mixed content.</p></div><div class="sect3" title="RDF"><div class="titlepage"><div><div><h4 class="title" id="section-8.2.2.3">RDF</h4></div></div></div><p>In <a class="xref" href="ch08.html#chapter-8-figure-8-4" title="Figure 8-4. Descriptions Linked into a Graph.">Figure 8-4</a>, we structured our
                    resource description as a graph by treating resources, properties and values as
                    nodes, with edges reflecting their combination into descriptive statements.
                    However, a more common approach is to treat resources and values as nodes, and
                    properties as the edges that connect them. <a class="xref" href="ch08.html#chapter-8-figure-8-6" title="Figure 8-6. Treating Properties as Edges Rather Than Nodes.">Figure 8-6</a> shows the same description as <a class="xref" href="ch08.html#chapter-8-figure-8-4" title="Figure 8-4. Descriptions Linked into a Graph.">Figure 8-4</a>, 
                    this time with properties treated as edges.
                    This roughly corresponds to the particular kind of graph metamodel defined by
                        <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_RDF"><em class="glossterm">RDF</em></a></strong></span>. (<a class="xref" href="ch04.html#section-4.2.2.3" title="Tagging of Web-Based Resources">Tagging of Web-Based Resources</a>
                    introduces <abbr class="abbrev">RDF</abbr>.)</p><div class="figure-float"><div class="figure"><a id="chapter-8-figure-8-6"/><div class="figure-contents"><div class="mediaobject"><a id="chapter-8-figure-8-6a"/><img src="figs/print/ch8.6-350dpi.png" alt="We can treat each component of a description as &#10;                            a pair of nodes (a resource and a value) with an edge (the property) linking them.&#10;                        Here, we have two book resources that are related to four values through five properties.&#10;                        The single value node, Winfried George Sebald is the subject of one book&#10;                        while being the author of the second book. The books are depicted as boxes, &#10;                        the edges as labeled arrows and the values as text strings."/></div></div><div class="figure-title">Figure 8-6. Treating Properties as Edges Rather Than Nodes.</div></div></div><p>We have noted that we can treat a graph as a set of pairs of nodes, where each
                    pair may be connected by an edge. Similarly, we can treat each component of the
                    description in <a class="xref" href="ch08.html#chapter-8-figure-8-6" title="Figure 8-6. Treating Properties as Edges Rather Than Nodes.">Figure 8-6</a> as a
                    pair of nodes (a resource and a value) with an edge (the property) linking them.
                        <a id="id655364" class="indexterm"/><a id="id655347" class="indexterm"/><span><a id="def_triple"/>In the RDF metamodel, a pair of nodes and
                        its edge is called a <span class="strong"><strong><a class="glossterm" id="term_triple" href="go01.html#gloss_triple"><em class="glossterm">triple</em></a></strong></span>, because it consists of three parts
                        (two nodes and one edge). The RDF metamodel is a directed graph, so it
                        identifies one node (the one from which the edge is pointing) as the
                            <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_subject"><em class="glossterm">subject</em></a></strong></span> of the triple,
                        and the other node (the one to which the edge is pointing) as its <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_object"><em class="glossterm">object</em></a></strong></span>. The edge is referred to as the
                            <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_predicate"><em class="glossterm">predicate</em></a></strong></span> or (as we
                        have been saying) <span class="emphasis"><em><a class="glossterm" href="go01.html#gloss_property"><em class="glossterm">property</em></a></em></span> of the
                        triple.</span></p><div class="figure-float"><div class="figure"><a id="chapter-8-figure-8-7"/><div class="figure-contents"><div class="mediaobject"><a id="chapter-8-figure-6a"/><img src="figs/print/ch8.7-350dpi.png" alt="Lists each of the triples individually.&#10;                            Here, each statements relates one resource to one value through an edge.&#10;                            Thus, we have two distinct Winfried George Sebald value nodes. &#10;                            The books are depicted as boxes, &#10;                            the edges as labeled arrows and the values as text strings."/></div></div><div class="figure-title">Figure 8-7. Listing Triples Individually.</div></div></div><p><a class="xref" href="ch08.html#chapter-8-figure-8-7" title="Figure 8-7. Listing Triples Individually.">Figure 8-7</a> lists separately all the triples in
                        <a class="xref" href="ch08.html#chapter-8-figure-8-6" title="Figure 8-6. Treating Properties as Edges Rather Than Nodes.">Figure 8-6</a> 
                    However, there is something missing in <a class="xref" href="ch08.html#chapter-8-figure-8-7" title="Figure 8-7. Listing Triples Individually.">Figure 8-7</a> 
                    <a class="xref" href="ch08.html#chapter-8-figure-8-6" title="Figure 8-6. Treating Properties as Edges Rather Than Nodes.">Figure 8-6</a> clearly indicates that the
                        <span class="emphasis"><em>Winfried George Sebald</em></span> who is the subject of book 1 is
                    the same <span class="emphasis"><em>Winfried George Sebald</em></span> who is the author of book
                    2. In <a class="xref" href="ch08.html#chapter-8-figure-8-7" title="Figure 8-7. Listing Triples Individually.">Figure 8-7</a> this relationship is not clear.
                    How can we tell if the <span class="emphasis"><em>Winfried George Sebald</em></span> of the third
                    triple is the same as the <span class="emphasis"><em>Winfried George Sebald</em></span> of the
                    triple statement? For that matter, how can we tell if the first three triples
                    all involve the same book 1? This is easy to show in a diagram of the entire
                    description graph, where we can have multiple edges attached to a node. But when
                    we disaggregate that graph into triples, we need some way of uniquely referring
                    to nodes. We need identifiers (<a class="xref" href="ch03.html#section-3.4.3" title="Choosing Good Names and Identifiers">Choosing Good Names and Identifiers</a>). When two
                    triples have nodes with the same identifier, we can know that it is the same
                    node. RDF achieves this by associating URIs with nodes (<a class="xref" href="ch04.html#section-4.2.2.3" title="Tagging of Web-Based Resources">Tagging of Web-Based Resources</a>).</p><p>The need to identify nodes when we break down an <abbr class="abbrev">RDF</abbr> graph
                    into triples becomes important when we want to <span class="quote">“<span class="quote">write</span>”</span>
                    <abbr class="abbrev">RDF</abbr> graphs<span class="symbol">—</span>create textual
                    representations of them instead of depicting them<span class="symbol">—</span>so that
                    they can be exchanged as data. Tree structures do not necessarily have this
                    problem, because it is possible to textually represent a tree structure without
                    having to mention any node more than once. Thus, one price paid for the
                    generality and flexibility of graph structures is the added complexity of
                    recording, representing or writing those structures.</p></div><div class="sect3" title="Choosing Your Constraints"><div class="titlepage"><div><div><h4 class="title" id="section-8.2.2.4">Choosing Your Constraints</h4></div></div></div><p><a id="id655582" class="indexterm"/><a id="id655590" class="indexterm"/>This tradeoff between flexibility and complexity illustrates a more
                    general point about constraints. In the context of managing and interacting with
                    resource descriptions, constraints are a good thing. As discussed above, a tree
                    is a graph with very specific constraints. These constraints allow you to do
                    things with trees that are not possible with graphs in general, such as
                    representing them textually without repeating yourself, or uniquely identifying
                    nodes by the path from the root of the tree to that node. This can make managing
                    descriptions and the resources they describe easier and more
                        efficient<span class="symbol">—</span><span class="emphasis"><em>if</em></span> a tree structure is
                    a good fit to the requirements of the organizing system. For example, an ordered
                    tree structure is a good fit for the hierarchical structure of the content of a
                    book or book-like document, such as an aircraft service manual or an SEC filing.
                    On the other hand, the network of relationships among the people and
                    organizations that collaborated to produce a book might be better represented
                    using a graph structure. <abbr class="abbrev">XML</abbr> is most often used to represent
                    hierarchies, but is also capable of representing network structures.</p></div></div><div class="sect2" title="Modeling within Constraints"><div class="titlepage"><div><div><h3 class="title" id="section-8.2.3">Modeling within Constraints</h3></div></div></div><p><a id="id655630" class="indexterm"/>A metamodel imposes certain constraints on the structure of our resource
                descriptions. But in organizing systems, we usually need to further specify the
                content and composition of descriptions of the specific types of resources being
                organized. For example, when designing a system for organizing books, it is not
                sufficient to say that a book’s description is structured using
                <abbr class="abbrev">XML</abbr>, because the <abbr class="abbrev">XML</abbr> metamodel constrains
                structure and not the content of descriptions. We need also to specify that a book
                description includes a list of contributors, each entry of which provides a name and
                indicates the role of that contributor. This kind of specification is a
                    <span class="emphasis"><em>model</em></span> to which our descriptions of books are expected to
                conform (<a class="xref" href="ch04.html#section-4.3.1.2" title="Abstraction in Resource Description">Abstraction in Resource Description</a>).</p><p><a id="id655692" class="indexterm"/>When designing an organizing system we may choose to reuse a standard
                model. For example, <span class="citerefentry"><span class="refentrytitle"><abbr class="abbrev">ONIX</abbr> for Books</span></span> is a standard model (conforming to the <abbr class="abbrev">XML</abbr>
                metamodel) developed by the publishing industry for describing books.<sup>[<a id="chapter-8-endnote-19" href="#ftn.chapter-8-endnote-19" class="footnote">460</a>]</sup></p><p><a id="id655682" class="indexterm"/>If no such standard exists, or existing standards do not suit our needs, we may
                create a new model for our specific domain. But we will not usually create a new
                metamodel: instead we will make choices from among the metamodels, such as
                    <abbr class="abbrev">JSON</abbr>, <abbr class="abbrev">XML</abbr>, or <abbr class="abbrev">RDF</abbr>, that have
                been formally recognized and incorporated into existing standards. Once we have
                selected a metamodel, we know the constraints we have to work with when modeling the
                resources and collections in our specific domain.<sup>[<a id="chapter-8-endnote-20" href="#ftn.chapter-8-endnote-20" epub:type="noteref" class="footnote">461</a>]</sup></p><div class="sect3" title="Specifying Vocabularies and Schemas"><div class="titlepage"><div><div><h4 class="title" id="section-8.2.3.1">Specifying Vocabularies and Schemas</h4></div></div></div><p>Creating a model for descriptions of resources in a particular domain involves
                    specifying the common elements of those descriptions, and giving those elements
                    standard names (see <a class="xref" href="ch04.html#section-4.3" title="The Process of Describing Resources">The Process of Describing Resources</a>). The model may also specify
                    how these elements are arranged into larger structures, for example how they are
                    ordered into lists nested into trees. Metamodels vary in the tools they provide
                    for specifying the structure and composition of domain-specific models, and in
                    the maturity and robustness of the methods for designing them.<sup>[<a id="chapter-8-endnote-21" href="#ftn.chapter-8-endnote-21" epub:type="noteref" class="footnote">462</a>]</sup>
                    <abbr class="abbrev">RDF</abbr> and <abbr class="abbrev">XML</abbr> each provide different,
                    metamodel-specific tools to define a model for a specific domain. But not every
                    metamodel provides such tools.</p><p>In <abbr class="abbrev">XML</abbr>, models are defined in separate documents known as
                        <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_schema"><em class="glossterm">schemas</em></a></strong></span>. An <abbr class="abbrev">XML</abbr> schema defining
                    a domain model provides a vocabulary of terms that can be used as element and
                    attribute names in <abbr class="abbrev">XML</abbr> documents that adhere to that model. For
                    example, the <span class="citerefentry"><span class="refentrytitle">Onix for Books</span></span> schema specifies that an author of a book should be called a
                        <code class="literal">Contributor</code>, and that the page count should be called an
                        <code class="literal">Extent</code>. An <abbr class="abbrev">XML</abbr> schema also defines rules
                    for how those elements, attributes, and their content can be arranged into
                    higher-level structures. For example, the <span class="citerefentry"><span class="refentrytitle">Onix for Books</span></span> specifies that the description of a book must include a list of
                        <code class="literal">Contributor</code> elements, that this list must have at least
                    one element in it, and that each <code class="literal">Contributor</code> element must
                    have a <code class="literal">ContributorRole</code> child element.</p><p>If an <abbr class="abbrev">XML</abbr> schema is given an identifier, <abbr class="abbrev">XML</abbr>
                    documents can use that identifier to indicate that they use terms and rules from
                    that schema. An <abbr class="abbrev">XML</abbr> document may use vocabularies from more
                    than one <abbr class="abbrev">XML</abbr> schema.<sup>[<a id="chapter-8-endnote-22" href="#ftn.chapter-8-endnote-22" epub:type="noteref" class="footnote">463</a>]</sup> Associating a schema with an <abbr class="abbrev">XML</abbr> instance enables
                        <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_validation"><em class="glossterm">validation</em></a></strong></span>: automatically
                    checking that vocabulary terms are being used correctly.<sup>[<a id="chapter-8-endnote-23" href="#ftn.chapter-8-endnote-23" epub:type="noteref" class="footnote">464</a>]</sup></p><p>If two descriptions share the same <abbr class="abbrev">XML</abbr> schema and use only
                    that schema, then combining them is straightforward. If not, it can be
                    problematic, unless someone has figured out exactly how the two schemas should
                        <span class="quote">“<span class="quote">map</span>”</span> to one another. Finding such a mapping is not a trivial
                    problem, as <abbr class="abbrev">XML</abbr> schemas may differ semantically, lexically,
                    structurally, or architecturally despite sharing a common implementation form
                    (see <a class="xref" href="ch05.html" title="Chapter 5. Describing Relationships and Structures">Chapter 5</a>).</p><p>Tree structures can vary considerably while still conforming to the
                        <abbr class="abbrev">XML</abbr> Infoset metamodel. Users of <abbr class="abbrev">XML</abbr> often
                    specify rules for checking whether certain patterns appear in an
                        <abbr class="abbrev">XML</abbr> document (document-level validation). This is less
                    often done with <abbr class="abbrev">RDF</abbr>, because graphs that conform to the
                        <abbr class="abbrev">RDF</abbr> metamodel all have the same structure: they are all
                    sets of triples. This shared structure makes it simple to combine different RDF
                    descriptions without worrying about checking structure at the document level.
                    However, sometimes it is desirable to check descriptions at the document level,
                    as when part of a description is required. As with <abbr class="abbrev">XML</abbr>, if
                    consumers of those descriptions want to assert that they expect those
                    descriptions to have a certain structure (such as a required property), they
                    must check them at the document level.</p><p>Because the <abbr class="abbrev">RDF</abbr> metamodel already defines structure, defining
                    a domain-specific model in <abbr class="abbrev">RDF</abbr> mainly involves specifying
                        <abbr class="abbrev">URI</abbr>s and names for predicates. <span><a id="def_RDF_vocabulary"/>A set of <abbr class="abbrev">RDF</abbr> predicate names and
                            <abbr class="abbrev">URI</abbr>s is known as an <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_RDF_vocabulary"><em class="glossterm">RDF
                                vocabulary</em></a></strong></span>.</span> Publication of
                    vocabularies on the web and the use of <abbr class="abbrev">URI</abbr>s to identify and
                    refer to predicate definitions are key principles of Linked Data and the
                        <a class="glossterm" href="go01.html#gloss_semantic_web"><em class="glossterm">Semantic Web</em></a> (see <a class="xref" href="ch05.html#section-5.8.1" title="The Semantic Web and Linked Data">The Semantic Web and Linked Data</a>, as well as later in this
                        chapter).<sup>[<a id="chapter-8-endnote-24" href="#ftn.chapter-8-endnote-24" class="footnote">465</a>]</sup></p><p><a id="id656236" class="indexterm"/><a id="id656293" class="indexterm"/>For example, the <span class="citerefentry"><span class="refentrytitle">Resource Description and Access</span>(RDA)</span> standard for cataloging library resources includes a set of
                        <abbr class="abbrev">RDF</abbr> vocabularies defining predicates usable in cataloging
                    descriptions. One such predicate is:</p><a id="pro_id00001"/><pre class="programlisting">        &lt;http://rdvocab.info/Elements/extentOfText&gt;</pre><p>which is defined as <span class="quote">“<span class="quote">the number and type of units and/or subunits making
                        up a resource consisting of text, with or without accompanying
                        illustrations.</span>”</span> The vocabulary further specifies that this predicate
                    is a refinement of a more general predicate:</p><a id="pro_id00002"/><pre class="programlisting">        &lt;http://rdvocab.info/Elements/extent&gt;</pre><p>which can be used to indicate, <span class="quote">“<span class="quote">the number and type of units and/or
                        subunits making up a resource</span>”</span> regardless of whether it is textual or
                    not.</p><p><abbr class="abbrev">JSON</abbr> lacks any standardized way to define which terms can be
                    used. That does not mean that one cannot use a standard vocabulary when creating
                    descriptions using <abbr class="abbrev">JSON</abbr>, only that there is no agreed-upon way
                    to use <abbr class="abbrev">JSON</abbr> to communicate which vocabulary is being used, and
                    no way to automatically check that it is being used correctly.</p></div><div class="sect3" title="Controlling Values"><div class="titlepage"><div><div><h4 class="title" id="section-8.2.3.2">Controlling Values</h4></div></div></div><p>So far, we have focused on how models specify vocabularies of terms and how
                    those terms can be used in descriptions. But models may also constrain the
                    values or content of descriptions. Sometimes, a single model will define both
                    the terms that can be used for property names and the terms that can be used for
                    property values. For example, an <abbr class="abbrev">XML</abbr> schema may enumerate a
                    list of valid terms for an attribute value.<sup>[<a id="id656395" href="#ftn.id656395" epub:type="noteref" class="footnote">466</a>]</sup></p><p>Often, however, there are separate, specialized vocabularies of terms intended
                    for use as property values in resource descriptions. Typically these
                    vocabularies provide values for use within statements that describe what a
                    resource is about.<a id="id656431" class="indexterm"/><a id="id656418" class="indexterm"/> Examples of such subject vocabularies include the <span class="citerefentry"><span class="refentrytitle">Library of Congress Subject Headings</span>(LOC-SH)</span> and the <em class="firstterm"><a id="first_MESH"/><span class="citerefentry"><span class="refentrytitle">Medical Subject Headings</span>(MeSH)</span></em>.<sup>[<a id="chapter-8-endnote-21a" href="#ftn.chapter-8-endnote-21a" class="footnote">467</a>]</sup> Other vocabularies may provide authoritative names for people,
                    corporations, or places. Classification schemes are yet another kind of
                    vocabulary, providing the category names for use as the values in descriptive
                    statements that classify resources.</p><p>Because different metamodels such as <abbr class="abbrev">XML</abbr> and
                        <abbr class="abbrev">RDF</abbr> take different approaches to specifying vocabularies,
                    there will usually be different versions of these vocabularies for use with
                    different metamodels. <a id="id656543" class="indexterm"/><a id="id656547" class="indexterm"/><a id="id656552" class="indexterm"/> For example the <abbr class="abbrev">LCSH</abbr> are available both as
                        <abbr class="abbrev">XML</abbr> conforming to the <em class="firstterm"><a id="first_MADS"/><span class="citerefentry"><span class="refentrytitle">Metadata Authority Description Standard</span>(MADS)</span></em> schema, and as <abbr class="abbrev">RDF</abbr> using the
                        <em class="firstterm"><a id="first_SKOS"/><span class="citerefentry"><span class="refentrytitle">Simple Knowledge Organization System</span>(SKOS)</span></em> vocabulary.</p><p>Specifying a vocabulary is just one way models can control what values can be
                    assigned to properties. Another strategy is to specify what <span class="quote">“<span class="quote">types</span>”</span> of values can be assigned. For example, a model for book
                    descriptions may specify that the value of a <span class="emphasis"><em>pages</em></span> property
                    must be a positive integer. Or it could be more specific; a course catalog might
                    give each course an identifier that contains a two-letter department code
                    followed by a 1-3 digit course number. Specifying a data type like this with a
                        <a class="glossterm" href="go01.html#gloss_regular_expressions"><em class="glossterm">regular
                        expression</em></a> narrows down the set of possible values for the
                    property without having to enumerate every possible value. (See the
                    Sidebar.)</p><p><a id="id656618" class="indexterm"/><a id="id656644" class="indexterm"/>In addition to or in lieu of specifying a type, a model may specify
                    an encoding scheme for values. <span><a id="def_encoding_scheme"/>An <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_encoding_scheme"><em class="glossterm">encoding
                                scheme</em></a></strong></span> is a specialized <a class="glossterm" href="go01.html#gloss_writing_system"><em class="glossterm">writing system</em></a> or syntax for
                        particular types of values.</span> For example, a model like Atom for
                    describing syndicated web content requires a publication date. But there are
                    many different ways to write dates: <code class="literal">9/2/76</code>, <code class="literal">2 Sept.
                        1976</code>, <code class="literal">September 2nd 1976</code>, etc. So, Atom also
                    specifies an encoding scheme for date values. The encoding scheme is <span class="citerefentry"><span class="refentrytitle">RFC3339</span></span>, a standard for writing dates. When using <span class="citerefentry"><span class="refentrytitle">RFC3339</span></span>, one always writes a date using the same form:
                        <code class="literal">1976-09-02</code>.<sup>[<a id="chapter-8-endnote-25" href="#ftn.chapter-8-endnote-25" class="footnote">468</a>]</sup></p><p><a id="id656756" class="indexterm"/></p><div class="sidebar"><a id="sidebar-regular_expressions"/><div class="sidebar-title">Regular Expressions</div><p><a class="glossterm" href="go01.html#gloss_regular_expressions"><em class="glossterm">Regular
                            expressions</em></a> have been used to describe patterns in text
                        documents since the early days of computing and came into widespread use
                        when Ken Thompson incorporated them into early UNIX text processing tools,
                        such as <span class="italic"><span class="application">ed</span></span> and
                            <span class="italic"><span class="application">grep</span></span>.
                        There are too many variations of regular expression syntax for us to detail
                        them here, but it is worthwhile to consider them briefly while we are on the
                        subject of controlling values.<sup>[<a id="id656803" href="#ftn.id656803" class="footnote">469</a>]</sup></p><p>Regular expressions are employed by modern text processing tools for
                        selection and retrieval purposes. In search and replace applications, one
                        might search for the string <span class="quote">“<span class="quote"><code class="literal">Chapter [1-5]</code></span>”</span>
                        to express your intent to select chapters 1 through 5, or
                                <span class="quote">“<span class="quote"><code class="literal">it[']?s</code></span>”</span> to locate every use of
                            <span class="quote">“<span class="quote">it’s</span>”</span> and <span class="quote">“<span class="quote">its</span>”</span> in a manuscript; this
                        capability is highly valued by anyone who has to had edit a book.
                        Programmers and data modelers use regular expressions to describe expected
                        encoding schemes when they design documents, data elements, databases, and
                        encoding schemes. You experience regular expression processing when you
                        enter a phone number or postal code into a Web-based form. Many data
                        modeling, programming and XML schema languages employ regular expressions to
                        control data entry and validation of values. In the context of controlling
                        values, we can use regular expressions to describe data values as varied as
                        identifiers, names, dates, telephone numbers, and postal codes. We can,
                        likewise, define rules for white space handling and punctuation within a
                        data value.</p></div><p><a id="id656862" class="indexterm"/>Encoding schemes are often defined in conjunction with standardized
                    identifiers (see <a class="xref" href="ch03.html#section-3.4.3.1" title="Make Names Informative">Make Names Informative</a>). For example, <span><a id="ref_ISBN"/><span class="citerefentry"><span class="refentrytitle">International Standard Book Numbers</span>(ISBN)</span></span> are not just sequences of Arabic numerals: they are
                    values written using the <abbr class="abbrev">ISBN</abbr> encoding scheme. This scheme
                    specifies how to separate the sequence of numerals into parts, and how each of
                    these parts should be interpreted. The ISBN <code class="literal">978-3-8218-4448-0</code>
                    has five parts, the first three of which indicate that the resource with this
                    identifier is 1) a product of the book publishing industry, 2) published in a
                    German-speaking country, and 3) published by the publishing house
                        <span class="orgname">Eichborn</span>.</p><p>Encoding schemes can be viewed as very specialized models of particular kinds
                    of information, such as dates or book identifiers. But because they specify not
                    only the structure of this information, but also how it should be written, we
                    can also view them as specialized <a class="glossterm" href="go01.html#gloss_writing_system"><em class="glossterm">writing systems</em></a>. That is, encoding schemes specify how to
                        <span class="emphasis"><em>textually represent</em></span> information.</p><p>In the second half of this chapter, we will focus on the issues involved in
                    textually representing resource descriptions<span class="symbol">—</span>writing
                    them. Graphs, trees, dictionaries, lists, and sets are general types of
                    structures found in different metamodels. Thinking about these broad types and
                    how they fit or do not fit the ways we want to model our resource descriptions
                    can help us select a specific metamodel. Specific metamodels such as the
                        <abbr class="abbrev">XML</abbr> Infoset or <abbr class="abbrev">RDF</abbr> are formalized and
                    standardized definitions of the more general types of structures discussed
                    above. Once we have selected a metamodel, we know the constraints we have to
                    work with when modeling the <a class="glossterm" href="go01.html#gloss_resource"><em class="glossterm">resources</em></a> and collections in our specific domain. But because
                    metamodels are abstract and exist only on a conceptual level, they can only take
                    us so far. If we want to create, store, and exchange individual resource
                    descriptions, we need to make the structures defined by our abstract metamodels
                    concrete. We need to write them.</p></div></div></div><div class="sect1" title="Writing Descriptions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="section-8.3">Writing Descriptions</h2></div></div></div><p>Suppose that I am organizing books, and I have decided that it is important for the
            purposes of this organizing to know the title of each book and how many pages it has.
            Before me I have a book, which I examine to determine that its title is <em class="citetitle">Die
                Ringe des Saturn</em> and it has 371 pages. <a class="xref" href="ch08.html#chapter-8-table-8-1" title="Table 8-1. Basic ways of writing part of a book description.">Table 8-1</a> lists a few of the ways to write this description.
            Let us examine these various forms of writing to see what they have in common and where
            they differ.</p><div class="table"><a id="chapter-8-table-8-1"/><div class="table-title">Table 8-1. Basic ways of writing part of a book description.</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/></colgroup><tbody><tr><td style="text-align: center; border-bottom: 0.5pt solid ; ">
                            <p>The title is <span class="emphasis"><em>Die Ringe des Saturn</em></span> and it has
                                371 pages.</p>
                        </td></tr><tr><td style="border-bottom: 0.5pt solid ; ">
                            <a id="pro_id00003"/><pre class="programlisting">{ book {"title":"Die Ringe des Saturn","pages":371} }</pre>
                        </td></tr><tr><td style="border-bottom: 0.5pt solid ; ">
                            <pre class="programlisting">&lt;book pages="371"&gt; &lt;title&gt;Die Ringe des Saturn&lt;/title&gt; &lt;/book&gt;</pre>
                        </td></tr><tr><td style="border-bottom: 0.5pt solid ; ">
                            <pre class="programlisting">&lt;div class="book"&gt;The title is 
&lt;span class="title"&gt;Die Ringe des Saturn&lt;/span&gt;
and it has &lt;span class="pages"&gt;371 pages.&lt;/span&gt;</pre>
                        </td></tr><tr><td>
                            <a id="pro_id00005"/><pre class="programlisting">&lt;http://lccn.loc.gov/96103072&gt;
&lt;http://rdvocab.info/Elements/title&gt; "Die Ringe des Saturn"@de ;
&lt;http://rdvocab.info/Elements/extentOfText&gt; "371 p." .</pre>
                        </td></tr></tbody></table></div></div><p>We examine the notations, writing systems and syntax of each of the examples in the following sections.</p><div class="sect2" title="Notations"><div class="titlepage"><div><div><h3 class="title" id="section-8.3.1">Notations</h3></div></div></div><p><a id="id657306" class="indexterm"/>First, let us look at the actual marks on the page. To write you must
                make marks or<span class="symbol">—</span>more likely<span class="symbol">—</span>select from
                a menu of marks using a keyboard. In either case, you are using a <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_notation"><em class="glossterm">notation</em></a></strong></span>: <span><a id="def_notation"/>a set of
                    characters with distinct forms.</span><sup>[<a id="chapter-8-endnote-26" href="#ftn.chapter-8-endnote-26" epub:type="noteref" class="footnote">470</a>]</sup> The Latin alphabet is a notation, as are Arabic numerals. Some more
                exotic notations include the symbols used for editorial markup and alchemical
                    symbols.<sup>[<a id="chapter-8-endnote-27" href="#ftn.chapter-8-endnote-27" class="footnote">471</a>]</sup> The characters in a notation usually have an ordering. Arabic numerals
                are ordered <span class="emphasis"><em>1 2 3</em></span> and so on. English-speaking children usually
                learn the ordering of the Latin alphabet in the form of an alphabet song.<sup>[<a id="chapter-8-endnote-28" href="#ftn.chapter-8-endnote-28" epub:type="noteref" class="footnote">472</a>]</sup></p><p>A character may belong to more than one notation. The examples in <a class="xref" href="ch08.html#chapter-8-table-8-1" title="Table 8-1. Basic ways of writing part of a book description.">Table 8-1</a> use characters from a few
                different notations: the letters of the Latin alphabet, Arabic numerals, and a
                handful of auxiliary marks: <code class="literal">. { } " :&lt; &gt; / $</code> Collectively,
                all of these characters<span class="symbol">—</span>alphabet, numerals, and auxiliary
                    marks<span class="symbol">—</span>also belong to a notation called the <a id="id657450" class="indexterm"/><span class="citerefentry"><span class="refentrytitle">American Standard Code for Information
                        Interchange</span>(ASCII)</span>.<sup>[<a id="chapter-8-endnote-29" href="#ftn.chapter-8-endnote-29" class="footnote">473</a>]</sup></p><p><a id="id657507" class="indexterm"/><abbr class="abbrev">ASCII</abbr> is an example of a notation
                that has been codified and standardized for use in a digital environment. A
                traditional notation like the Latin alphabet can withstand a certain degree of
                variation in the form of a particular mark. Two people might write the letter
                    <span class="emphasis"><em>A</em></span> rather differently, but as long as they can mutually
                recognize each other’s marks as an <span class="quote">“<span class="quote">A,</span>”</span> they can successfully share a
                notation. Computers, however, cannot easily accommodate such variation. Each
                character must be strictly defined. In the case of <abbr class="abbrev">ASCII</abbr>, each
                character is given a number from 0 to 127, so that there are 128 <abbr class="abbrev">ASCII</abbr> characters.<sup>[<a id="chapter-8-endnote-30" href="#ftn.chapter-8-endnote-30" epub:type="noteref" class="footnote">474</a>]</sup> When using a computer to type <abbr class="abbrev">ASCII</abbr>
                characters, each key you press selects a character from this <span class="quote">“<span class="quote">menu</span>”</span> of
                128 characters. <a id="id657588" class="indexterm"/><a id="id657603" class="indexterm"/><span><a id="def_character_encoding"/>A notation that has had numbers
                    assigned to its characters is called a <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_character_encoding"><em class="glossterm">character encoding</em></a></strong></span>.</span></p><p><a id="id657635" class="indexterm"/>The most ambitious character coding in existence is Unicode, which as of
                version 6.0 assigns numbers to 109,449 characters.<sup>[<a id="chapter-8-endnote-31" href="#ftn.chapter-8-endnote-31" class="footnote">475</a>]</sup>
                <span><a id="def_character"/>Unicode makes the important distinction between <span class="strong"><strong><em class="glossterm">characters</em></strong></span> and <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_glyph"><em class="glossterm">glyphs</em></a></strong></span>. A character is the
                    smallest meaningful unit of a written language. In alphabet-based languages like
                    English, characters are letters; in languages like Chinese, characters are
                    ideographs.</span> Unicode treats all of these characters as abstract ideas
                    (<span class="emphasis"><em>Latin capital A</em></span>) rather than specific marks (A <span class="italic">A</span>
                <code class="literal">A</code>
                <span class="bold"><strong>A</strong></span>). <a id="id657717" class="indexterm"/><a id="id657728" class="indexterm"/><a id="id657747" class="indexterm"/><span><a id="def_glyph"/>A specific mark that can be used to depict a
                    character is a glyph.</span>
                <a id="id657768" class="indexterm"/><a id="id657780" class="indexterm"/><span><a id="def_font"/>A <span class="bold"><strong><a class="glossterm" href="go01.html#gloss_font"><em class="glossterm">font</em></a></strong></span> is a
                    collection of glyphs used to depict some set of characters. A Unicode font
                    explicitly associates each glyph with a particular number in the Unicode
                    character encoding.</span> The inability of computers to use contextual
                understanding to bridge the gap between various glyphs and the abstract character
                depicted by those glyphs turns out to have important consequences for organizing
                systems.</p><p><a id="id657853" class="indexterm"/><a id="id657813" class="indexterm"/><a id="id657825" class="indexterm"/>Different notations may include very similar marks. For example, modern
                music notation includes marks for indicating the pitch of note, known as
                accidentals. One of these music notation marks is <span class="symbol">♯</span>
                    (<span class="quote">“<span class="quote">sharp</span>”</span>). The sharp sign looks very much like the symbol used in
                English as an abbreviation for the word <span class="emphasis"><em>number</em></span>, as in
                        <span class="emphasis"><em>We<span class="symbol">’</span>re #1!</em></span><sup>[<a id="chapter-8-endnote-32" href="#ftn.chapter-8-endnote-32" epub:type="noteref" class="footnote">476</a>]</sup> If you were to write a sharp sign and a number sign by hand, they would
                probably look identical. In a non-digital environment, we would rely on context to
                understand whether the written mark was being used as part of music notation, or
                mathematical notation, or as an English abbreviation.</p><p>Computers, however, have no such intuitive understanding of context. Unicode
                encodes the number sign and the sharp sign as two different characters. As far as a
                computer using Unicode is concerned, <span class="symbol">♯</span> and # are completely
                different, and the fact that they have similar-looking glyphs is irrelevant. That is
                a problem if, for example, a cataloger has carefully described a piece of music by
                correctly using the sharp sign, but a person looking for that piece of music
                searches for descriptions using the number sign (since that is what you get when you
                press the keyboard button with the symbol that most closely resembles a sharp
                    sign).<sup>[<a id="chapter-8-endnote-33" href="#ftn.chapter-8-endnote-33" epub:type="noteref" class="footnote">477</a>]</sup></p></div><div class="sect2" title="Writing Systems"><div class="titlepage"><div><div><h3 class="title" id="section-8.3.2">Writing Systems</h3></div></div></div><p><span><a id="def_writing_system"/>A <span class="strong"><strong><a class="glossterm" id="term_writing_system" href="go01.html#gloss_writing_system"><em class="glossterm">writing system</em></a></strong></span> employs
                    one or more notations, and adds a set of rules for using them. Most writing
                    systems assume knowledge of a particular human language. These writing systems
                    are known as <span class="emphasis"><em>glottic</em></span> writing systems. But there are many
                    writing systems, such as mathematical and musical ones, that are not tied to
                    human languages in this way. Many of the writing systems used for describing
                    resources belong to this latter group, meaning that (at least in principle) they
                    can be used with equal facility by speakers of any language.</span></p><p><a id="id658083" class="indexterm"/>Glottic writing systems, being grounded in natural human languages, are difficult
                to describe precisely and comprehensively. Non-glottic writing systems, on the other
                hand, can be described precisely and comprehensively using an abstract model. That
                is the connection between the structural perspective taken in the previous section,
                and the textual perspective taken in this section. A non-glottic writing system is
                described by a particular metamodel, and structures that fit within the constraints
                of a given metamodel can be textually represented using one or more writing systems
                that are described by that metamodel.</p><p>Some writing systems are closely identified with specific metamodels. For example,
                    <abbr class="abbrev">XML</abbr> and <abbr class="abbrev">JSON</abbr> are <span class="emphasis"><em>both</em></span> 1)
                metamodels for structuring information <span class="emphasis"><em>and</em></span> 2) writing systems
                for textually representing information. In other words, they specify both the
                abstract structure of a description and how to write it down. It is possible to
                conceive of other ways to textually represent the structure of these metamodels, but
                for each of these metamodels just one writing system has been standardized.<sup>[<a id="chapter-8-endnote-34" href="#ftn.chapter-8-endnote-34" epub:type="noteref" class="footnote">478</a>]</sup></p><p><abbr class="abbrev">RDF</abbr>, on the other hand, is <span class="emphasis"><em>only</em></span> a metamodel,
                not a writing system. <abbr class="abbrev">RDF</abbr> only defines an abstract structure, not
                how to write that structure. So how do we write information that is structured as
                RDF? It turns out that we have many choices. Unlike <abbr class="abbrev">XML</abbr> and
                    <abbr class="abbrev">JSON</abbr>, several different writing systems for the
                    <abbr class="abbrev">RDF</abbr> metamodel have been standardized, including N-Triples,
                Turtle, RDFa, and RDF/XML.<sup>[<a id="chapter-8-endnote-35" href="#ftn.chapter-8-endnote-35" epub:type="noteref" class="footnote">479</a>]</sup> Each of these is a writing system that is abstractly described by the
                    <abbr class="abbrev">RDF</abbr> metamodel.</p><p><a id="id658215" class="indexterm"/>Writing systems provide rules for arranging characters from a notation
                into meaningful structures. A character in a notation has no inherent meaning.
                Characters in a notation only take on meaning in the context of a writing system
                that uses that notation. For example: what does the letter
                        <span class="emphasis"><em><span class="symbol">I</span></em></span> from the Latin alphabet mean? That
                question can only be answered by looking at how it is being used in a particular
                writing system. If the writing system is American English, then whether
                        <span class="emphasis"><em><span class="symbol">I</span></em></span> has a meaning depends on whether it
                is grouped with other letters or whether it stands alone. Only in the latter case
                does it have an assignable meaning. However in the arithmetic writing system of
                Ancient Rome, which also uses as a notation the letters of the Latin alphabet,
                        <span class="emphasis"><em><span class="symbol">I</span></em></span> has a different meaning:
                    <span class="emphasis"><em>one</em></span>.</p><p><a id="id658290" class="indexterm"/>This example also serves to illustrate how the ordering of a notation
                can differ from the ordering of a writing system that uses that notation. According
                to the ordering of the Latin alphabet, the twelfth letter
                        <span class="emphasis"><em><span class="symbol">L</span></em></span> comes before the twenty-second
                letter <span class="emphasis"><em><span class="symbol">V</span></em></span>. But in the Roman numeric writing
                system, <span class="emphasis"><em><span class="symbol">V</span></em></span> (the number 5) comes before
                        <span class="emphasis"><em><span class="symbol">L</span></em></span> (the number 50). Unless we know
                which ordering we are using, we cannot arrange
                    <span class="emphasis"><em><span class="symbol">L</span></em></span> and
                    <span class="emphasis"><em><span class="symbol">V</span></em></span>
                <span class="quote">“<span class="quote">in order.</span>”</span><sup>[<a id="chapter-8-endnote-36" href="#ftn.chapter-8-endnote-36" epub:type="noteref" class="footnote">480</a>]</sup></p><p>This kind of difference in ordering can arise in more subtle ways as well. When we
                alphabetically order names, we first compare the first character of each name, and
                arrange them according to the ordering of the writing system. <a id="id658289" class="indexterm"/>The first known use of alphabetical ordering was in the Library of
                Alexandria about two thousand years ago, when Zenodetus arranged the collection
                according to the first letter of resource names.<sup>[<a id="chapter-8-endnote-37" href="#ftn.chapter-8-endnote-37" epub:type="noteref" class="footnote">481</a>]</sup> If the first characters of two names are the same, we compare the second
                character, and so on. We can also apply this same kind of ordering procedure to
                sequences of numerals. If we do, then <span class="emphasis"><em>334</em></span> will come before
                    <span class="emphasis"><em>67</em></span>, because <span class="emphasis"><em>3</em></span> (the first character of
                the first sequence) comes before <span class="emphasis"><em>6</em></span> (the first character of the
                second sequence) according to the ordering of our notation (Arabic numerals).
                However, it is more common when ordering sequences of numerals to treat them as
                decimal numbers, and thus to use the ordering imposed by the decimal system. In the
                decimal writing system, <span class="emphasis"><em>67</em></span> precedes <span class="emphasis"><em>334</em></span>,
                since the latter is a greater number.</p><p>This difference is important for organizing systems. Computers will sort values
                differently depending on whether they are treating sequences of numerals as numbers
                or just as sequences. Some organizing systems mix multiple ways of ordering the same
                characters. For example, <span class="orgname">Library of Congress</span>
                <a id="id658394" class="indexterm"/><a id="id658405" class="indexterm"/>call numbers have four parts, and sequences of Arabic numerals can
                appear in three of them. In the second part, indicating a narrow subject area, and
                fourth part, indicating year of publication, sequences of numerals are treated as
                numbers and ordered according to the decimal system. In the third part, however,
                sequences of numerals are treated as sequences and ordered
                    <span class="quote">“<span class="quote">notationally</span>”</span> as in the example above (<span class="emphasis"><em>334</em></span>
                before <span class="emphasis"><em>67</em></span>).</p><p>Differences in ordering demonstrate just one way that multiple writing systems may
                use the same notation differently. For example, the American English and British
                English writing systems both use the same Latin alphabet, but impose slightly
                different spelling rules.<sup>[<a id="chapter-8-endnote-38" href="#ftn.chapter-8-endnote-38" class="footnote">482</a>]</sup> The Japanese writing system employs a number of notations, including
                traditional Chinese characters (<span class="emphasis"><em>kanji</em></span>) as well as the Latin
                alphabet (<span class="emphasis"><em>rōmaji</em></span>). Often writing systems do not share the
                same exact notation but have mostly overlapping notations. Many European languages,
                for example, extend the Latin alphabet with characters such as
                        <span class="emphasis"><em><span class="symbol">Å</span></em></span> and
                        <span class="emphasis"><em><span class="symbol">Ü</span></em></span> that add additional marks,
                known as diacritics, to the basic characters.<sup>[<a id="chapter-8-endnote-39" href="#ftn.chapter-8-endnote-39" epub:type="noteref" class="footnote">483</a>]</sup></p><p><a id="id658547" class="indexterm"/>In organizing systems it is often necessary to represent values from one
                writing system in another writing system that uses a different notation, a process
                known as <span class="strong"><strong>transliteration</strong></span>. For example, early
                computer systems only supported the <abbr class="abbrev">ASCII</abbr> notation, so text from
                writing systems that extend the Latin alphabet had to be converted to
                    <abbr class="abbrev">ASCII</abbr>, usually by removing (or sometimes transliterating)
                diacritics. This made the non-<abbr class="abbrev">ASCII</abbr> text usable in an <abbr class="abbrev">ASCII</abbr>-based computerized organizing system, at the
                expense of information loss.</p><p>Even in modern computer systems that support Unicode, however, transliteration is
                often needed to support organizing activities by users who cannot read text written
                using its original system. The <span class="orgname">Library of Congress</span> and the
                    <span class="orgname">American Library Association</span> provide standard procedures for
                transliterating text from over sixty different writing systems into the (extended)
                Latin alphabet.</p></div><div class="sect2" title="Syntax"><div class="titlepage"><div><div><h3 class="title" id="section-8.3.3">Syntax</h3></div></div></div><p><a id="id658639" class="indexterm"/>The examples in <a class="xref" href="ch08.html#chapter-8-table-8-1" title="Table 8-1. Basic ways of writing part of a book description.">Table 8-1</a> express the same
                information using different writing systems. The examples use the same notation
                    (<abbr class="abbrev">ASCII</abbr>) but differ in their <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_syntax"><em class="glossterm">syntax</em></a></strong></span>: the rules that define how characters can be
                combined into words and how words can be combined into higher-level
                    structures.<sup>[<a id="chapter-8-endnote-40" href="#ftn.chapter-8-endnote-40" epub:type="noteref" class="footnote">484</a>]</sup></p><p>Consider the first example: <span class="emphasis"><em>The title is</em></span> Die Ringe des Saturn
                    <span class="emphasis"><em>and it has 371 pages</em></span>. The leading capital letter and the
                period ending this sequence of characters indicate to us that this is a sentence.
                This sentence is one way we might use the English writing system to express two
                statements about the book we are describing. A <span class="emphasis"><em>statement</em></span> is one
                distinct fact or piece of information. In glottic writing systems like English,
                there is usually more than one sentence we could write to express the same
                statement. For example, instead of <span class="emphasis"><em>it has 371 pages</em></span> we might
                have written <span class="emphasis"><em>the number of pages is 371</em></span>. English writing also
                enables us to construct complex sentences that express more than one
                    statement.<sup>[<a id="chapter-8-endnote-41" href="#ftn.chapter-8-endnote-41" epub:type="noteref" class="footnote">485</a>]</sup></p><p>In contrast, when we create descriptions of resources in an organizing system, we
                generally use non-glottic writing systems in which each sentence only expresses a
                single statement, and there is just one way to write a sentence that expresses a
                given statement.<sup>[<a id="chapter-8-endnote-42" href="#ftn.chapter-8-endnote-42" epub:type="noteref" class="footnote">486</a>]</sup> These restrictions make these writing systems less expressive, but
                simplify their use. In particular, since there is a one-to-one correspondence
                between sentences and statements, we can drop the distinction and just talk about
                the statements of a description.</p><p>Now we return to our example and look at the structure of the statement,
                    <span class="emphasis"><em>The title is</em></span> Die Ringe des Saturn <span class="emphasis"><em>and it has 371
                    pages</em></span>. Spaces are used to separate the text into words, and English
                syntax defines the functions of those words. The verb <span class="strong"><strong>is</strong></span> in this statement functions to link the word title to the phrase
                    <span class="emphasis"><em>Die Ringe des Saturn</em></span>. This is typical of the kind of
                statements found in a resource description. Each statement identifies and describes
                some aspect of the resource. In this case, the statement attributes the value
                    <span class="emphasis"><em>Die Ringe des Saturn</em></span> to the property
                    <span class="emphasis"><em>title</em></span>.</p><p>As we saw when we looked at description structures, we can analyze descriptions as
                involving properties of resources and their corresponding values or content. In a
                writing system like English, it is not always so straightforward to determine which
                words refer to properties and which refer to values. (This is why blobs are not
                ideal description structures.) Writing systems designed for expressing resource
                descriptions, on the other hand, usually define syntax that makes this determination
                easier. In our dictionary examples above, we used an arrow character
                    <span class="symbol">→</span> to indicate the relationship between properties and
                values.</p><p>This ease of distinguishing properties and values comes at a price, however. The
                syntax of English is forgiving: we can read a sentence with somewhat garbled syntax
                such as <span class="emphasis"><em>371 pages it has</em></span> and often still make out its
                    meaning.<sup>[<a id="chapter-8-endnote-43" href="#ftn.chapter-8-endnote-43" class="footnote">487</a>]</sup> This is usually not the case with writing systems intended for
                expressing resource descriptions. These systems strictly define their rules for how
                characters can be combined into higher-level structures. Structures that follow the
                rules are <span class="emphasis"><em>well formed</em></span> according to that system.</p><p>Take for example the second entry in <a class="xref" href="ch08.html#chapter-8-table-8-1" title="Table 8-1. Basic ways of writing part of a book description.">Table 8-1</a>. This example is written in <abbr class="abbrev">JSON</abbr>. As
                explained earlier in this chapter, <abbr class="abbrev">JSON</abbr> is a metamodel for
                structuring information using lists and dictionaries. But <abbr class="abbrev">JSON</abbr> is
                also a writing system, which borrows its syntax from JavaScript. The
                    <abbr class="abbrev">JSON</abbr> syntax uses brackets to textually represent lists
                    <code class="literal">[1,2,3]</code> and braces to textually represent dictionaries
                    <code class="literal">{title:"Die Ringe des Saturn", "pages":371}</code>. Within braces,
                the colon character <code class="literal">:</code> is used to link properties with their
                values, much as is was used in the previous example. So
                    <code class="literal">"pages":371</code> is a statement assigning the value
                    <code class="literal">371</code> to the property <code class="literal">pages</code>.</p><p>The third example is written in <abbr class="abbrev">XML</abbr>. Like <abbr class="abbrev">JSON</abbr>,
                    <abbr class="abbrev">XML</abbr> is a metamodel and also a writing system. Here we have
                    <abbr class="abbrev">XML</abbr> elements and attributes. <abbr class="abbrev">XML</abbr> elements are
                textually represented as <span class="emphasis"><em>tags</em></span> that are marked using the special
                characters <code class="literal">&lt;</code>, <code class="literal">&gt;</code> and
                <code class="literal">/</code>. So, this fragment of <abbr class="abbrev">XML</abbr> consists of a
                    <code class="literal">book</code> element with a child element, <code class="literal">title</code>
                and a <code class="literal">pages</code> attribute each of which has some text content. In
                this case, <code class="literal">pages="371"</code> is a statement assigning the value 371 to
                the property <code class="literal">pages</code>. The difference is syntax is subtle; quotation
                marks surround the value and equal sign = is used to assign the property to its
                value.</p><p>The fourth example is a fragment of <abbr class="abbrev">HTML</abbr>. The writing system that
                    <abbr class="abbrev">HTML</abbr> employs is close enough to <abbr class="abbrev">XML</abbr> to ignore
                any differences in syntax. In this example, the CLASS attribute contains the
                property name and the property value is the element content.</p><p>The fifth example is a fragment of Turtle, one of the writing systems for
                    <abbr class="abbrev">RDF</abbr>. Turtle provides a syntax for writing down
                    <abbr class="abbrev">RDF</abbr>
                <a class="glossterm" href="go01.html#gloss_triple"><em class="glossterm">triples</em></a>. Each triple consists of a
                subject, predicate, and object separated by spaces. Recall that <abbr class="abbrev">RDF</abbr>
                uses <abbr class="abbrev">URI</abbr>s to identify subjects, predicates, and some objects; these
                    <abbr class="abbrev">URI</abbr>s are written in Turtle by enclosing them in angle brackets
                    <code class="literal">&lt; &gt;</code>. Triples are separated by period
                    <code class="literal">.</code> characters, but triples that share the same subject can be
                written more compactly by writing the subject only once, and then writing the
                predicate and object of each triple, separated by a semicolon <code class="literal">;</code>
                character. This is what we see in Table 1: two triples that share a subject.</p><div class="table"><a id="chapter-8-table-8-2"/><div class="table-title">Table 8-2. Writing part of a book description in Semantic XML.</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/></colgroup><tbody><tr><td style="border-bottom: 0.5pt solid ; ">
                                <a id="pro_id00004"/><pre class="programlisting">&lt;book xmlns:dc="http://purl.org/dc/terms/" dc:extent="371 p."&gt;
&lt;dc:title&gt;Die Ringe des Saturn&lt;/title&gt;
...
&lt;/book&gt;</pre>
                            </td></tr><tr><td>
                                <pre class="programlisting">&lt;book xmlns:db="http://www.docbook.org/xml/4.5/docbookx.dtd"&gt;
&lt;bookinfo&gt;
&lt;title&gt;Die Ringe des Saturn&lt;/title&gt;
&lt;pagenums&gt;371 p.&lt;/pagenums&gt;...&lt;/bookinfo&gt;
...
&lt;/book&gt;</pre>
                            </td></tr></tbody></table></div></div><p><a id="id659157" class="indexterm"/><a id="id659161" class="indexterm"/>The two examples in <a class="xref" href="ch08.html#chapter-8-table-8-2" title="Table 8-2. Writing part of a book description in Semantic XML.">Table 8-2</a> demonstrate
                namespaces, terms from the Dublin Core and DocBook namespaces, and the facility with
                which <abbr class="abbrev">XML</abbr> embraces semantic encoding of description resources. The
                first example extends the third example from Table 1; the
                        <code class="literal">xmlns:dc="<em class="replaceable"><code>...</code></em>"</code> segment is a
                namespace declaration which is associating <code class="literal">dc</code> with the quoted
                URI, which happens to be the <span class="citerefentry"><span class="refentrytitle">Dublin Core Metadata Initiative</span>(DCMI)</span>; the child <code class="sgmltag-starttag">&lt;dc:title&gt;</code> element and
                the attached <code class="literal">dc:extent="371"</code> tell us that the corresponding
                values are attributable to the title and extent properties, respectively, from the
                Dublin Core namespace. The next example employs DocBook DTD namespace; we now have a
                    <code class="sgmltag-starttag">&lt;pagenums&gt;</code> element for which the meaning is
                contextually obvious; the title is still a title; an extra layer of markup reflects
                the fact that it could be metadata in the source file of a book that is being
                edited, is in production or is on your favorite tablet right now.<sup>[<a id="chapter-8-endnote-39b" href="#ftn.chapter-8-endnote-39b" epub:type="noteref" class="footnote">488</a>]</sup></p><div class="table"><a id="chapter-8-table-8-3"/><div class="table-title">Table 8-3. Writing part of a book description in RDFa or microdata.</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/></colgroup><tbody><tr><td style="border-bottom: 0.5pt solid ; ">
                                <pre class="programlisting">&lt;div class="book"&gt;The title is
&lt;span property="http://purl.org/dc/terms/title"&gt;Die Ringe des Saturn&lt;/span&gt;
and it has &lt;span property="http://purl.org/dc/terms/extent"&gt;371 p.&lt;/span&gt;&lt;/div&gt;</pre>
                            </td></tr><tr><td>
                                <pre class="programlisting">&lt;div itemscope itemtype="book"&gt;The title is
&lt;span itemprop="http://purl.org/dc/terms/title"&gt;Die Ringe des Saturn&lt;/span&gt;
and it has &lt;span itemprop="http://purl.org/dc/terms/extent"&gt;371 p.&lt;/span&gt;&lt;/div&gt;</pre>
                            </td></tr></tbody></table></div></div><p>The two examples in <a class="xref" href="ch08.html#chapter-8-table-8-3" title="Table 8-3. Writing part of a book description in RDFa or microdata.">Table 8-3</a>
                demonstrate RDFa and microdata formats, which each rely upon specific attributes to
                establish the type of the property values contained by the HTML elements. In each
                example, the book title is contained by a <code class="sgmltag-starttag">&lt;span&gt;</code>
                element. Whereas RDFa relies upon the <code class="sgmltag-attribute">property</code>
                attribute, the microdata example employs the <code class="sgmltag-attribute">itemprop</code> attribute to specify that the contents of the element is,
                effectively a <span class="quote">“<span class="quote">title</span>”</span> in exactly the same sense as we know that the
                contents of <code class="sgmltag-starttag">&lt;dc:title&gt;</code> is a <span class="quote">“<span class="quote">title.</span>”</span></p></div></div><div class="sect1" title="Worlds of Description"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="section-8.4">Worlds of Description</h2></div></div></div><p><a id="id659416" class="indexterm"/>In the previous two sections we have considered descriptions as designed objects with
            particular structures, and as written documents with particular syntaxes. As we have
            seen, there are many possible choices of structure and syntax. But these choices are
            never made in isolation. Just as an architect or designer must work within the
            constraints of the existing built environment, and just as any author must work with
            existing writing systems, descriptions are always created as part of a pre-existing
                <span class="quote">“<span class="quote">world</span>”</span> over which any one of us has little control.</p><p>In the final part of this chapter, we will consider how choices of structure and
            syntax have converged historically into broad patterns of usage. For lack of a better
            term, we call these broad patterns <span class="quote">“<span class="quote">worlds.</span>”</span>
            <span class="quote">“<span class="quote">World</span>”</span> is not a technical term and should not be taken too literally: the
            broad areas of application sketched here have considerable overlap, and there are many
            other ways one might identify patterns of description structure and syntax. That said,
            the three <span class="quote">“<span class="quote">worlds</span>”</span> described here do reflect real patterns of description
            form that influence tool and technology choices. In your own work creating and managing
            resource descriptions, it is likely that you will need to think about how your
            descriptions fit into one or more of these worlds.</p><div class="sect2" title="The Document Processing World"><div class="titlepage"><div><div><h3 class="title" id="section-8.4.1">The Document Processing World</h3></div></div></div><p>The first world we will consider is concerned primarily with the creation,
                processing and management of hybrid narrative-transactional documents such as
                instruction manuals, textbooks, or annotated medieval manuscripts (see <a class="xref" href="ch03.html#chapter-3-sidebar-1" title="The Document Type Spectrum">The Document Type Spectrum</a>). These are quite different kinds of documents,
                but they all contain a mixture of narrative text and structured data, and they all
                can be usefully modeled as tree structures. Because of these shared qualities, tools
                as different as publishing software, supply-chain management software, and scholarly
                editing software have all converged on common <abbr class="abbrev">XML</abbr>-based solutions.
                    (<span class="quote">“<span class="quote">The <abbr class="abbrev">XML</abbr> world</span>”</span> would be another appropriate name
                for the document-processing world.)</p><p>This convergence was no accident, because <abbr class="abbrev">XML</abbr> was designed
                specifically to address the problem of how to add structure and data to documents by
                    <span class="quote">“<span class="quote">marking them up.</span>”</span>
                <abbr class="abbrev">XML</abbr> is the descendant of <span class="citerefentry"><span class="refentrytitle">Standard Generalized Markup Language</span>(SGML)</span>, which in turn descended from <span><a id="ref_IBM"/><span class="citerefentry"><span class="refentrytitle">International Business Machines</span>(IBM)</span></span>’s <span class="citerefentry"><span class="refentrytitle">Generalized Markup Language</span></span>, which was invented to enable the production and management of
                large-scale technical documentation. The explicitness of markup makes it well-suited
                for representing structure and content type distinctions in institutional contexts
                where the scope, scale, and expected lifetime of organizing systems for information
                implies reuse by unknown people for unanticipated purposes.</p><p>The abstract data model underlying <abbr class="abbrev">XML</abbr> is called the <span class="citerefentry"><span class="refentrytitle"><abbr class="abbrev">XML</abbr> Information Set</span></span> or Infoset. The Infoset defines a document as a partially ordered
                tree of <span class="quote">“<span class="quote">information items.</span>”</span> Every <abbr class="abbrev">XML</abbr> document can
                thus be understood as a specific kind of tree, although not every tree structure is
                expressible as an <abbr class="abbrev">XML</abbr> document.<sup>[<a id="chapter-8-endnote-44" href="#ftn.chapter-8-endnote-44" epub:type="noteref" class="footnote">489</a>]</sup></p><p>As we discussed in <a class="xref" href="ch08.html#sidebar_XML_Transclusion_Features" title="Inclusions and References">Inclusions and References</a>,
                    <abbr class="abbrev">XML</abbr> has the ability to describe graphs by incorporating the use
                of ID and IDREF attribute types to create references among element information items
                within the same document. This modest form of hypertext linking allows us to present
                the following document fragment that approximates the graph we saw modeled in <a class="xref" href="ch08.html#chapter-8-figure-8-4" title="Figure 8-4. Descriptions Linked into a Graph.">Figure 8-4</a></p><div class="example"><a id="id659694"/><div class="example-title">Example 8-5. XML Implementation of a Biblio-graph</div><div class="example-contents"><pre class="programlisting">
<code class="literal">&lt;person id="WG.Sebald"&gt;Winfried George Sebald&lt;/person&gt;
&lt;person id="MR.McCulloch&gt;Mark Richard McCulloch&lt;/person&gt;

&lt;book&gt;
    &lt;title&gt;Understanding W.G. Sebald&lt;/title&gt;
    &lt;subject idref="WG.Sebald"/&gt;
    &lt;author idref="WG.Sebald"/&gt;
    &lt;author idref="MR.McCulloch"/&gt;
&lt;/book&gt;

&lt;book pages="371"&gt;
    &lt;title lang="de"&gt;Die Ringe des Saturne&lt;/title&gt;
    &lt;title lang="en"&gt;The Rings of Saturn&lt;/title&gt;
    &lt;author idref="WG.Sebald"/&gt;
&lt;/book&gt;

&lt;book pages="416"&gt;
    &lt;title lang="de"&gt;Austerlitz&lt;/title&gt;
    &lt;author idref="WG.Sebald"/&gt;
&lt;/book&gt;</code>      </pre></div></div><p>As one might expect, tools and technologies in the document-processing world are
                optimized for manipulating and combining tree structures. A <span class="quote">“<span class="quote">toolchain</span>”</span>
                is set of tools intended to be used together to achieve some goal.</p><div class="sidebar"><a id="chapter-8-sidebar-XMLToolchain"/><div class="sidebar-title">The XML Toolchain</div><p>The <abbr class="abbrev">XML</abbr> toolchain is quite comprehensive. It consists of
                    tools for creating <abbr class="abbrev">XML</abbr> documents (XML editors), tools for
                    expressing logical document and data models (<abbr class="abbrev">DTD</abbr>, <span class="citerefentry"><span class="refentrytitle">XML Schema</span></span>, <em class="firstterm"><a id="first_RELAXNG"/><span class="citerefentry"><span class="refentrytitle">REgular LAnguage for XML Next Generation</span>(RELAX NG)</span></em>, <span class="citerefentry"><span class="refentrytitle">Schematron</span></span>), tools for transforming XML documents (<abbr class="abbrev">XSLT</abbr>),
                    tools for describing document processing <span class="quote">“<span class="quote">pipelines</span>”</span> (<em class="firstterm"><a id="first_XProc"/><span class="citerefentry"><span class="refentrytitle">XProc: An XML Pipeline Language</span></span></em>), and tools for storing and querying collections
                    of <abbr class="abbrev">XML</abbr> documents (<abbr class="abbrev">XML</abbr> databases, queried using <span class="citerefentry"><span class="refentrytitle">XML Query Language</span>(XQuery)</span>). Used together, these tools provide very powerful means of
                    working with tree-structured documents. <abbr class="abbrev">XML</abbr> editors incorporate
                    knowledge of <abbr class="abbrev">DTD</abbr>s, schemas, transformations, style sheets,
                    queries, databases and pipelines. Pipelines choreograph the plumbing and
                    inter-dependencies involved in processing a complex dataset and publishing a
                    useful result in one or more output formats.</p></div><p>For programmers who do not to use the <abbr class="abbrev">XML</abbr> toolchain, other
                programming languages also provide libraries for working with <abbr class="abbrev">XML</abbr>.
                This fact has led some to propose, and others to believe, that <abbr class="abbrev">XML</abbr>
                is a kind of <span class="quote">“<span class="quote">universal</span>”</span> format for exchanging data among systems.
                However, programmers have observed that a random <abbr class="abbrev">XML</abbr> Infoset does
                not map easily to the data structures commonly found in many programming languages.
                    <span class="quote">“<span class="quote">Working with <abbr class="abbrev">XML</abbr></span>”</span> frequently means translating
                from <abbr class="abbrev">XML</abbr> tree structures to data structures native to another
                language, usually meaning lists and dictionaries. This translation can be
                problematic and often means giving up many of the strengths of <abbr class="abbrev">XML</abbr>.
                By the same token, there are decades more practical experience working with markup
                languages and institutional publishing than there is with <abbr class="abbrev">JSON</abbr> and
                    <abbr class="abbrev">RDF</abbr>.</p><p><abbr class="abbrev">XML</abbr> is not a universal solution for every possible problem. That
                does not mean that it is not the best solution for a wide variety of problems,
                including yours. To gauge whether your resource descriptions are, or ought to be,
                part of the document-processing world, ask yourself the following questions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Do my resource descriptions contain mixtures of narrative text, hypertext,
                        structured data and a variety of media formats?</p></li><li class="listitem"><p>Can my descriptions easily be modeled using tree structures, hypertext
                        links and transclusion?</p></li><li class="listitem"><p>Are the vocabularies I need or want to use made available using
                            <abbr class="abbrev">XML</abbr> technologies?</p></li><li class="listitem"><p>Do I need to work with a body of existing descriptions already encoded as
                            <abbr class="abbrev">XML</abbr>?</p></li><li class="listitem"><p>Do I need to interoperate with processes or partners that utilize the
                            <abbr class="abbrev">XML</abbr> toolchain?</p></li><li class="listitem"><p>Do I need to publish my resource descriptions in multiple formats from a
                        single source?</p></li></ul></div><p>If the answer to one or more of these questions is <span class="quote">“<span class="quote">yes,</span>”</span> then
                chances are good that you are working within the document processing world, and you
                will need to become familiar with conceptualizing your descriptions as trees and
                working with them using <abbr class="abbrev">XML</abbr> tools.</p></div><div class="sect2" title="The Web World"><div class="titlepage"><div><div><h3 class="title" id="section-8.4.2">The Web World</h3></div></div></div><p>The second <span class="quote">“<span class="quote">world</span>”</span> emerged in the early 1990s with the creation of
                the World Wide Web. The web was developed to address a need for simple and rapid
                sharing of scientific data. Of course, it has grown far beyond that initial use
                case, and is now a ubiquitous infrastructure for all varieties of information and
                communication services. (<span class="quote">“<span class="quote">The browser world</span>”</span> would be another
                appropriate name for what we are calling the Web World.)</p><p>Documents, data, and services on the web are conceptualized as resources,
                identified using <span class="citerefentry"><span class="refentrytitle">Uniform Resource Identifiers</span>(URI)</span>, and accessible through <span class="emphasis"><em>representations</em></span>
                transferred via <span><a id="ref_HTTP"/><span class="citerefentry"><span class="refentrytitle">Hypertext Transfer Protocol</span>(HTTP)</span></span>. Representations are sequences of bytes, and could be
                    <abbr class="abbrev">HTML</abbr> pages, <abbr class="abbrev">JPEG</abbr> images, tabular data, or
                practically anything else transferable via <abbr class="abbrev">HTTP</abbr>. No matter what
                they are, representations transferred over the web include descriptions of
                themselves. These descriptions take the form of property-value pairs, known as
                        <span class="quote">“<span class="quote"><abbr class="abbrev">HTTP</abbr> headers.</span>”</span> The <abbr class="abbrev">HTTP</abbr>
                headers of web representations are structured as dictionaries.</p><p>Dictionary structures appear many other places in web infrastructure.
                    <abbr class="abbrev">URI</abbr>s may include a <span class="emphasis"><em>query</em></span> component
                beginning with a <code class="literal">?</code> character. This component is used for purposes
                such as providing query parameters to search services. The query component is
                commonly structured as a dictionary, consisting of a series of property-value pairs
                separated by the <code class="literal">&amp;</code> character. For example, the following
                    <abbr class="abbrev">URI</abbr>:</p><a id="pro_id00006"/><pre class="programlisting">https://www.google.com/search?q=sebald&amp;tbs=qdr:m</pre><p><a id="id660301" class="indexterm"/>includes the query component <code class="literal">q=sebald&amp;tbs=qdr:m</code>. This is a
                dictionary with the properties <code class="literal">q</code> and <code class="literal">tbs</code>,
                respectively specifying the search term and temporal constraints on the
                search.</p><div class="sidebar"><a id="chapter-8-sidebar-microformats"/><div class="sidebar-title">Microformats, RDFa and Microdata</div><p><a id="id660388" class="indexterm"/>When <span class="personname"><span class="firstname">Tim</span> <span class="surname">Berners-Lee</span></span> deployed HTML, it contained the basic elements and attributes
                    needed to make statements about the document as a whole by using <code class="sgmltag-emptytag">&lt;LINK/&gt;</code>, or about specific parts of the document by
                    using the <code class="sgmltag-starttag">&lt;A&gt;</code> element. Each of these elements
                    had four attributes in common: the famous HREF attribute contains a URI that
                    names an object resource; the NAME attribute allowed the element to be the
                    target end of a link, and; the REL and REV attributes contains descriptions of
                    the link relations. Microformats, RDFa and Microdata are the latest generation
                    of metadata extensions to HTML. Each approach is widely used on the web and by
                    search engines. As such, they are potential targets when transforming into HTML
                    from richer semantic formats.</p><p>Microformats are the simplest of the three. It uses controlled vocabularies of
                    terms in REL/REV, and in the CLASS attribute, to declare high-level information
                    types.</p><p>RDFa is RDF in Attributes. That is, RDFa is a formal specification for writing
                    RDF expressions by using attributes in <abbr class="abbrev">XML</abbr> and
                        <abbr class="abbrev">HTML</abbr> documents. It uses an ABOUT attribute to name the
                    subject of the relation; the REL and REV attributes; HREF is joined by SRC and
                    RESOURCE to name the object of the link, and; a TYPEOF attribute declares a type; 
                    PROPERTY and CONTENT attributes
                    are used to <a class="glossterm" href="go01.html#gloss_attribute"><em class="glossterm">attribute</em></a> a value
                    to an object’s property.</p><p>Microdata is similar, inasmuch as it uses attributes extensively. The presence
                    of an ITEMSCOPE attribute identifies an item while the ITEMTYPE attribute value
                    identifies its type; ITEMID declares an items name or unique identifier;
                    ITEMPROP is a name value pair, and; ITEMREF relates this item to other elements
                    that are outside of the scope of the container element.</p></div><p>Data entered into an <abbr class="abbrev">HTML</abbr> form is also structured as a
                dictionary. When an <abbr class="abbrev">HTML</abbr> form is submitted, the entered data is
                used either to compose the query component of a <abbr class="abbrev">URI</abbr>, or to create a
                new representation to be transferred to a web server. In either case, the data is
                structured as a set of properties and their corresponding values.</p><p><abbr class="abbrev">HTML</abbr> documents are structured as trees, but descriptions embedded
                within <abbr class="abbrev">HTML</abbr> documents can also be structured as dictionaries.
                <abbr class="abbrev">HTML</abbr> documents may include a dictionary of metadata elements,
                each of which specifies a property and its value. Recently support for
                <span class="emphasis"><em>microdata</em></span> was added to <abbr class="abbrev">HTML</abbr>, which is
                another method of adding dictionaries of property-value pairs to documents. Using
                <em class="glossterm">microdata</em>, authors can annotate web content with
                additional information, making it easier to automatically extract structured
                descriptions of that content.<sup>[<a id="chapter-8-endnote-45" href="#ftn.chapter-8-endnote-45" epub:type="noteref" class="footnote">490</a>]</sup>
                <em class="glossterm">Microformats</em> are another method for doing this by mapping
                existing <abbr class="abbrev">HTML</abbr> attributes and values to (nested) dictionary
                structures.<sup>[<a id="chapter-8-endnote-45a" href="#ftn.chapter-8-endnote-45a" epub:type="noteref" class="footnote">491</a>]</sup></p><p>Dictionary structures are easy to work with in any programming language, and they
                pervade various popular frameworks for programming the Web. In the programming
                languages used to implement web services, <abbr class="abbrev">HTTP</abbr> headers and query
                parameters are easily mapped to dictionary data structures native to those
                languages. On the client side, there is only one programming language that runs
                within all web browsers: <span class="citerefentry"><span class="refentrytitle">JavaScript</span></span>. The dictionary is the fundamental data structure within JavaScript
                as well.</p><p>Thus it is unsurprising that <abbr class="abbrev">JSON</abbr>, a dictionary-structured,
                JavaScript-based syntax, has become the de facto standard for
                application-to-application interchange of data on the web in contexts that do not
                involve business transactions. Web services providing structured data intended for
                programmatic use can make that data available as <abbr class="abbrev">JSON</abbr>, which is
                well-suited for use either by JavaScript programs running within browsers, or by
                programs written in other languages running outside of browsers (for example, smart
                phone applications).</p><p>It is now commonly accepted that there are useful differences of approach between
                the document-processing world and the Web World. This does not mean that the two
                worlds do not have significant overlaps. Some very important web representation
                types are <abbr class="abbrev">XML</abbr>-based, such as the Atom syndication format. Trees
                will continue to be the structure of choice for web representations that consist
                primarily of narrative rather than transactional data. But for structured
                descriptions that are intended to be accessed and manipulated on the Web, dictionary
                structures currently rule.</p><p>To gauge whether your resource descriptions are or ought to be part of the Web
                world, ask yourself the following questions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Is the web the primary platform upon which I will be making my
                        descriptions available?</p></li><li class="listitem"><p>Are my resource descriptions primarily structured, transaction-oriented
                        data?</p></li><li class="listitem"><p>Can my descriptions easily be modeled as lists of properties and values
                        (dictionaries)?</p></li><li class="listitem"><p>Are the vocabularies I need or want to use made available primarily using
                            <abbr class="abbrev">HTML</abbr> technologies such as microdata or
                        microformats?</p></li><li class="listitem"><p>Do I need to make my descriptions easily usable for use within a wide
                        array of programming languages?</p></li></ul></div><p>If the answer to one or more of these questions is <span class="quote">“<span class="quote">yes,</span>”</span> then
                chances are good that you are working within the Web World, and you will need to
                become familiar with conceptualizing your descriptions as dictionaries and working
                with them using programming languages such as JavaScript.</p></div><div class="sect2" title="The Semantic Web World"><div class="titlepage"><div><div><h3 class="title" id="section-8.4.3">The Semantic Web World</h3></div></div></div><p>The last world we consider is still somewhat of a <span class="quote">“<span class="quote">possible world,</span>”</span>
                at least in comparison with the previous two. While the document processing world
                and the web world are well-established, the Semantic Web world is only starting to
                emerge, despite having been envisioned over a decade ago.</p><p><a id="id660745" class="indexterm"/><span><a id="def_semantic_web"/>The vision of a <a class="glossterm" href="go01.html#gloss_semantic_web"><em class="glossterm">Semantic Web</em></a> world builds upon the
                    web world, but adds some further prescriptions and constraints for how to
                    structure descriptions. The Semantic Web world unifies the concept of a resource
                    as it has been developed in this book, with the web notion of a resource as
                    anything with a <abbr class="abbrev">URI</abbr>. On the Semantic Web, anything being
                    described must have a URI. Furthermore, the descriptions must be structured as
                    graphs, adhering to the <abbr class="abbrev">RDF</abbr> metamodel and relating resources to
                    one another via their <abbr class="abbrev">URI</abbr>s. Advocates of Linked Data further
                    prescribe that those descriptions must be made available as representations
                    transferred over <abbr class="abbrev">HTTP</abbr>.</span><sup>[<a id="chapter-8-endnote-46" href="#ftn.chapter-8-endnote-46" epub:type="noteref" class="footnote">492</a>]</sup></p><p><a id="id660790" class="indexterm"/>This is a departure from the web world. The web world is also structured
                around <abbr class="abbrev">URI</abbr>s, but it does not require that every resource being
                described have a <abbr class="abbrev">URI</abbr>. For example, in the web world a list of
                bibliographic descriptions of books by <span class="personname"><span class="firstname">W. G.</span> <span class="surname">Sebald</span></span> might be published at a specific <abbr class="abbrev">URI</abbr>, but the
                individual books themselves might not have <abbr class="abbrev">URI</abbr>s. In the Semantic
                Web world, in addition to the list having a URIs, each book would have a
                    <abbr class="abbrev">URI</abbr> too, in addition to whatever other identifiers it might
                    have.<sup>[<a id="chapter-8-endnote-47" href="#ftn.chapter-8-endnote-47" epub:type="noteref" class="footnote">493</a>]</sup></p><p>Making an <abbr class="abbrev">HTTP</abbr> request to an individual book <abbr class="abbrev">URI</abbr>
                may return a graph-structured description of that book, if best practices for Linked
                Data are being followed. This, too, is a departure from the web world, which is
                agnostic about the form representations or descriptions of resources should take
                (although as we have seen, dictionary structures are often favored on the web when
                the clients consuming those descriptions are computer programs). On the Semantic
                Web, all descriptions are structured as <abbr class="abbrev">RDF</abbr> graphs. Each
                description graph links to other description graphs by referring to these related
                resources using their <abbr class="abbrev">URI</abbr>s. Thus, at least in theory, all
                description graphs on the Semantic Web are linked into a single massive graph
                structure. In practice, however, it is far from clear that this is an achievable, or
                even a desirable, goal.</p><p><a id="id660912" class="indexterm"/><a id="id660927" class="indexterm"/><a id="id660932" class="indexterm"/>Although the Semantic Web is in its infancy, a significant number of
                resource descriptions have already been made available in accordance with the
                principles outlined above. Descriptions published according to these principles are
                often referred to as <span class="quote">“<span class="quote">Linked Data.</span>”</span> Prominent examples include:
                DBpedia, a graph of descriptions of subjects of Wikipedia articles; the <span class="citerefentry"><span class="refentrytitle">Virtual International Authority File</span>(VIAF)</span>, a graph of descriptions of names collected from various national
                    libraries<span class="symbol">’</span> name authority files; GeoNames, a graph of
                descriptions of places; and Data.gov.uk, a graph of descriptions of public data made
                available by the UK government.<sup>[<a id="chapter-8-endnote-48" href="#ftn.chapter-8-endnote-48" class="footnote">494</a>]</sup></p><p>Despite the growing amount of Linked Data, tools for working with graph-structured
                data are still immature in comparison to the <abbr class="abbrev">XML</abbr> toolchain and Web
                programming languages. Although there is an <abbr class="abbrev">XML</abbr> syntax for
                    <abbr class="abbrev">RDF</abbr>, using the <abbr class="abbrev">XML</abbr> toolchain to work with
                graph-structured data is generally a bad idea. And just as most programming
                languages do not support natively working with tree structures, most do not support
                natively working with graph structures either. Storing and querying graph-structured
                data efficiently requires a graph database or <span class="emphasis"><em>triple
                store</em></span>.</p><p>Still, the Semantic Web world has much to recommend it. Having a common way of
                identifying resources (the <abbr class="abbrev">URI</abbr>) and a single shared metamodel
                    (<abbr class="abbrev">RDF</abbr>) for all resource descriptions makes it much easier to
                combine descriptions from different sources. To gauge whether your resource
                descriptions are or ought to be part of the Semantic Web world, ask yourself the
                following questions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Is the web the primary platform upon which I will be making my
                        descriptions available?</p></li><li class="listitem"><p>Is it important that I be able to easily and freely aggregate the elements
                        of my descriptions in different ways and to combine them with descriptions
                        created by others?</p></li><li class="listitem"><p>Are my descriptions best modeled as graph structures?</p></li><li class="listitem"><p>Have the vocabularies I need or want to use been created using
                            <abbr class="abbrev">RDF</abbr>?</p></li><li class="listitem"><p>Do I need to work with a body of existing descriptions that have been
                        published as Linked Data?</p></li></ul></div><p>If the answer to one or more of these questions is <span class="quote">“<span class="quote">yes,</span>”</span> then
                chances are good that you should be working within the Semantic Web world, and you
                ought to become familiar with conceptualizing your descriptions as graphs and
                working with them using Semantic Web tools.</p></div></div><div class="sect1" title="Key Points in Chapter Eight"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="section-8.5">Key Points in Chapter Eight</h2></div></div></div><div class="highlights"><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>We can approach the problem of how to form resource descriptions from two
                        perspectives: structuring and writing.</p></li><li class="listitem"><p>Metamodels describe structures commonly found in resource descriptions and
                        other information resources, regardless of the specific domain.</p></li><li class="listitem"><p>Blobs, sets, lists, dictionaries, trees, and graphs are kinds of
                        structures that can be used to form resource descriptions.</p></li><li class="listitem"><p>A <span class="strong"><strong>list</strong></span>, like a set, is a collection of
                        items with an additional constraint: their items are
                            <span class="emphasis"><em>ordered</em></span>.</p></li><li class="listitem"><p>A <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_dictionary"><em class="glossterm">dictionary</em></a></strong></span>, also known
                        as a <span class="emphasis"><em><a class="glossterm" href="go01.html#gloss_map"><em class="glossterm">map</em></a></em></span> or an <span class="emphasis"><em><a class="glossterm" href="go01.html#gloss_associative_array"><em class="glossterm">associative array</em></a></em></span>, is a set of
                        property-value pairs or <span class="emphasis"><em>entries</em></span>.</p></li><li class="listitem"><p>Nested dictionaries form a <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_tree"><em class="glossterm">tree</em></a></strong></span>.</p></li><li class="listitem"><p>Trees consist of <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_node"><em class="glossterm">nodes</em></a></strong></span> joined by <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_edge"><em class="glossterm">edges</em></a></strong></span>.</p></li><li class="listitem"><p><abbr class="abbrev">JSON</abbr> consists of two kinds of structures: lists (called
                            <span class="emphasis"><em>arrays</em></span> in JavaScript) and dictionaries (called
                            <span class="emphasis"><em>objects</em></span> in JavaScript).</p></li><li class="listitem"><p>The <abbr class="abbrev">XML</abbr> Infoset is a tree structure, where each node of
                        the tree is defined to be an <span class="emphasis"><em>information item</em></span> of a
                        particular type.</p></li><li class="listitem"><p>Using schemas to define data representation formats is a good practice
                        that facilitates shared understanding and contributes to long-term
                        maintainability.</p></li><li class="listitem"><p>The <abbr class="abbrev">RDF</abbr> metamodel is a directed graph, so it identifies
                        one node (the one from which the edge is pointing) as the <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_subject"><em class="glossterm">subject</em></a></strong></span> of the triple, and the other node
                        (the one to which the edge is pointing) as its <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_object"><em class="glossterm">object</em></a></strong></span>. The edge is referred to as the
                            <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_predicate"><em class="glossterm">predicate</em></a></strong></span> or (as we
                        have been saying) <span class="emphasis"><em>property</em></span> of the triple.</p></li><li class="listitem"><p>An <span class="quote">“<span class="quote">encoding scheme</span>”</span> is a specialized writing system or
                        syntax for particular types of values. Encoding schemes specify how to
                            <span class="emphasis"><em>textually represent</em></span> information.</p></li><li class="listitem"><p>A <span class="strong"><strong><a class="glossterm" href="go01.html#gloss_writing_system"><em class="glossterm">writing system</em></a></strong></span>
                        employs notations, and adds a set of rules for using them.</p></li><li class="listitem"><p>Differences in ordering demonstrate just one way that multiple writing
                        systems may use the same notation differently.</p></li><li class="listitem"><p>Syntax is the rules that define how characters can be combined into words
                        and how words can be combined into higher-level structures.</p></li><li class="listitem"><p>The document processing world is concerned primarily with the creation,
                        processing and management of hybrid narrative-transactional
                        documents.</p></li><li class="listitem"><p>In the web world, documents, data, and services are conceptualized as
                        resources, identified using <span class="citerefentry"><span class="refentrytitle">Uniform Resource Identifiers</span>(URI)</span>, and accessible through <span class="emphasis"><em>representations</em></span>
                        transferred via the Hypertext Transfer Protocol
                        (<abbr class="abbrev">HTTP</abbr>).</p></li><li class="listitem"><p>The Semantic Web world unifies the concept of a resource as it has been
                        developed in this book, with the web notion of a resource as anything with a
                            <abbr class="abbrev">URI</abbr>. Descriptions must be structured as graphs,
                        adhering to the <abbr class="abbrev">RDF</abbr> metamodel and relating <a class="glossterm" href="go01.html#gloss_resource"><em class="glossterm">resources</em></a> to one another via their
                            <abbr class="abbrev">URI</abbr>s.</p></li></ul></div></div></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-01"><p><sup>[<a href="#chapter-8-endnote-01" class="para">439</a>] </sup>[Computing] <a id="id651824" class="indexterm"/>This discussion of Batten’s cards is based on (Lancaster 1968, pages
                    28-32). Batten’s own explanation is in <a class="link" href="bi01.html#Batten1951" title="“Specialized Files for Patent Searching”"><a id="cite_Batten1951"/>(Batten 1951)</a>.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-02"><p><sup>[<a href="#chapter-8-endnote-02" class="para">440</a>] </sup>[Citation] <a class="link" href="bi01.html#Silman1998" title="“In the Company of Ghosts”"><a id="cite_Silman1998"/>(Silman
                                1998)</a>.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-03"><p><sup>[<a href="#chapter-8-endnote-03" class="para">441</a>] </sup>[CogSci] <a id="id652119" class="indexterm"/><a id="id652137" class="indexterm"/>The technique of diagramming sentences was invented in the
                            mid-19th century by Stephen W. Clark, a New York schoolmaster; <a class="link" href="bi01.html#Clark2010" title="A Practical Grammar: In Which Words, Phrases, and Sentences Are Classified According to Their Offices and Their Various Relations to One Another"><a id="cite_Clark2010"/>(Clark 2010)</a> is an
                            exact reprinting of a nearly 100 year old edition of his book
                                <a class="link" href="bi01.html#Clark1868" title="A Practical Grammar: In Which Words, Phrases, and Sentences Are Classified According to Their Offices and Their Various Relations to One Another"><em class="citetitle">A Practical Grammar</em></a>. A recent tribute to
                            Clark is <a class="link" href="bi01.html#Florey2012" title="“A Picture of Language”"><a id="cite_Florey2012"/>(Florey
                                2012)</a>.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-04"><p class="CogSci"><sup>[<a href="#chapter-8-endnote-04" class="para">442</a>] </sup>[CogSci] <a id="id652154" class="indexterm"/><a id="id652159" class="indexterm"/><a id="id652205" class="indexterm"/><a id="id652212" class="indexterm"/>It is easy to underestimate the incredible power of the
                            human perceptual and cognitive systems to apply neural computation and
                            knowledge to enable vision and hearing to seem automatic. Computers are
                            getting better at extracting features from visual and auditory signals
                            to identify and classify inputs, but our point here is that none of
                            these features are explicitly represented in the input
                                <span class="quote">“<span class="quote">blob</span>”</span> or <span class="quote">“<span class="quote">stream.</span>”</span></p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-05"><p><sup>[<a href="#chapter-8-endnote-05" class="para">443</a>] </sup>[Computing] <a id="id652287" class="indexterm"/><a id="id652294" class="indexterm"/><a id="id652299" class="indexterm"/>As we commented earlier, an oral description of a resource
                            may not be especially useful in an organizing system because computers
                            cannot easily understand it. On the other hand, there are many contexts
                            in which an oral description would be especially useful, such as in a
                            guided tour of a museum where visitors can use audio headsets.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-06"><p><sup>[<a href="#chapter-8-endnote-06" class="para">444</a>] </sup>[LIS] <a id="id652376" class="indexterm"/><a id="id652386" class="indexterm"/>What was lost was the previously invisible structure
                            provided by the grammar, which made us assign roles to each of these
                            terms to create a semantic interpretation.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-07"><p><sup>[<a href="#chapter-8-endnote-07" class="para">445</a>] </sup>[Computing] <a id="id652465" class="indexterm"/><a id="id652446" class="indexterm"/>It is rarely practical to make things as simple as possible.
                            According to Einstein, we should endeavor to <span class="quote">“<span class="quote">Make everything as
                                simple as possible, but not simpler.</span>”</span></p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-08"><p><sup>[<a href="#chapter-8-endnote-08" class="para">446</a>] </sup>[Computing] <a id="id652854" class="indexterm"/><a id="id652862" class="indexterm"/><a id="id652858" class="indexterm"/><a id="id652878" class="indexterm"/>This structural metamodel only allows one value for each
                            property, which means it would not work for books with multiple authors
                            or that discuss multiple subjects.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-09"><p><sup>[<a href="#chapter-8-endnote-09" class="para">447</a>] </sup>[LIS] <a id="id652938" class="indexterm"/><a id="id652923" class="indexterm"/>Going the other direction is not so easy, however: just as
                            real dictionaries do not support finding a word given a definition,
                            neither do dictionary structures support finding a key given a
                            value.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-11"><p><sup>[<a href="#chapter-8-endnote-11" class="para">448</a>] </sup>[Computing] <a id="id653258" class="indexterm"/><a id="id653268" class="indexterm"/><abbr class="abbrev">RDF/XML</abbr> is one example where meta models
                            meet. In <a class="link" href="bi01.html#Wilde2008b" title="“Document design matters”"><a id="cite_Wilde2008b"/><em class="citetitle">Document Design Matters</em>, 
                                (Wilde and Glushko 2008b)</a> point out that <span class="quote">“<span class="quote">If the designer of an exchange
                                format uses a non-<abbr class="abbrev">XML</abbr> conceptual metamodel because
                                it seems to be a better fit for the data model, <abbr class="abbrev">XML</abbr>
                                is only used as the physical layer for the exchange model. The
                                logical layer in this case defines the mapping between the
                                    non-<abbr class="abbrev">XML</abbr> conceptual model, and any
                                reconstruction of the exchange model data requires the consumer to
                                be fully aware of this mapping. In such a case, it is good practice
                                to make users of the <abbr class="abbrev">API</abbr> aware of the fact that it
                                is using a non-<abbr class="abbrev">XML</abbr> metamodel. Otherwise they might
                                be tempted to base their implementation on a too small set of
                                examples, creating implementations which are brittle and will fail
                                at some point in time.</span>”</span></p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-12"><p><sup>[<a href="#chapter-8-endnote-12" class="para">449</a>] </sup>[Computing] <a id="id653910" class="indexterm"/><a id="id653919" class="indexterm"/><a id="id653927" class="indexterm"/>Technically, what is described here is referred to as
                                <span class="quote">“<span class="quote">rooted tree</span>”</span> by mathematicians, who define trees more
                            generally. Since trees used as data structures are always rooted trees,
                            we do not make the distinction here.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-14"><p class="Computing"><sup>[<a href="#chapter-8-endnote-14" class="para">450</a>] </sup>[Computing] <a id="id654058" class="indexterm"/><a id="id654093" class="indexterm"/><a id="id654067" class="indexterm"/><a id="id654072" class="indexterm"/><a id="id654077" class="indexterm"/>This feature relies upon the existence of an
                                <abbr class="abbrev">XML</abbr> schema. An <abbr class="abbrev">XML</abbr> schema can
                            declare that certain attributes are of type ID, IDREF or IDREFS. Whether
                            an <abbr class="abbrev">XML</abbr>
                            <abbr class="abbrev">DTD</abbr> or one of the many schema languages that have been
                            developed under the auspices of the <abbr class="abbrev">W3C</abbr> or
                                <abbr class="abbrev">ISO</abbr>.</p></div><div class="footnote" id="ftn.id654439"><p><sup>[<a href="#id654439" class="para">451</a>] </sup>[Citation] <a class="ulink" href="http://www.w3.org/TR/xml-infoset/" target="_top"><code class="uri">http://www.w3.org/TR/xml-infoset/</code></a>.</p></div><div class="footnote" epub:type="footnote" id="ftn.id654501"><p><sup>[<a href="#id654501" class="para">452</a>] </sup>[Computing] <a id="id654561" class="indexterm"/>The <a class="glossterm" href="go01.html#gloss_XML_Infoset"><em class="glossterm">XML
                                            Infoset</em></a> is one of many metamodels for
                                            <abbr class="abbrev">XML</abbr>, including the DOM and XPath.
                                        Typically, an XML Infoset is created as a by-product of
                                        parsing a well-formed <abbr class="abbrev">XML</abbr> document
                                        instance. An XML document may also be informed by its DTD or
                                        schema with information about the types of attribute values,
                                        and their default values. Attributes of type ID, IDREF and
                                        IDREFs provide a mechanism for intra-document hypertext
                                        linking and transclusion. An <abbr class="abbrev">XML</abbr> document
                                        instance may contain entity definitions and references that
                                        get expanded when the document is parsed, thereby offering
                                        another form of transclusion.</p></div><div class="footnote" id="ftn.chapter-8-endnote-16"><p><sup>[<a href="#chapter-8-endnote-16" class="para">453</a>] </sup>[Computing] <a id="id654817" class="indexterm"/><a id="id654826" class="indexterm"/>A well-formed XML document instance, when processed,
                                will yield an XML Information Set, as described here. Information
                                sets may also be constructed by other means, such as transforming
                                from another information set. See the section on
                                    <em class="citetitle">Synthetic Infosets</em> at
                                    <a class="ulink" href="http://www.w3.org/TR/xml-infoset/#intro.synthetic" target="_top"><code class="uri">http://www.w3.org/TR/xml-infoset/#intro.synthetic</code></a> for
                                details.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-17"><p><sup>[<a href="#chapter-8-endnote-17" class="para">454</a>] </sup>[Computing] <a id="id654860" class="indexterm"/><a id="id654883" class="indexterm"/>The Infoset contains knowledge of whether all related
                                declarations have been read and processed, the base
                                    <abbr class="abbrev">URI</abbr> of the document instance, information about
                                attribute types, comments, processing instructions, unparsed
                                entities and notations, and more.</p><p><a id="id654925" class="indexterm"/>A well-formed <abbr class="abbrev">XML</abbr> document instance for
                                which there are associated schemas, such as a <abbr class="abbrev">DTD</abbr>,
                                may contribute information to the Infoset. Notably, schemas may
                                associate data types with element and attribute information items,
                                and it may also specify default or fixed values for attributes. A
                                    <abbr class="abbrev">DTD</abbr> may define entities that are referenced in
                                the document instance and are expanded in-place when processed.
                                These contributions can affect the truth value of the
                                document.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-18"><p><sup>[<a href="#chapter-8-endnote-18" class="para">455</a>] </sup>[Computing] <a id="id654907" class="indexterm"/><a id="id654942" class="indexterm"/><a id="id654950" class="indexterm"/>The <abbr class="abbrev">SGML</abbr> standard explicitly stated
                                that documentation describing or explaining a <abbr class="abbrev">DTD</abbr>
                                is part of the document type definition. The implication being that
                                a schema is not just about defining syntax, but also semantics.
                                Moreover, since <abbr class="abbrev">DTD</abbr>s do not make possible to
                                describe all possible constraints, such as co-occurrence
                                constraints, the documentation could serve as human-consumable
                                guidance for implementers as well as content creators and
                                consumers.</p></div><div class="footnote" epub:type="footnote" id="ftn.id654993"><p><sup>[<a href="#id654993" class="para">456</a>] </sup>[Computing] <a id="id655028" class="indexterm"/><a id="id655043" class="indexterm"/>Attribute types may be declared in an
                                    <abbr class="abbrev">XML</abbr>
                                <abbr class="abbrev">DTD</abbr> or schema. Attributes whose type is ID must
                                have a valid <abbr class="abbrev">XML</abbr> name value that is unique within
                                that <abbr class="abbrev">XML</abbr> document; an attribute of type IDREF whose
                                value corresponds to a unique ID has a <span class="quote">“<span class="quote">references</span>”</span>
                                property whose value is the element node that corresponds to the
                                element with that ID. An attribute of type IDREFS whose value
                                corresponds to a list of unique ID has a <span class="quote">“<span class="quote">references</span>”</span>
                                property whose value is a list of element node(s) that corresponds
                                to the element(s) with matching IDs.</p></div><div class="footnote" epub:type="footnote" id="ftn.id655098"><p><sup>[<a href="#id655098" class="para">457</a>] </sup>[Citation] <a id="id655064" class="indexterm"/>XML Linking Language (XLink) is <a class="link" href="bi01.html#Marsh2006" title="XML Inclusions (XInclude)"><a id="cite_Marsh2006"/>(Marsh, Orchard, and
                                    Veillard 2006)</a>.</p></div><div class="footnote" epub:type="footnote" id="ftn.id655115"><p><sup>[<a href="#id655115" class="para">458</a>] </sup>[Citation] <a id="id655120" class="indexterm"/><a id="id655154" class="indexterm"/><a id="id655159" class="indexterm"/><a id="id655075" class="indexterm"/> XML Linking Language (XLink) is <a class="link" href="bi01.html#DeRose2010" title="XML Linking Language (XLink)"><a id="cite_DeRose2010"/>(DeRose, Maler,
                                    Orchard, and Walsh 2010)</a>.</p></div><div class="footnote" epub:type="footnote" id="ftn.id655141"><p><sup>[<a href="#id655141" class="para">459</a>] </sup>[Computing] Within the document’s DTD, one simply declares the
                                entity and its corresponding value, which could be anything from an
                                entire document to a phrase and then it may be referenced in place
                                within the <abbr class="abbrev">XML</abbr> document instance. The entity
                                reference is replaced by the entity value in the
                                    <abbr class="abbrev">XML</abbr> Infoset. Entities, as nameable wrappers,
                                effectively disappear on their way into the <abbr class="abbrev">XML</abbr>
                                Infoset.</p></div><div class="footnote" id="ftn.chapter-8-endnote-19"><p><sup>[<a href="#chapter-8-endnote-19" class="para">460</a>] </sup>[Citation] <a id="id655643" class="indexterm"/>ONIX is the international standard for representing and
                        communicating book industry product information in electronic form:
                            <a class="ulink" href="http://www.editeur.org/11/Books/" target="_top"><code class="uri">http://www.editeur.org/11/Books/</code></a>.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-20"><p><sup>[<a href="#chapter-8-endnote-20" class="para">461</a>] </sup>[Citation] <a id="id655769" class="indexterm"/>Do not take on the task of creating a new <abbr class="abbrev">XML</abbr>
                        model lightly. Literally thousands of <abbr class="abbrev">XML</abbr> vocabularies have
                        been created, and some represent hundreds or thousands of hours of effort.
                        See <a class="link" href="bi01.html#Bray2005" title="“On Language Creation”"><a id="cite_Bray2005"/>(Bray 2005)</a> for
                        advice on how to reduce the risk of vocabulary design if you cannot find an
                        existing one that satisfies your requirements.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-21"><p><sup>[<a href="#chapter-8-endnote-21" class="para">462</a>] </sup>[Citation] <a id="id655832" class="indexterm"/>See <a class="link" href="bi01.html#Glushko2005" title="Document Engineering: Analyzing and Designing Documents for Business Informatics and Web Services"><a id="cite_Glushko2005-8.1"/>(Glushko and McGrath 2005)</a> for a synthesis of best practices
                            for creating domain-specific languages in technical publishing and
                            business-to-business document exchange contexts. You need best practices
                            for big problems, while small ones can be attacked with <span xml:lang="latin" class="foreignphrase"><em xml:lang="latin" class="foreignphrase">ad hoc</em></span> methods.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-22"><p><sup>[<a href="#chapter-8-endnote-22" class="para">463</a>] </sup>[Computing] <a id="id655979" class="indexterm"/><a id="id655986" class="indexterm"/><a id="id655995" class="indexterm"/>Unless an <abbr class="abbrev">XML</abbr> instance is associated with a
                            schema, it is fair to say that it does not have any model at all because
                            there is no way to understand the content and structure of the
                            information it contains. The assignment of a schema to an
                                <abbr class="abbrev">XML</abbr> instance requires a <span class="quote">“<span class="quote">Document Type
                                Declaration.</span>”</span> If some of the same vocabulary terms occur in
                            more than one <abbr class="abbrev">XML</abbr> schema, with different meanings in
                            each, using elements from more than one schema in the same instance
                            requires that they be distinguished using <a class="glossterm" href="go01.html#gloss_namespace"><em class="glossterm">namespaces.</em></a> For example, if an
                            element named <span class="quote">“<span class="quote">title</span>”</span> means the <span class="quote">“<span class="quote">title of the
                                book</span>”</span> in one schema and <span class="quote">“<span class="quote">the honorific associated with
                                a person</span>”</span> in another, instances might have elements with
                            namespace prefixes like &lt;book:title&gt;The Discipline of
                            Organizing&lt;/book:title&gt; and
                            &lt;hon:title&gt;Professor&lt;/hon:title&gt;. Namespaces are a common
                            source of frustration in <abbr class="abbrev">XML</abbr>, because they seem like an
                            overly complicated solution to a simple problem. But in addition to
                            avoiding naming collisions, they are important in schema composition and
                            organization.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-23"><p><sup>[<a href="#chapter-8-endnote-23" class="para">464</a>] </sup>[Computing] <a id="id656092" class="indexterm"/><a id="id656071" class="indexterm"/><a id="id656083" class="indexterm"/>What <span class="quote">“<span class="quote">correctly</span>”</span> means depends on the schema
                            language used to encode the conceptual model of the document type. The
                                <abbr class="abbrev">XML</abbr> family of standards includes several schema
                            languages that differ in how completely they can encode a document
                            type’s conceptual model.<a id="id656106" class="indexterm"/> The <span class="citerefentry"><span class="refentrytitle">Document Type Definition</span>(DTD)</span> has its origins in publishing and enforces structural
                            constraints well; it expresses strong data typing through associated
                            documentation resources. XML Schemas (<abbr class="abbrev">XSD</abbr>) are better
                            for representing transactional document types but their added expressive
                            power tends to make them more complex.</p></div><div class="footnote" id="ftn.chapter-8-endnote-24"><p><sup>[<a href="#chapter-8-endnote-24" class="para">465</a>] </sup>[Citation] <a id="id656254" class="indexterm"/>For example, see <span class="citerefentry"><span class="refentrytitle">Linked Open Vocabularies</span></span> at
                            <a class="ulink" href="http://lov.okfn.org/dataset/lov/index.html" target="_top"><code class="uri">http://lov.okfn.org/dataset/lov/index.html</code></a>.</p></div><div class="footnote" epub:type="footnote" id="ftn.id656395"><p><sup>[<a href="#id656395" class="para">466</a>] </sup>[Computing] <a id="id656398" class="indexterm"/><a id="id656383" class="indexterm"/>Attribute values can be constrained in a schema by
                            specifying a data type, a default value, and a list of potential values.
                            Data types allow us to specify whether a value is supposed to be a name,
                            a number, a date, a token or a string of text. Having established the
                            data type, we can further constrain the value of an attribute by
                            specifying a range of values, for a number or a date, for example. We
                            can also use <a class="glossterm" href="go01.html#gloss_regular_expressions"><em class="glossterm">regular
                                expression</em></a> patterns to describe a data type such as a
                            postal code, telephone number or <abbr class="abbrev">ISBN</abbr> number.
                            Specifying default values and lists of legal values for attributes
                            simplifies content creation and quality assurance processes. In
                            Schematron, a rule-based XML schema language for making test assertions
                            about XML documents, we can express constraints between elements and
                            attributes in ways that other XML schema languages cannot. For example,
                            we can express the constraint that if two <code class="sgmltag-starttag">&lt;title&gt;</code> elements are provided, then each must contain a
                            unique string value and different <code class="sgmltag-attribute">language</code> attribute values.</p></div><div class="footnote" id="ftn.chapter-8-endnote-21a"><p><sup>[<a href="#chapter-8-endnote-21a" class="para">467</a>] </sup>[Citation] <a id="id656462" class="indexterm"/><a id="id656472" class="indexterm"/>See <abbr class="abbrev">LOC-SH</abbr> as
                                <a class="ulink" href="http://id.loc.gov/authorities/subjects.html" target="_top"><code class="uri">http://id.loc.gov/authorities/subjects.html</code></a>; MeSH at
                                <a class="ulink" href="http://www.nlm.nih.gov/mesh/" target="_top"><code class="uri">http://www.nlm.nih.gov/mesh/</code></a>.</p></div><div class="footnote" id="ftn.chapter-8-endnote-25"><p><sup>[<a href="#chapter-8-endnote-25" class="para">468</a>] </sup>[Citation] <a id="id656729" class="indexterm"/>The Atom Publishing Protocol is IETF RFC 5023,
                            (<a class="ulink" href="https://tools.ietf.org/html/rfc5023" target="_top"><code class="uri">https://tools.ietf.org/html/rfc5023</code></a>); a good introduction is <a class="link" href="bi01.html#Sayre2005" title="“Atom: The Standard in Syndication”"><a id="cite_Sayre2005"/>(Sayre 2005)</a>. IETF
                            RFC is <a class="ulink" href="http://www.ietf.org/rfc/rfc3339.txt" target="_top"><code class="uri">http://www.ietf.org/rfc/rfc3339.txt</code></a>.</p></div><div class="footnote" id="ftn.id656803"><p><sup>[<a href="#id656803" class="para">469</a>] </sup>[Citation] There is no single authority on the subject of regular
                                expressions or their syntax. A good starting point is the Wikipedia
                                article on the subject:
                                    <a class="ulink" href="http://en.wikipedia.org/wiki/Regular_expression" target="_top"><code class="uri">http://en.wikipedia.org/wiki/Regular_expression</code></a>.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-26"><p><sup>[<a href="#chapter-8-endnote-26" class="para">470</a>] </sup>[Citation] The terminology here and in the following sections comes from
                            <a class="link" href="bi01.html#Harris1996" title="Signs of Writing"><a id="cite_Harris1996"/>(Harris 1996)</a>.</p></div><div class="footnote" id="ftn.chapter-8-endnote-27"><p><sup>[<a href="#chapter-8-endnote-27" class="para">471</a>] </sup>[Computing] <a id="id657367" class="indexterm"/>See <a class="ulink" href="http://unicode.org/charts/PDF/U1F700.pdf." target="_top"><code class="uri">http://unicode.org/charts/PDF/U1F700.pdf</code></a>.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-28"><p><sup>[<a href="#chapter-8-endnote-28" class="para">472</a>] </sup>[Citation] <a id="id657408" class="indexterm"/><a id="id657399" class="indexterm"/>Entitled <span class="quote">“<span class="quote">The ABC,</span>”</span> the song was copyrighted in
                        1835 by Boston Music publisher <span class="orgname">Charles Bradlee</span>. It is
                        sung to a tune that was originally developed by <span class="personname"><span class="firstname">Wolfgang</span> <span class="othername">Amadeus</span> <span class="surname">Mozart</span></span>, and is commonly recognizable as <em class="citetitle">Twinkle, Twinkle,
                            Little Star.</em></p></div><div class="footnote" id="ftn.chapter-8-endnote-29"><p><sup>[<a href="#chapter-8-endnote-29" class="para">473</a>] </sup>[Citation] <a class="ulink" href="http://tools.ietf.org/html/rfc20" target="_top"><code class="uri">http://tools.ietf.org/html/rfc20</code></a>.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-30"><p><sup>[<a href="#chapter-8-endnote-30" class="para">474</a>] </sup>[Computing] <a id="id657525" class="indexterm"/><a id="id657543" class="indexterm"/>Only 95 of these characters are actually <span class="quote">“<span class="quote">marks</span>”</span> in
                        the sense of being visible and printable. The other 33 <abbr class="abbrev">ASCII</abbr> characters are <span class="quote">“<span class="quote">control
                            codes</span>”</span> that indicate things like horizontal and vertical tabs,
                        the ends of printed lines, form feeds, and transmission control. We can
                        think of many of these as special auxiliary marks, similar to the kind of
                        symbols editors and proofreaders use to annotate texts.</p></div><div class="footnote" id="ftn.chapter-8-endnote-31"><p><sup>[<a href="#chapter-8-endnote-31" class="para">475</a>] </sup>[Citation] The Unicode standard is maintained by a global non-profit
                        organization. Everything you need to know is at <a class="ulink" href="http://www.unicode.org/" target="_top"><code class="uri">http://www.unicode.org/</code></a>.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-32"><p><sup>[<a href="#chapter-8-endnote-32" class="para">476</a>] </sup>[Computing] <a id="id657870" class="indexterm"/><a id="id657882" class="indexterm"/><a id="id657886" class="indexterm"/>The Chinese character
                            <span class="emphasis"><em><span class="symbol">井</span></em></span> (water well) looks like
                        the # character too. The # symbol was historically used to denote pounds,
                        the Imperial unit of weight, as in 10# of potatoes. In the United Kingdom,
                        the # character is called<span class="quote">“<span class="quote">hash.</span>”</span> We could go on, but we will
                        leave it to you to discover more.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-33"><p><sup>[<a href="#chapter-8-endnote-33" class="para">477</a>] </sup>[Computing] <a id="id657917" class="indexterm"/><a id="id657931" class="indexterm"/><a id="id657945" class="indexterm"/><a id="id657950" class="indexterm"/>To add to the confusion, while the American standard (<abbr class="abbrev">ASCII</abbr>) places the # character at position 23,
                        the British equivalent (<span class="citerefentry"><span class="refentrytitle">BS 4730</span></span>) places the currency symbol <span class="symbol">£</span> at the
                        same position. As a result, improperly configured computers sometimes
                        display # in place of <span class="symbol">£</span> and vice versa.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-34"><p><sup>[<a href="#chapter-8-endnote-34" class="para">478</a>] </sup>[Computing] <a id="id658159" class="indexterm"/><a id="id658166" class="indexterm"/>Recently, an alternative writing system for
                        <abbr class="abbrev">XML</abbr>-structured data has been standardized: <span class="citerefentry"><span class="refentrytitle">Efficient XML Interchange</span>(EXI)</span>. However it is not yet widely used.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-35"><p><sup>[<a href="#chapter-8-endnote-35" class="para">479</a>] </sup>[Computing] <a id="id658188" class="indexterm"/>RDF/XML is a bit confusing; it is a writing system that uses
                            <abbr class="abbrev">XML</abbr> syntax to textually represent <abbr class="abbrev">RDF</abbr>
                        structure. This means that while <abbr class="abbrev">XML</abbr> tools can read and
                        write <abbr class="abbrev">RDF/XML</abbr>, they cannot manipulate the graph structures
                        it represents, because they were designed to work with
                        <abbr class="abbrev">XML</abbr>’s tree structures.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-36"><p><sup>[<a href="#chapter-8-endnote-36" class="para">480</a>] </sup>[Citation] <a id="id658314" class="indexterm"/>Although we use the Roman alphabetic characters today to
                        represent Roman numerals, originally they were represented by unique
                        symbols.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-37"><p><sup>[<a href="#chapter-8-endnote-37" class="para">481</a>] </sup>[Computing]<a id="id658373" class="indexterm"/><a id="id658338" class="indexterm"/>It took a few hundred years before alphabetization became
                        recursive and applied to letters other than the first 
                        <a class="link" href="bi01.html#Casson2002" title="Libraries in the Ancient World"><a id="cite_Casson2002"/>(Casson 2002, p. 37)</a>.
                        Alphabetization relies on the ordering of the writing system, not the
                        notation. For example, Swedish and German are two writing systems that
                        assign different orderings to the same notation.</p></div><div class="footnote" id="ftn.chapter-8-endnote-38"><p><sup>[<a href="#chapter-8-endnote-38" class="para">482</a>] </sup>[Citation] For example, the American spelling of the words
                            <span class="quote">“<span class="quote">center</span>”</span> and <span class="quote">“<span class="quote">color</span>”</span> contrasts slightly with
                        the English spelling of <span class="quote">“<span class="quote">centre</span>”</span> and <span class="quote">“<span class="quote">colour.</span>”</span>
                        There are too many examples to include here. Wikipedia has a comprehensive
                        analysis at
                        <a class="ulink" href="http://en.wikipedia.org/wiki/American_and_British_English_spelling_differences" target="_top"><code class="uri">http://en.wikipedia.org/wiki/American_and_British_English_spelling_differences</code></a>.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-39"><p><sup>[<a href="#chapter-8-endnote-39" class="para">483</a>] </sup>[Computing] <a id="id658530" class="indexterm"/><a id="id658508" class="indexterm"/><a id="id658516" class="indexterm"/><abbr class="abbrev">ASCII</abbr>’s 128 characters are
                        insufficient to represent these more complex character sets, so a new family
                        of character encodings was created, ISO-8859, in which each encoding
                        enumerates 256 characters. Each encoding thus has more space to accommodate
                        the additional characters of regionally-specific notations. ISO 8859-5, for
                        example, has extensions to support the Cyrillic alphabet.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-40"><p><sup>[<a href="#chapter-8-endnote-40" class="para">484</a>] </sup>[Computing] <a id="id658675" class="indexterm"/>In discussions of glottic writing systems, <span class="quote">“<span class="quote">syntax</span>”</span>
                        usually refers only to the rules for combining words into sentences. In
                        discussions of programming languages, <span class="quote">“<span class="quote">syntax</span>”</span> has the broader
                        sense we use here.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-41"><p><sup>[<a href="#chapter-8-endnote-41" class="para">485</a>] </sup>[CogSci] <a id="id658750" class="indexterm"/><a id="id658724" class="indexterm"/>Compund sentences contain two independent clauses joined by a
                        conjunction, such as <span class="quote">“<span class="quote">and,</span>”</span>
                        <span class="quote">“<span class="quote">or,</span>”</span>
                        <span class="quote">“<span class="quote">nor,</span>”</span>
                        <span class="quote">“<span class="quote">but.</span>”</span> For example: I went to the store and I bought a
                            book.<span class="symbol">”</span> Complex sentences contain an independent
                        clause joined by one or more dependent clauses. For example: <span class="quote">“<span class="quote">I read
                            the book that I bought at the store.</span>”</span></p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-42"><p><sup>[<a href="#chapter-8-endnote-42" class="para">486</a>] </sup>[Computing] <a id="id658782" class="indexterm"/>In truth, even non-glottic writing systems designed to encode
                        resource descriptions unambiguously can have variant forms of the same
                        statement. For example, <abbr class="abbrev">XML</abbr> permits some variation in the
                        way the same Infoset may be textually represented. Often these variations
                        involve the treatment of content that may under some circumstances be
                        treated as optional, such as white space. The difference is that in writing
                        systems designed for resource description, these variations can be precisely
                        enumerated and rules developed to reconcile them, while this is not
                        generally true for glottic writing systems.</p></div><div class="footnote" id="ftn.chapter-8-endnote-43"><p><sup>[<a href="#chapter-8-endnote-43" class="para">487</a>] </sup>[CogSci] <a id="id658835" class="indexterm"/>Fortunately for Yoda. There are many web services for converting
                        English to Yoda-speak; an example is
                        <a class="ulink" href="http://www.yodaspeak.co.uk/" target="_top"><code class="uri">http://www.yodaspeak.co.uk/</code></a>.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-39b"><p><sup>[<a href="#chapter-8-endnote-39b" class="para">488</a>] </sup>[Computing] <a id="id659255" class="indexterm"/><a id="id659262" class="indexterm"/>DocBook <a class="link" href="bi01.html#Walsh2010" title="DocBook 5: The Definitive Guide"><a id="cite_Walsh2010-8.1"/>(Walsh
                            2010)</a> is widely used to publish academic, commercial, industrial
                        book, scientific, and computing book, papers and articles. The book that you
                        are reading is encoded with DocBook markup; complete bibliographic
                        information for the book is contained within the source files, ready to be
                        extracted on the way into one of the latest eBook formats.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-44"><p><sup>[<a href="#chapter-8-endnote-44" class="para">489</a>] </sup>[Computing] <a id="id659645" class="indexterm"/><a id="id659628" class="indexterm"/><a id="id659633" class="indexterm"/><a id="id659659" class="indexterm"/>It should be noted that the content of the Infoset for a given
                        document may be affected by knowledge of any related <abbr class="abbrev">DTD</abbr>s
                        or schemas. That is to say that, upon examination of a given
                            <abbr class="abbrev">XML</abbr> document instance, its Infoset may be augmented
                        with some useful information, such as default attribute values and attribute
                        types. (See <a class="xref" href="ch08.html#sidebar_XML_Transclusion_Features" title="Inclusions and References">Inclusions and References</a>.)</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-45"><p><sup>[<a href="#chapter-8-endnote-45" class="para">490</a>] </sup>[Citation] <a id="id660473" class="indexterm"/>Microdata, an invention of WHATWG and exists and part of what
                        they call a <span class="quote">“<span class="quote">living standard</span>”</span> It is supported by Google, so it
                        is widely used and there exist numerous controlled vocabularies, including
                        those for creative works, persons, events and organizations.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-45a"><p><sup>[<a href="#chapter-8-endnote-45a" class="para">491</a>] </sup>[Computing] <a id="id660563" class="indexterm"/><a id="id660566" class="indexterm"/><a id="id660462" class="indexterm"/>Microformats is a non-standard that emerged from the community
                        and has been sponsored by CommerceNet and Microformats.org.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-46"><p><sup>[<a href="#chapter-8-endnote-46" class="para">492</a>] </sup>[Citation] <a class="link" href="bi01.html#Bizer2009b" title="“Linked Data—The Story So Far”"><a id="cite_Bizer2009b-8.1"/>(Bizer, Heath,
                            and Berners-Lee 2009)</a>.</p></div><div class="footnote" epub:type="footnote" id="ftn.chapter-8-endnote-47"><p><sup>[<a href="#chapter-8-endnote-47" class="para">493</a>] </sup>[Computing] <a id="id660850" class="indexterm"/><a id="id660867" class="indexterm"/><a id="id660873" class="indexterm"/>It is worth noting that <abbr class="abbrev">URI</abbr>s are not required
                        to have anything at their endpoints. Resolvability of <abbr class="abbrev">URI</abbr>s
                        is evangelized as a best practice for Linked Data but not a requirement
                        within the broader Semantic Web paradigm. Merely asserting that a
                            <abbr class="abbrev">URI</abbr> is associated with a book is enough. If the
                            <abbr class="abbrev">URI</abbr> can return a description or a resource, so much the
                        better, but if not, at least you can talk about the book by referring to the
                        same <abbr class="abbrev">URI</abbr>.</p></div><div class="footnote" id="ftn.chapter-8-endnote-48"><p><sup>[<a href="#chapter-8-endnote-48" class="para">494</a>] </sup>[Computing] <a id="id660945" class="indexterm"/>Many more available datasets are listed at
                            <a class="ulink" href="http://linkeddata.org/" target="_top"><code class="uri">http://linkeddata.org/</code></a>.</p></div></div></section></body></html>
