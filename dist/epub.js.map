{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","libs/mime/mime.js","node_modules/browserify/node_modules/process/browser.js","node_modules/rsvp/dist/rsvp.js","src/book.js","src/continuous.js","src/core.js","src/epubcfi.js","src/hook.js","src/layout.js","src/locations.js","src/map.js","src/navigation.js","src/paginate.js","src/parser.js","src/queue.js","src/rendition.js","src/replacements.js","src/request.js","src/section.js","src/spine.js","src/unarchive.js","src/view.js","src/views.js","src/epub.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzkDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3iBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"epub.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*\n From Zip.js, by Gildas Lormeau\nedited down\n */\n\nvar table = {\n\t\"application\" : {\n\t\t\"ecmascript\" : [ \"es\", \"ecma\" ],\n\t\t\"javascript\" : \"js\",\n\t\t\"ogg\" : \"ogx\",\n\t\t\"pdf\" : \"pdf\",\n\t\t\"postscript\" : [ \"ps\", \"ai\", \"eps\", \"epsi\", \"epsf\", \"eps2\", \"eps3\" ],\n\t\t\"rdf+xml\" : \"rdf\",\n\t\t\"smil\" : [ \"smi\", \"smil\" ],\n\t\t\"xhtml+xml\" : [ \"xhtml\", \"xht\" ],\n\t\t\"xml\" : [ \"xml\", \"xsl\", \"xsd\", \"opf\", \"ncx\" ],\n\t\t\"zip\" : \"zip\",\n\t\t\"x-httpd-eruby\" : \"rhtml\",\n\t\t\"x-latex\" : \"latex\",\n\t\t\"x-maker\" : [ \"frm\", \"maker\", \"frame\", \"fm\", \"fb\", \"book\", \"fbdoc\" ],\n\t\t\"x-object\" : \"o\",\n\t\t\"x-shockwave-flash\" : [ \"swf\", \"swfl\" ],\n\t\t\"x-silverlight\" : \"scr\",\n\t\t\"epub+zip\" : \"epub\",\n\t\t\"font-tdpfr\" : \"pfr\",\n\t\t\"inkml+xml\" : [ \"ink\", \"inkml\" ],\n\t\t\"json\" : \"json\",\n\t\t\"jsonml+json\" : \"jsonml\",\n\t\t\"mathml+xml\" : \"mathml\",\n\t\t\"metalink+xml\" : \"metalink\",\n\t\t\"mp4\" : \"mp4s\",\n\t\t// \"oebps-package+xml\" : \"opf\",\n\t\t\"omdoc+xml\" : \"omdoc\",\n\t\t\"oxps\" : \"oxps\",\n\t\t\"vnd.amazon.ebook\" : \"azw\",\n\t\t\"widget\" : \"wgt\",\n\t\t// \"x-dtbncx+xml\" : \"ncx\",\n\t\t\"x-dtbook+xml\" : \"dtb\",\n\t\t\"x-dtbresource+xml\" : \"res\",\n\t\t\"x-font-bdf\" : \"bdf\",\n\t\t\"x-font-ghostscript\" : \"gsf\",\n\t\t\"x-font-linux-psf\" : \"psf\",\n\t\t\"x-font-otf\" : \"otf\",\n\t\t\"x-font-pcf\" : \"pcf\",\n\t\t\"x-font-snf\" : \"snf\",\n\t\t\"x-font-ttf\" : [ \"ttf\", \"ttc\" ],\n\t\t\"x-font-type1\" : [ \"pfa\", \"pfb\", \"pfm\", \"afm\" ],\n\t\t\"x-font-woff\" : \"woff\",\n\t\t\"x-mobipocket-ebook\" : [ \"prc\", \"mobi\" ],\n\t\t\"x-mspublisher\" : \"pub\",\n\t\t\"x-nzb\" : \"nzb\",\n\t\t\"x-tgif\" : \"obj\",\n\t\t\"xaml+xml\" : \"xaml\",\n\t\t\"xml-dtd\" : \"dtd\",\n\t\t\"xproc+xml\" : \"xpl\",\n\t\t\"xslt+xml\" : \"xslt\",\n\t\t\"internet-property-stream\" : \"acx\",\n\t\t\"x-compress\" : \"z\",\n\t\t\"x-compressed\" : \"tgz\",\n\t\t\"x-gzip\" : \"gz\",\n\t},\n\t\"audio\" : {\n\t\t\"flac\" : \"flac\",\n\t\t\"midi\" : [ \"mid\", \"midi\", \"kar\", \"rmi\" ],\n\t\t\"mpeg\" : [ \"mpga\", \"mpega\", \"mp2\", \"mp3\", \"m4a\", \"mp2a\", \"m2a\", \"m3a\" ],\n\t\t\"mpegurl\" : \"m3u\",\n\t\t\"ogg\" : [ \"oga\", \"ogg\", \"spx\" ],\n\t\t\"x-aiff\" : [ \"aif\", \"aiff\", \"aifc\" ],\n\t\t\"x-ms-wma\" : \"wma\",\n\t\t\"x-wav\" : \"wav\",\n\t\t\"adpcm\" : \"adp\",\n\t\t\"mp4\" : \"mp4a\",\n\t\t\"webm\" : \"weba\",\n\t\t\"x-aac\" : \"aac\",\n\t\t\"x-caf\" : \"caf\",\n\t\t\"x-matroska\" : \"mka\",\n\t\t\"x-pn-realaudio-plugin\" : \"rmp\",\n\t\t\"xm\" : \"xm\",\n\t\t\"mid\" : [ \"mid\", \"rmi\" ]\n\t},\n\t\"image\" : {\n\t\t\"gif\" : \"gif\",\n\t\t\"ief\" : \"ief\",\n\t\t\"jpeg\" : [ \"jpeg\", \"jpg\", \"jpe\" ],\n\t\t\"pcx\" : \"pcx\",\n\t\t\"png\" : \"png\",\n\t\t\"svg+xml\" : [ \"svg\", \"svgz\" ],\n\t\t\"tiff\" : [ \"tiff\", \"tif\" ],\n\t\t\"x-icon\" : \"ico\",\n\t\t\"bmp\" : \"bmp\",\n\t\t\"webp\" : \"webp\",\n\t\t\"x-pict\" : [ \"pic\", \"pct\" ],\n\t\t\"x-tga\" : \"tga\",\n\t\t\"cis-cod\" : \"cod\"\n\t},\n\t\"text\" : {\n\t\t\"cache-manifest\" : [ \"manifest\", \"appcache\" ],\n\t\t\"css\" : \"css\",\n\t\t\"csv\" : \"csv\",\n\t\t\"html\" : [ \"html\", \"htm\", \"shtml\", \"stm\" ],\n\t\t\"mathml\" : \"mml\",\n\t\t\"plain\" : [ \"txt\", \"text\", \"brf\", \"conf\", \"def\", \"list\", \"log\", \"in\", \"bas\" ],\n\t\t\"richtext\" : \"rtx\",\n\t\t\"tab-separated-values\" : \"tsv\",\n\t\t\"x-bibtex\" : \"bib\"\n\t},\n\t\"video\" : {\n\t\t\"mpeg\" : [ \"mpeg\", \"mpg\", \"mpe\", \"m1v\", \"m2v\", \"mp2\", \"mpa\", \"mpv2\" ],\n\t\t\"mp4\" : [ \"mp4\", \"mp4v\", \"mpg4\" ],\n\t\t\"quicktime\" : [ \"qt\", \"mov\" ],\n\t\t\"ogg\" : \"ogv\",\n\t\t\"vnd.mpegurl\" : [ \"mxu\", \"m4u\" ],\n\t\t\"x-flv\" : \"flv\",\n\t\t\"x-la-asf\" : [ \"lsf\", \"lsx\" ],\n\t\t\"x-mng\" : \"mng\",\n\t\t\"x-ms-asf\" : [ \"asf\", \"asx\", \"asr\" ],\n\t\t\"x-ms-wm\" : \"wm\",\n\t\t\"x-ms-wmv\" : \"wmv\",\n\t\t\"x-ms-wmx\" : \"wmx\",\n\t\t\"x-ms-wvx\" : \"wvx\",\n\t\t\"x-msvideo\" : \"avi\",\n\t\t\"x-sgi-movie\" : \"movie\",\n\t\t\"x-matroska\" : [ \"mpv\", \"mkv\", \"mk3d\", \"mks\" ],\n\t\t\"3gpp2\" : \"3g2\",\n\t\t\"h261\" : \"h261\",\n\t\t\"h263\" : \"h263\",\n\t\t\"h264\" : \"h264\",\n\t\t\"jpeg\" : \"jpgv\",\n\t\t\"jpm\" : [ \"jpm\", \"jpgm\" ],\n\t\t\"mj2\" : [ \"mj2\", \"mjp2\" ],\n\t\t\"vnd.ms-playready.media.pyv\" : \"pyv\",\n\t\t\"vnd.uvvu.mp4\" : [ \"uvu\", \"uvvu\" ],\n\t\t\"vnd.vivo\" : \"viv\",\n\t\t\"webm\" : \"webm\",\n\t\t\"x-f4v\" : \"f4v\",\n\t\t\"x-m4v\" : \"m4v\",\n\t\t\"x-ms-vob\" : \"vob\",\n\t\t\"x-smv\" : \"smv\"\n\t}\n};\n\nvar mimeTypes = (function() {\n\tvar type, subtype, val, index, mimeTypes = {};\n\tfor (type in table) {\n\t\tif (table.hasOwnProperty(type)) {\n\t\t\tfor (subtype in table[type]) {\n\t\t\t\tif (table[type].hasOwnProperty(subtype)) {\n\t\t\t\t\tval = table[type][subtype];\n\t\t\t\t\tif (typeof val == \"string\") {\n\t\t\t\t\t\tmimeTypes[val] = type + \"/\" + subtype;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (index = 0; index < val.length; index++) {\n\t\t\t\t\t\t\tmimeTypes[val[index]] = type + \"/\" + subtype;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn mimeTypes;\n})();\n\nvar defaultValue = \"text/plain\";//\"application/octet-stream\";\n\nfunction lookup(filename) {\n\treturn filename && mimeTypes[filename.split(\".\").pop().toLowerCase()] || defaultValue;\n};\n\nmodule.exports = lookup\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*!\n * @overview RSVP - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/tildeio/rsvp.js/master/LICENSE\n * @version   3.0.14\n */\n\n(function() {\n    \"use strict\";\n\n    function $$rsvp$events$$indexOf(callbacks, callback) {\n      for (var i=0, l=callbacks.length; i<l; i++) {\n        if (callbacks[i] === callback) { return i; }\n      }\n\n      return -1;\n    }\n\n    function $$rsvp$events$$callbacksFor(object) {\n      var callbacks = object._promiseCallbacks;\n\n      if (!callbacks) {\n        callbacks = object._promiseCallbacks = {};\n      }\n\n      return callbacks;\n    }\n\n    var $$rsvp$events$$default = {\n\n      /**\n        `RSVP.EventTarget.mixin` extends an object with EventTarget methods. For\n        Example:\n\n        ```javascript\n        var object = {};\n\n        RSVP.EventTarget.mixin(object);\n\n        object.on('finished', function(event) {\n          // handle event\n        });\n\n        object.trigger('finished', { detail: value });\n        ```\n\n        `EventTarget.mixin` also works with prototypes:\n\n        ```javascript\n        var Person = function() {};\n        RSVP.EventTarget.mixin(Person.prototype);\n\n        var yehuda = new Person();\n        var tom = new Person();\n\n        yehuda.on('poke', function(event) {\n          console.log('Yehuda says OW');\n        });\n\n        tom.on('poke', function(event) {\n          console.log('Tom says OW');\n        });\n\n        yehuda.trigger('poke');\n        tom.trigger('poke');\n        ```\n\n        @method mixin\n        @for RSVP.EventTarget\n        @private\n        @param {Object} object object to extend with EventTarget methods\n      */\n      mixin: function(object) {\n        object.on = this.on;\n        object.off = this.off;\n        object.trigger = this.trigger;\n        object._promiseCallbacks = undefined;\n        return object;\n      },\n\n      /**\n        Registers a callback to be executed when `eventName` is triggered\n\n        ```javascript\n        object.on('event', function(eventInfo){\n          // handle the event\n        });\n\n        object.trigger('event');\n        ```\n\n        @method on\n        @for RSVP.EventTarget\n        @private\n        @param {String} eventName name of the event to listen for\n        @param {Function} callback function to be called when the event is triggered.\n      */\n      on: function(eventName, callback) {\n        var allCallbacks = $$rsvp$events$$callbacksFor(this), callbacks;\n\n        callbacks = allCallbacks[eventName];\n\n        if (!callbacks) {\n          callbacks = allCallbacks[eventName] = [];\n        }\n\n        if ($$rsvp$events$$indexOf(callbacks, callback) === -1) {\n          callbacks.push(callback);\n        }\n      },\n\n      /**\n        You can use `off` to stop firing a particular callback for an event:\n\n        ```javascript\n        function doStuff() { // do stuff! }\n        object.on('stuff', doStuff);\n\n        object.trigger('stuff'); // doStuff will be called\n\n        // Unregister ONLY the doStuff callback\n        object.off('stuff', doStuff);\n        object.trigger('stuff'); // doStuff will NOT be called\n        ```\n\n        If you don't pass a `callback` argument to `off`, ALL callbacks for the\n        event will not be executed when the event fires. For example:\n\n        ```javascript\n        var callback1 = function(){};\n        var callback2 = function(){};\n\n        object.on('stuff', callback1);\n        object.on('stuff', callback2);\n\n        object.trigger('stuff'); // callback1 and callback2 will be executed.\n\n        object.off('stuff');\n        object.trigger('stuff'); // callback1 and callback2 will not be executed!\n        ```\n\n        @method off\n        @for RSVP.EventTarget\n        @private\n        @param {String} eventName event to stop listening to\n        @param {Function} callback optional argument. If given, only the function\n        given will be removed from the event's callback queue. If no `callback`\n        argument is given, all callbacks will be removed from the event's callback\n        queue.\n      */\n      off: function(eventName, callback) {\n        var allCallbacks = $$rsvp$events$$callbacksFor(this), callbacks, index;\n\n        if (!callback) {\n          allCallbacks[eventName] = [];\n          return;\n        }\n\n        callbacks = allCallbacks[eventName];\n\n        index = $$rsvp$events$$indexOf(callbacks, callback);\n\n        if (index !== -1) { callbacks.splice(index, 1); }\n      },\n\n      /**\n        Use `trigger` to fire custom events. For example:\n\n        ```javascript\n        object.on('foo', function(){\n          console.log('foo event happened!');\n        });\n        object.trigger('foo');\n        // 'foo event happened!' logged to the console\n        ```\n\n        You can also pass a value as a second argument to `trigger` that will be\n        passed as an argument to all event listeners for the event:\n\n        ```javascript\n        object.on('foo', function(value){\n          console.log(value.name);\n        });\n\n        object.trigger('foo', { name: 'bar' });\n        // 'bar' logged to the console\n        ```\n\n        @method trigger\n        @for RSVP.EventTarget\n        @private\n        @param {String} eventName name of the event to be triggered\n        @param {Any} options optional value to be passed to any event handlers for\n        the given `eventName`\n      */\n      trigger: function(eventName, options) {\n        var allCallbacks = $$rsvp$events$$callbacksFor(this), callbacks, callback;\n\n        if (callbacks = allCallbacks[eventName]) {\n          // Don't cache the callbacks.length since it may grow\n          for (var i=0; i<callbacks.length; i++) {\n            callback = callbacks[i];\n\n            callback(options);\n          }\n        }\n      }\n    };\n\n    var $$rsvp$config$$config = {\n      instrument: false\n    };\n\n    $$rsvp$events$$default.mixin($$rsvp$config$$config);\n\n    function $$rsvp$config$$configure(name, value) {\n      if (name === 'onerror') {\n        // handle for legacy users that expect the actual\n        // error to be passed to their function added via\n        // `RSVP.configure('onerror', someFunctionHere);`\n        $$rsvp$config$$config.on('error', value);\n        return;\n      }\n\n      if (arguments.length === 2) {\n        $$rsvp$config$$config[name] = value;\n      } else {\n        return $$rsvp$config$$config[name];\n      }\n    }\n\n    function $$utils$$objectOrFunction(x) {\n      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n    }\n\n    function $$utils$$isFunction(x) {\n      return typeof x === 'function';\n    }\n\n    function $$utils$$isMaybeThenable(x) {\n      return typeof x === 'object' && x !== null;\n    }\n\n    var $$utils$$_isArray;\n\n    if (!Array.isArray) {\n      $$utils$$_isArray = function (x) {\n        return Object.prototype.toString.call(x) === '[object Array]';\n      };\n    } else {\n      $$utils$$_isArray = Array.isArray;\n    }\n\n    var $$utils$$isArray = $$utils$$_isArray;\n    var $$utils$$now = Date.now || function() { return new Date().getTime(); };\n    function $$utils$$F() { }\n\n    var $$utils$$o_create = (Object.create || function (o) {\n      if (arguments.length > 1) {\n        throw new Error('Second argument not supported');\n      }\n      if (typeof o !== 'object') {\n        throw new TypeError('Argument must be an object');\n      }\n      $$utils$$F.prototype = o;\n      return new $$utils$$F();\n    });\n\n    var $$instrument$$queue = [];\n\n    var $$instrument$$default = function instrument(eventName, promise, child) {\n      if (1 === $$instrument$$queue.push({\n          name: eventName,\n          payload: {\n            guid: promise._guidKey + promise._id,\n            eventName: eventName,\n            detail: promise._result,\n            childGuid: child && promise._guidKey + child._id,\n            label: promise._label,\n            timeStamp: $$utils$$now(),\n            stack: new Error(promise._label).stack\n          }})) {\n\n            setTimeout(function() {\n              var entry;\n              for (var i = 0; i < $$instrument$$queue.length; i++) {\n                entry = $$instrument$$queue[i];\n                $$rsvp$config$$config.trigger(entry.name, entry.payload);\n              }\n              $$instrument$$queue.length = 0;\n            }, 50);\n          }\n      };\n\n    function $$$internal$$noop() {}\n    var $$$internal$$PENDING   = void 0;\n    var $$$internal$$FULFILLED = 1;\n    var $$$internal$$REJECTED  = 2;\n    var $$$internal$$GET_THEN_ERROR = new $$$internal$$ErrorObject();\n\n    function $$$internal$$getThen(promise) {\n      try {\n        return promise.then;\n      } catch(error) {\n        $$$internal$$GET_THEN_ERROR.error = error;\n        return $$$internal$$GET_THEN_ERROR;\n      }\n    }\n\n    function $$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n      try {\n        then.call(value, fulfillmentHandler, rejectionHandler);\n      } catch(e) {\n        return e;\n      }\n    }\n\n    function $$$internal$$handleForeignThenable(promise, thenable, then) {\n      $$rsvp$config$$config.async(function(promise) {\n        var sealed = false;\n        var error = $$$internal$$tryThen(then, thenable, function(value) {\n          if (sealed) { return; }\n          sealed = true;\n          if (thenable !== value) {\n            $$$internal$$resolve(promise, value);\n          } else {\n            $$$internal$$fulfill(promise, value);\n          }\n        }, function(reason) {\n          if (sealed) { return; }\n          sealed = true;\n\n          $$$internal$$reject(promise, reason);\n        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n        if (!sealed && error) {\n          sealed = true;\n          $$$internal$$reject(promise, error);\n        }\n      }, promise);\n    }\n\n    function $$$internal$$handleOwnThenable(promise, thenable) {\n      if (thenable._state === $$$internal$$FULFILLED) {\n        $$$internal$$fulfill(promise, thenable._result);\n      } else if (promise._state === $$$internal$$REJECTED) {\n        $$$internal$$reject(promise, thenable._result);\n      } else {\n        $$$internal$$subscribe(thenable, undefined, function(value) {\n          if (thenable !== value) {\n            $$$internal$$resolve(promise, value);\n          } else {\n            $$$internal$$fulfill(promise, value);\n          }\n        }, function(reason) {\n          $$$internal$$reject(promise, reason);\n        });\n      }\n    }\n\n    function $$$internal$$handleMaybeThenable(promise, maybeThenable) {\n      if (maybeThenable.constructor === promise.constructor) {\n        $$$internal$$handleOwnThenable(promise, maybeThenable);\n      } else {\n        var then = $$$internal$$getThen(maybeThenable);\n\n        if (then === $$$internal$$GET_THEN_ERROR) {\n          $$$internal$$reject(promise, $$$internal$$GET_THEN_ERROR.error);\n        } else if (then === undefined) {\n          $$$internal$$fulfill(promise, maybeThenable);\n        } else if ($$utils$$isFunction(then)) {\n          $$$internal$$handleForeignThenable(promise, maybeThenable, then);\n        } else {\n          $$$internal$$fulfill(promise, maybeThenable);\n        }\n      }\n    }\n\n    function $$$internal$$resolve(promise, value) {\n      if (promise === value) {\n        $$$internal$$fulfill(promise, value);\n      } else if ($$utils$$objectOrFunction(value)) {\n        $$$internal$$handleMaybeThenable(promise, value);\n      } else {\n        $$$internal$$fulfill(promise, value);\n      }\n    }\n\n    function $$$internal$$publishRejection(promise) {\n      if (promise._onerror) {\n        promise._onerror(promise._result);\n      }\n\n      $$$internal$$publish(promise);\n    }\n\n    function $$$internal$$fulfill(promise, value) {\n      if (promise._state !== $$$internal$$PENDING) { return; }\n\n      promise._result = value;\n      promise._state = $$$internal$$FULFILLED;\n\n      if (promise._subscribers.length === 0) {\n        if ($$rsvp$config$$config.instrument) {\n          $$instrument$$default('fulfilled', promise);\n        }\n      } else {\n        $$rsvp$config$$config.async($$$internal$$publish, promise);\n      }\n    }\n\n    function $$$internal$$reject(promise, reason) {\n      if (promise._state !== $$$internal$$PENDING) { return; }\n      promise._state = $$$internal$$REJECTED;\n      promise._result = reason;\n\n      $$rsvp$config$$config.async($$$internal$$publishRejection, promise);\n    }\n\n    function $$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n      var subscribers = parent._subscribers;\n      var length = subscribers.length;\n\n      parent._onerror = null;\n\n      subscribers[length] = child;\n      subscribers[length + $$$internal$$FULFILLED] = onFulfillment;\n      subscribers[length + $$$internal$$REJECTED]  = onRejection;\n\n      if (length === 0 && parent._state) {\n        $$rsvp$config$$config.async($$$internal$$publish, parent);\n      }\n    }\n\n    function $$$internal$$publish(promise) {\n      var subscribers = promise._subscribers;\n      var settled = promise._state;\n\n      if ($$rsvp$config$$config.instrument) {\n        $$instrument$$default(settled === $$$internal$$FULFILLED ? 'fulfilled' : 'rejected', promise);\n      }\n\n      if (subscribers.length === 0) { return; }\n\n      var child, callback, detail = promise._result;\n\n      for (var i = 0; i < subscribers.length; i += 3) {\n        child = subscribers[i];\n        callback = subscribers[i + settled];\n\n        if (child) {\n          $$$internal$$invokeCallback(settled, child, callback, detail);\n        } else {\n          callback(detail);\n        }\n      }\n\n      promise._subscribers.length = 0;\n    }\n\n    function $$$internal$$ErrorObject() {\n      this.error = null;\n    }\n\n    var $$$internal$$TRY_CATCH_ERROR = new $$$internal$$ErrorObject();\n\n    function $$$internal$$tryCatch(callback, detail) {\n      try {\n        return callback(detail);\n      } catch(e) {\n        $$$internal$$TRY_CATCH_ERROR.error = e;\n        return $$$internal$$TRY_CATCH_ERROR;\n      }\n    }\n\n    function $$$internal$$invokeCallback(settled, promise, callback, detail) {\n      var hasCallback = $$utils$$isFunction(callback),\n          value, error, succeeded, failed;\n\n      if (hasCallback) {\n        value = $$$internal$$tryCatch(callback, detail);\n\n        if (value === $$$internal$$TRY_CATCH_ERROR) {\n          failed = true;\n          error = value.error;\n          value = null;\n        } else {\n          succeeded = true;\n        }\n\n        if (promise === value) {\n          $$$internal$$reject(promise, new TypeError('A promises callback cannot return that same promise.'));\n          return;\n        }\n\n      } else {\n        value = detail;\n        succeeded = true;\n      }\n\n      if (promise._state !== $$$internal$$PENDING) {\n        // noop\n      } else if (hasCallback && succeeded) {\n        $$$internal$$resolve(promise, value);\n      } else if (failed) {\n        $$$internal$$reject(promise, error);\n      } else if (settled === $$$internal$$FULFILLED) {\n        $$$internal$$fulfill(promise, value);\n      } else if (settled === $$$internal$$REJECTED) {\n        $$$internal$$reject(promise, value);\n      }\n    }\n\n    function $$$internal$$initializePromise(promise, resolver) {\n      try {\n        resolver(function resolvePromise(value){\n          $$$internal$$resolve(promise, value);\n        }, function rejectPromise(reason) {\n          $$$internal$$reject(promise, reason);\n        });\n      } catch(e) {\n        $$$internal$$reject(promise, e);\n      }\n    }\n\n    function $$enumerator$$makeSettledResult(state, position, value) {\n      if (state === $$$internal$$FULFILLED) {\n        return {\n          state: 'fulfilled',\n          value: value\n        };\n      } else {\n        return {\n          state: 'rejected',\n          reason: value\n        };\n      }\n    }\n\n    function $$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {\n      this._instanceConstructor = Constructor;\n      this.promise = new Constructor($$$internal$$noop, label);\n      this._abortOnReject = abortOnReject;\n\n      if (this._validateInput(input)) {\n        this._input     = input;\n        this.length     = input.length;\n        this._remaining = input.length;\n\n        this._init();\n\n        if (this.length === 0) {\n          $$$internal$$fulfill(this.promise, this._result);\n        } else {\n          this.length = this.length || 0;\n          this._enumerate();\n          if (this._remaining === 0) {\n            $$$internal$$fulfill(this.promise, this._result);\n          }\n        }\n      } else {\n        $$$internal$$reject(this.promise, this._validationError());\n      }\n    }\n\n    $$enumerator$$Enumerator.prototype._validateInput = function(input) {\n      return $$utils$$isArray(input);\n    };\n\n    $$enumerator$$Enumerator.prototype._validationError = function() {\n      return new Error('Array Methods must be provided an Array');\n    };\n\n    $$enumerator$$Enumerator.prototype._init = function() {\n      this._result = new Array(this.length);\n    };\n\n    var $$enumerator$$default = $$enumerator$$Enumerator;\n\n    $$enumerator$$Enumerator.prototype._enumerate = function() {\n      var length  = this.length;\n      var promise = this.promise;\n      var input   = this._input;\n\n      for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {\n        this._eachEntry(input[i], i);\n      }\n    };\n\n    $$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n      var c = this._instanceConstructor;\n      if ($$utils$$isMaybeThenable(entry)) {\n        if (entry.constructor === c && entry._state !== $$$internal$$PENDING) {\n          entry._onerror = null;\n          this._settledAt(entry._state, i, entry._result);\n        } else {\n          this._willSettleAt(c.resolve(entry), i);\n        }\n      } else {\n        this._remaining--;\n        this._result[i] = this._makeResult($$$internal$$FULFILLED, i, entry);\n      }\n    };\n\n    $$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n      var promise = this.promise;\n\n      if (promise._state === $$$internal$$PENDING) {\n        this._remaining--;\n\n        if (this._abortOnReject && state === $$$internal$$REJECTED) {\n          $$$internal$$reject(promise, value);\n        } else {\n          this._result[i] = this._makeResult(state, i, value);\n        }\n      }\n\n      if (this._remaining === 0) {\n        $$$internal$$fulfill(promise, this._result);\n      }\n    };\n\n    $$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {\n      return value;\n    };\n\n    $$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n      var enumerator = this;\n\n      $$$internal$$subscribe(promise, undefined, function(value) {\n        enumerator._settledAt($$$internal$$FULFILLED, i, value);\n      }, function(reason) {\n        enumerator._settledAt($$$internal$$REJECTED, i, reason);\n      });\n    };\n\n    var $$promise$all$$default = function all(entries, label) {\n      return new $$enumerator$$default(this, entries, true /* abort on reject */, label).promise;\n    };\n\n    var $$promise$race$$default = function race(entries, label) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      var promise = new Constructor($$$internal$$noop, label);\n\n      if (!$$utils$$isArray(entries)) {\n        $$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n        return promise;\n      }\n\n      var length = entries.length;\n\n      function onFulfillment(value) {\n        $$$internal$$resolve(promise, value);\n      }\n\n      function onRejection(reason) {\n        $$$internal$$reject(promise, reason);\n      }\n\n      for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {\n        $$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n      }\n\n      return promise;\n    };\n\n    var $$promise$resolve$$default = function resolve(object, label) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      if (object && typeof object === 'object' && object.constructor === Constructor) {\n        return object;\n      }\n\n      var promise = new Constructor($$$internal$$noop, label);\n      $$$internal$$resolve(promise, object);\n      return promise;\n    };\n\n    var $$promise$reject$$default = function reject(reason, label) {\n      /*jshint validthis:true */\n      var Constructor = this;\n      var promise = new Constructor($$$internal$$noop, label);\n      $$$internal$$reject(promise, reason);\n      return promise;\n    };\n\n    var $$rsvp$promise$$guidKey = 'rsvp_' + $$utils$$now() + '-';\n    var $$rsvp$promise$$counter = 0;\n\n    function $$rsvp$promise$$needsResolver() {\n      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n    }\n\n    function $$rsvp$promise$$needsNew() {\n      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n    }\n\n    var $$rsvp$promise$$default = $$rsvp$promise$$Promise;\n\n    /**\n      Promise objects represent the eventual result of an asynchronous operation. The\n      primary way of interacting with a promise is through its `then` method, which\n      registers callbacks to receive either a promise’s eventual value or the reason\n      why the promise cannot be fulfilled.\n\n      Terminology\n      -----------\n\n      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n      - `thenable` is an object or function that defines a `then` method.\n      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n      - `exception` is a value that is thrown using the throw statement.\n      - `reason` is a value that indicates why a promise was rejected.\n      - `settled` the final resting state of a promise, fulfilled or rejected.\n\n      A promise can be in one of three states: pending, fulfilled, or rejected.\n\n      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n      state.  Promises that are rejected have a rejection reason and are in the\n      rejected state.  A fulfillment value is never a thenable.\n\n      Promises can also be said to *resolve* a value.  If this value is also a\n      promise, then the original promise's settled state will match the value's\n      settled state.  So a promise that *resolves* a promise that rejects will\n      itself reject, and a promise that *resolves* a promise that fulfills will\n      itself fulfill.\n\n\n      Basic Usage:\n      ------------\n\n      ```js\n      var promise = new Promise(function(resolve, reject) {\n        // on success\n        resolve(value);\n\n        // on failure\n        reject(reason);\n      });\n\n      promise.then(function(value) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Advanced Usage:\n      ---------------\n\n      Promises shine when abstracting away asynchronous interactions such as\n      `XMLHttpRequest`s.\n\n      ```js\n      function getJSON(url) {\n        return new Promise(function(resolve, reject){\n          var xhr = new XMLHttpRequest();\n\n          xhr.open('GET', url);\n          xhr.onreadystatechange = handler;\n          xhr.responseType = 'json';\n          xhr.setRequestHeader('Accept', 'application/json');\n          xhr.send();\n\n          function handler() {\n            if (this.readyState === this.DONE) {\n              if (this.status === 200) {\n                resolve(this.response);\n              } else {\n                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n              }\n            }\n          };\n        });\n      }\n\n      getJSON('/posts.json').then(function(json) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Unlike callbacks, promises are great composable primitives.\n\n      ```js\n      Promise.all([\n        getJSON('/posts'),\n        getJSON('/comments')\n      ]).then(function(values){\n        values[0] // => postsJSON\n        values[1] // => commentsJSON\n\n        return values;\n      });\n      ```\n\n      @class RSVP.Promise\n      @param {function} resolver\n      @param {String} label optional string for labeling the promise.\n      Useful for tooling.\n      @constructor\n    */\n    function $$rsvp$promise$$Promise(resolver, label) {\n      this._id = $$rsvp$promise$$counter++;\n      this._label = label;\n      this._state = undefined;\n      this._result = undefined;\n      this._subscribers = [];\n\n      if ($$rsvp$config$$config.instrument) {\n        $$instrument$$default('created', this);\n      }\n\n      if ($$$internal$$noop !== resolver) {\n        if (!$$utils$$isFunction(resolver)) {\n          $$rsvp$promise$$needsResolver();\n        }\n\n        if (!(this instanceof $$rsvp$promise$$Promise)) {\n          $$rsvp$promise$$needsNew();\n        }\n\n        $$$internal$$initializePromise(this, resolver);\n      }\n    }\n\n    // deprecated\n    $$rsvp$promise$$Promise.cast = $$promise$resolve$$default;\n\n    $$rsvp$promise$$Promise.all = $$promise$all$$default;\n    $$rsvp$promise$$Promise.race = $$promise$race$$default;\n    $$rsvp$promise$$Promise.resolve = $$promise$resolve$$default;\n    $$rsvp$promise$$Promise.reject = $$promise$reject$$default;\n\n    $$rsvp$promise$$Promise.prototype = {\n      constructor: $$rsvp$promise$$Promise,\n\n      _guidKey: $$rsvp$promise$$guidKey,\n\n      _onerror: function (reason) {\n        $$rsvp$config$$config.trigger('error', reason);\n      },\n\n    /**\n      The primary way of interacting with a promise is through its `then` method,\n      which registers callbacks to receive either a promise's eventual value or the\n      reason why the promise cannot be fulfilled.\n\n      ```js\n      findUser().then(function(user){\n        // user is available\n      }, function(reason){\n        // user is unavailable, and you are given the reason why\n      });\n      ```\n\n      Chaining\n      --------\n\n      The return value of `then` is itself a promise.  This second, 'downstream'\n      promise is resolved with the return value of the first promise's fulfillment\n      or rejection handler, or rejected if the handler throws an exception.\n\n      ```js\n      findUser().then(function (user) {\n        return user.name;\n      }, function (reason) {\n        return 'default name';\n      }).then(function (userName) {\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n        // will be `'default name'`\n      });\n\n      findUser().then(function (user) {\n        throw new Error('Found user, but still unhappy');\n      }, function (reason) {\n        throw new Error('`findUser` rejected and we're unhappy');\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n      });\n      ```\n      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\n      ```js\n      findUser().then(function (user) {\n        throw new PedagogicalException('Upstream error');\n      }).then(function (value) {\n        // never reached\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // The `PedgagocialException` is propagated all the way down to here\n      });\n      ```\n\n      Assimilation\n      ------------\n\n      Sometimes the value you want to propagate to a downstream promise can only be\n      retrieved asynchronously. This can be achieved by returning a promise in the\n      fulfillment or rejection handler. The downstream promise will then be pending\n      until the returned promise is settled. This is called *assimilation*.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // The user's comments are now available\n      });\n      ```\n\n      If the assimliated promise rejects, then the downstream promise will also reject.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\n      }, function (reason) {\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\n      });\n      ```\n\n      Simple Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var result;\n\n      try {\n        result = findResult();\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n      findResult(function(result, err){\n        if (err) {\n          // failure\n        } else {\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findResult().then(function(result){\n        // success\n      }, function(reason){\n        // failure\n      });\n      ```\n\n      Advanced Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var author, books;\n\n      try {\n        author = findAuthor();\n        books  = findBooksByAuthor(author);\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n\n      function foundBooks(books) {\n\n      }\n\n      function failure(reason) {\n\n      }\n\n      findAuthor(function(author, err){\n        if (err) {\n          failure(err);\n          // failure\n        } else {\n          try {\n            findBoooksByAuthor(author, function(books, err) {\n              if (err) {\n                failure(err);\n              } else {\n                try {\n                  foundBooks(books);\n                } catch(reason) {\n                  failure(reason);\n                }\n              }\n            });\n          } catch(error) {\n            failure(err);\n          }\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findAuthor().\n        then(findBooksByAuthor).\n        then(function(books){\n          // found books\n      }).catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method then\n      @param {Function} onFulfilled\n      @param {Function} onRejected\n      @param {String} label optional string for labeling the promise.\n      Useful for tooling.\n      @return {Promise}\n    */\n      then: function(onFulfillment, onRejection, label) {\n        var parent = this;\n        var state = parent._state;\n\n        if (state === $$$internal$$FULFILLED && !onFulfillment || state === $$$internal$$REJECTED && !onRejection) {\n          if ($$rsvp$config$$config.instrument) {\n            $$instrument$$default('chained', this, this);\n          }\n          return this;\n        }\n\n        parent._onerror = null;\n\n        var child = new this.constructor($$$internal$$noop, label);\n        var result = parent._result;\n\n        if ($$rsvp$config$$config.instrument) {\n          $$instrument$$default('chained', parent, child);\n        }\n\n        if (state) {\n          var callback = arguments[state - 1];\n          $$rsvp$config$$config.async(function(){\n            $$$internal$$invokeCallback(state, child, callback, result);\n          });\n        } else {\n          $$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n        }\n\n        return child;\n      },\n\n    /**\n      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n      as the catch block of a try/catch statement.\n\n      ```js\n      function findAuthor(){\n        throw new Error('couldn't find that author');\n      }\n\n      // synchronous\n      try {\n        findAuthor();\n      } catch(reason) {\n        // something went wrong\n      }\n\n      // async with promises\n      findAuthor().catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method catch\n      @param {Function} onRejection\n      @param {String} label optional string for labeling the promise.\n      Useful for tooling.\n      @return {Promise}\n    */\n      'catch': function(onRejection, label) {\n        return this.then(null, onRejection, label);\n      },\n\n    /**\n      `finally` will be invoked regardless of the promise's fate just as native\n      try/catch/finally behaves\n\n      Synchronous example:\n\n      ```js\n      findAuthor() {\n        if (Math.random() > 0.5) {\n          throw new Error();\n        }\n        return new Author();\n      }\n\n      try {\n        return findAuthor(); // succeed or fail\n      } catch(error) {\n        return findOtherAuther();\n      } finally {\n        // always runs\n        // doesn't affect the return value\n      }\n      ```\n\n      Asynchronous example:\n\n      ```js\n      findAuthor().catch(function(reason){\n        return findOtherAuther();\n      }).finally(function(){\n        // author was either found, or not\n      });\n      ```\n\n      @method finally\n      @param {Function} callback\n      @param {String} label optional string for labeling the promise.\n      Useful for tooling.\n      @return {Promise}\n    */\n      'finally': function(callback, label) {\n        var constructor = this.constructor;\n\n        return this.then(function(value) {\n          return constructor.resolve(callback()).then(function(){\n            return value;\n          });\n        }, function(reason) {\n          return constructor.resolve(callback()).then(function(){\n            throw reason;\n          });\n        }, label);\n      }\n    };\n\n    function $$rsvp$node$$Result() {\n      this.value = undefined;\n    }\n\n    var $$rsvp$node$$ERROR = new $$rsvp$node$$Result();\n    var $$rsvp$node$$GET_THEN_ERROR = new $$rsvp$node$$Result();\n\n    function $$rsvp$node$$getThen(obj) {\n      try {\n       return obj.then;\n      } catch(error) {\n        $$rsvp$node$$ERROR.value= error;\n        return $$rsvp$node$$ERROR;\n      }\n    }\n\n    function $$rsvp$node$$tryApply(f, s, a) {\n      try {\n        f.apply(s, a);\n      } catch(error) {\n        $$rsvp$node$$ERROR.value = error;\n        return $$rsvp$node$$ERROR;\n      }\n    }\n\n    function $$rsvp$node$$makeObject(_, argumentNames) {\n      var obj = {};\n      var name;\n      var i;\n      var length = _.length;\n      var args = new Array(length);\n\n      for (var x = 0; x < length; x++) {\n        args[x] = _[x];\n      }\n\n      for (i = 0; i < argumentNames.length; i++) {\n        name = argumentNames[i];\n        obj[name] = args[i + 1];\n      }\n\n      return obj;\n    }\n\n    function $$rsvp$node$$arrayResult(_) {\n      var length = _.length;\n      var args = new Array(length - 1);\n\n      for (var i = 1; i < length; i++) {\n        args[i - 1] = _[i];\n      }\n\n      return args;\n    }\n\n    function $$rsvp$node$$wrapThenable(then, promise) {\n      return {\n        then: function(onFulFillment, onRejection) {\n          return then.call(promise, onFulFillment, onRejection);\n        }\n      };\n    }\n\n    var $$rsvp$node$$default = function denodeify(nodeFunc, options) {\n      var fn = function() {\n        var self = this;\n        var l = arguments.length;\n        var args = new Array(l + 1);\n        var arg;\n        var promiseInput = false;\n\n        for (var i = 0; i < l; ++i) {\n          arg = arguments[i];\n\n          if (!promiseInput) {\n            // TODO: clean this up\n            promiseInput = $$rsvp$node$$needsPromiseInput(arg);\n            if (promiseInput === $$rsvp$node$$GET_THEN_ERROR) {\n              var p = new $$rsvp$promise$$default($$$internal$$noop);\n              $$$internal$$reject(p, $$rsvp$node$$GET_THEN_ERROR.value);\n              return p;\n            } else if (promiseInput && promiseInput !== true) {\n              arg = $$rsvp$node$$wrapThenable(promiseInput, arg);\n            }\n          }\n          args[i] = arg;\n        }\n\n        var promise = new $$rsvp$promise$$default($$$internal$$noop);\n\n        args[l] = function(err, val) {\n          if (err)\n            $$$internal$$reject(promise, err);\n          else if (options === undefined)\n            $$$internal$$resolve(promise, val);\n          else if (options === true)\n            $$$internal$$resolve(promise, $$rsvp$node$$arrayResult(arguments));\n          else if ($$utils$$isArray(options))\n            $$$internal$$resolve(promise, $$rsvp$node$$makeObject(arguments, options));\n          else\n            $$$internal$$resolve(promise, val);\n        };\n\n        if (promiseInput) {\n          return $$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self);\n        } else {\n          return $$rsvp$node$$handleValueInput(promise, args, nodeFunc, self);\n        }\n      };\n\n      fn.__proto__ = nodeFunc;\n\n      return fn;\n    };\n\n    function $$rsvp$node$$handleValueInput(promise, args, nodeFunc, self) {\n      var result = $$rsvp$node$$tryApply(nodeFunc, self, args);\n      if (result === $$rsvp$node$$ERROR) {\n        $$$internal$$reject(promise, result.value);\n      }\n      return promise;\n    }\n\n    function $$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self){\n      return $$rsvp$promise$$default.all(args).then(function(args){\n        var result = $$rsvp$node$$tryApply(nodeFunc, self, args);\n        if (result === $$rsvp$node$$ERROR) {\n          $$$internal$$reject(promise, result.value);\n        }\n        return promise;\n      });\n    }\n\n    function $$rsvp$node$$needsPromiseInput(arg) {\n      if (arg && typeof arg === 'object') {\n        if (arg.constructor === $$rsvp$promise$$default) {\n          return true;\n        } else {\n          return $$rsvp$node$$getThen(arg);\n        }\n      } else {\n        return false;\n      }\n    }\n\n    var $$rsvp$all$$default = function all(array, label) {\n      return $$rsvp$promise$$default.all(array, label);\n    };\n\n    function $$rsvp$all$settled$$AllSettled(Constructor, entries, label) {\n      this._superConstructor(Constructor, entries, false /* don't abort on reject */, label);\n    }\n\n    $$rsvp$all$settled$$AllSettled.prototype = $$utils$$o_create($$enumerator$$default.prototype);\n    $$rsvp$all$settled$$AllSettled.prototype._superConstructor = $$enumerator$$default;\n    $$rsvp$all$settled$$AllSettled.prototype._makeResult = $$enumerator$$makeSettledResult;\n\n    $$rsvp$all$settled$$AllSettled.prototype._validationError = function() {\n      return new Error('allSettled must be called with an array');\n    };\n\n    var $$rsvp$all$settled$$default = function allSettled(entries, label) {\n      return new $$rsvp$all$settled$$AllSettled($$rsvp$promise$$default, entries, label).promise;\n    };\n\n    var $$rsvp$race$$default = function race(array, label) {\n      return $$rsvp$promise$$default.race(array, label);\n    };\n\n    function $$promise$hash$$PromiseHash(Constructor, object, label) {\n      this._superConstructor(Constructor, object, true, label);\n    }\n\n    var $$promise$hash$$default = $$promise$hash$$PromiseHash;\n    $$promise$hash$$PromiseHash.prototype = $$utils$$o_create($$enumerator$$default.prototype);\n    $$promise$hash$$PromiseHash.prototype._superConstructor = $$enumerator$$default;\n\n    $$promise$hash$$PromiseHash.prototype._init = function() {\n      this._result = {};\n    };\n\n    $$promise$hash$$PromiseHash.prototype._validateInput = function(input) {\n      return input && typeof input === 'object';\n    };\n\n    $$promise$hash$$PromiseHash.prototype._validationError = function() {\n      return new Error('Promise.hash must be called with an object');\n    };\n\n    $$promise$hash$$PromiseHash.prototype._enumerate = function() {\n      var promise = this.promise;\n      var input   = this._input;\n      var results = [];\n\n      for (var key in input) {\n        if (promise._state === $$$internal$$PENDING && input.hasOwnProperty(key)) {\n          results.push({\n            position: key,\n            entry: input[key]\n          });\n        }\n      }\n\n      var length = results.length;\n      this._remaining = length;\n      var result;\n\n      for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {\n        result = results[i];\n        this._eachEntry(result.entry, result.position);\n      }\n    };\n\n    var $$rsvp$hash$$default = function hash(object, label) {\n      return new $$promise$hash$$default($$rsvp$promise$$default, object, label).promise;\n    };\n\n    function $$rsvp$hash$settled$$HashSettled(Constructor, object, label) {\n      this._superConstructor(Constructor, object, false, label);\n    }\n\n    $$rsvp$hash$settled$$HashSettled.prototype = $$utils$$o_create($$promise$hash$$default.prototype);\n    $$rsvp$hash$settled$$HashSettled.prototype._superConstructor = $$enumerator$$default;\n    $$rsvp$hash$settled$$HashSettled.prototype._makeResult = $$enumerator$$makeSettledResult;\n\n    $$rsvp$hash$settled$$HashSettled.prototype._validationError = function() {\n      return new Error('hashSettled must be called with an object');\n    };\n\n    var $$rsvp$hash$settled$$default = function hashSettled(object, label) {\n      return new $$rsvp$hash$settled$$HashSettled($$rsvp$promise$$default, object, label).promise;\n    };\n\n    var $$rsvp$rethrow$$default = function rethrow(reason) {\n      setTimeout(function() {\n        throw reason;\n      });\n      throw reason;\n    };\n\n    var $$rsvp$defer$$default = function defer(label) {\n      var deferred = { };\n\n      deferred.promise = new $$rsvp$promise$$default(function(resolve, reject) {\n        deferred.resolve = resolve;\n        deferred.reject = reject;\n      }, label);\n\n      return deferred;\n    };\n\n    var $$rsvp$map$$default = function map(promises, mapFn, label) {\n      return $$rsvp$promise$$default.all(promises, label).then(function(values) {\n        if (!$$utils$$isFunction(mapFn)) {\n          throw new TypeError(\"You must pass a function as map's second argument.\");\n        }\n\n        var length = values.length;\n        var results = new Array(length);\n\n        for (var i = 0; i < length; i++) {\n          results[i] = mapFn(values[i]);\n        }\n\n        return $$rsvp$promise$$default.all(results, label);\n      });\n    };\n\n    var $$rsvp$resolve$$default = function resolve(value, label) {\n      return $$rsvp$promise$$default.resolve(value, label);\n    };\n\n    var $$rsvp$reject$$default = function reject(reason, label) {\n      return $$rsvp$promise$$default.reject(reason, label);\n    };\n\n    var $$rsvp$filter$$default = function filter(promises, filterFn, label) {\n      return $$rsvp$promise$$default.all(promises, label).then(function(values) {\n        if (!$$utils$$isFunction(filterFn)) {\n          throw new TypeError(\"You must pass a function as filter's second argument.\");\n        }\n\n        var length = values.length;\n        var filtered = new Array(length);\n\n        for (var i = 0; i < length; i++) {\n          filtered[i] = filterFn(values[i]);\n        }\n\n        return $$rsvp$promise$$default.all(filtered, label).then(function(filtered) {\n          var results = new Array(length);\n          var newLength = 0;\n\n          for (var i = 0; i < length; i++) {\n            if (filtered[i]) {\n              results[newLength] = values[i];\n              newLength++;\n            }\n          }\n\n          results.length = newLength;\n\n          return results;\n        });\n      });\n    };\n\n    var $$rsvp$asap$$len = 0;\n\n    var $$rsvp$asap$$default = function asap(callback, arg) {\n      $$rsvp$asap$$queue[$$rsvp$asap$$len] = callback;\n      $$rsvp$asap$$queue[$$rsvp$asap$$len + 1] = arg;\n      $$rsvp$asap$$len += 2;\n      if ($$rsvp$asap$$len === 2) {\n        // If len is 1, that means that we need to schedule an async flush.\n        // If additional callbacks are queued before the queue is flushed, they\n        // will be processed by this flush that we are scheduling.\n        $$rsvp$asap$$scheduleFlush();\n      }\n    };\n\n    var $$rsvp$asap$$browserGlobal = (typeof window !== 'undefined') ? window : {};\n    var $$rsvp$asap$$BrowserMutationObserver = $$rsvp$asap$$browserGlobal.MutationObserver || $$rsvp$asap$$browserGlobal.WebKitMutationObserver;\n\n    // test for web worker but not in IE10\n    var $$rsvp$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n      typeof importScripts !== 'undefined' &&\n      typeof MessageChannel !== 'undefined';\n\n    // node\n    function $$rsvp$asap$$useNextTick() {\n      return function() {\n        process.nextTick($$rsvp$asap$$flush);\n      };\n    }\n\n    function $$rsvp$asap$$useMutationObserver() {\n      var iterations = 0;\n      var observer = new $$rsvp$asap$$BrowserMutationObserver($$rsvp$asap$$flush);\n      var node = document.createTextNode('');\n      observer.observe(node, { characterData: true });\n\n      return function() {\n        node.data = (iterations = ++iterations % 2);\n      };\n    }\n\n    // web worker\n    function $$rsvp$asap$$useMessageChannel() {\n      var channel = new MessageChannel();\n      channel.port1.onmessage = $$rsvp$asap$$flush;\n      return function () {\n        channel.port2.postMessage(0);\n      };\n    }\n\n    function $$rsvp$asap$$useSetTimeout() {\n      return function() {\n        setTimeout($$rsvp$asap$$flush, 1);\n      };\n    }\n\n    var $$rsvp$asap$$queue = new Array(1000);\n\n    function $$rsvp$asap$$flush() {\n      for (var i = 0; i < $$rsvp$asap$$len; i+=2) {\n        var callback = $$rsvp$asap$$queue[i];\n        var arg = $$rsvp$asap$$queue[i+1];\n\n        callback(arg);\n\n        $$rsvp$asap$$queue[i] = undefined;\n        $$rsvp$asap$$queue[i+1] = undefined;\n      }\n\n      $$rsvp$asap$$len = 0;\n    }\n\n    var $$rsvp$asap$$scheduleFlush;\n\n    // Decide what async method to use to triggering processing of queued callbacks:\n    if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\n      $$rsvp$asap$$scheduleFlush = $$rsvp$asap$$useNextTick();\n    } else if ($$rsvp$asap$$BrowserMutationObserver) {\n      $$rsvp$asap$$scheduleFlush = $$rsvp$asap$$useMutationObserver();\n    } else if ($$rsvp$asap$$isWorker) {\n      $$rsvp$asap$$scheduleFlush = $$rsvp$asap$$useMessageChannel();\n    } else {\n      $$rsvp$asap$$scheduleFlush = $$rsvp$asap$$useSetTimeout();\n    }\n\n    // default async is asap;\n    $$rsvp$config$$config.async = $$rsvp$asap$$default;\n\n    var $$rsvp$$cast = $$rsvp$resolve$$default;\n\n    function $$rsvp$$async(callback, arg) {\n      $$rsvp$config$$config.async(callback, arg);\n    }\n\n    function $$rsvp$$on() {\n      $$rsvp$config$$config.on.apply($$rsvp$config$$config, arguments);\n    }\n\n    function $$rsvp$$off() {\n      $$rsvp$config$$config.off.apply($$rsvp$config$$config, arguments);\n    }\n\n    // Set up instrumentation through `window.__PROMISE_INTRUMENTATION__`\n    if (typeof window !== 'undefined' && typeof window['__PROMISE_INSTRUMENTATION__'] === 'object') {\n      var $$rsvp$$callbacks = window['__PROMISE_INSTRUMENTATION__'];\n      $$rsvp$config$$configure('instrument', true);\n      for (var $$rsvp$$eventName in $$rsvp$$callbacks) {\n        if ($$rsvp$$callbacks.hasOwnProperty($$rsvp$$eventName)) {\n          $$rsvp$$on($$rsvp$$eventName, $$rsvp$$callbacks[$$rsvp$$eventName]);\n        }\n      }\n    }\n\n    var rsvp$umd$$RSVP = {\n      'race': $$rsvp$race$$default,\n      'Promise': $$rsvp$promise$$default,\n      'allSettled': $$rsvp$all$settled$$default,\n      'hash': $$rsvp$hash$$default,\n      'hashSettled': $$rsvp$hash$settled$$default,\n      'denodeify': $$rsvp$node$$default,\n      'on': $$rsvp$$on,\n      'off': $$rsvp$$off,\n      'map': $$rsvp$map$$default,\n      'filter': $$rsvp$filter$$default,\n      'resolve': $$rsvp$resolve$$default,\n      'reject': $$rsvp$reject$$default,\n      'all': $$rsvp$all$$default,\n      'rethrow': $$rsvp$rethrow$$default,\n      'defer': $$rsvp$defer$$default,\n      'EventTarget': $$rsvp$events$$default,\n      'configure': $$rsvp$config$$configure,\n      'async': $$rsvp$$async\n    };\n\n    /* global define:true module:true window: true */\n    if (typeof define === 'function' && define.amd) {\n      define(function() { return rsvp$umd$$RSVP; });\n    } else if (typeof module !== 'undefined' && module.exports) {\n      module.exports = rsvp$umd$$RSVP;\n    } else if (typeof this !== 'undefined') {\n      this['RSVP'] = rsvp$umd$$RSVP;\n    }\n}).call(this);","var RSVP = require('rsvp');\nvar core = require('./core');\nvar Spine = require('./spine');\nvar Locations = require('./locations');\nvar Parser = require('./parser');\nvar Navigation = require('./navigation');\nvar Rendition = require('./rendition');\nvar Continuous = require('./continuous');\nvar Paginate = require('./paginate');\nvar Unarchive = require('./unarchive');\nvar request = require('./request');\n\nfunction Book(_url, options){\n  // Promises\n  this.opening = new RSVP.defer();\n  this.opened = this.opening.promise;\n  this.isOpen = false;\n\n  this.url = undefined;\n\n  this.loading = {\n    manifest: new RSVP.defer(),\n    spine: new RSVP.defer(),\n    metadata: new RSVP.defer(),\n    cover: new RSVP.defer(),\n    navigation: new RSVP.defer(),\n    pageList: new RSVP.defer()\n  };\n\n  this.loaded = {\n    manifest: this.loading.manifest.promise,\n    spine: this.loading.spine.promise,\n    metadata: this.loading.metadata.promise,\n    cover: this.loading.cover.promise,\n    navigation: this.loading.navigation.promise,\n    pageList: this.loading.pageList.promise\n  };\n\n  this.ready = RSVP.hash(this.loaded);\n\n  // Queue for methods used before opening\n  this.isRendered = false;\n  // this._q = core.queue(this);\n\n  this.request = this.requestMethod.bind(this);\n\n  this.spine = new Spine(this.request);\n  this.locations = new Locations(this.spine, this.request);\n\n  if(_url) {\n    this.open(_url);\n  }\n};\n\nBook.prototype.open = function(_url){\n  var uri;\n  var parse = new Parser();\n  var epubPackage;\n  var epubContainer;\n  var book = this;\n  var containerPath = \"META-INF/container.xml\";\n  var location;\n\n  if(!_url) {\n    this.opening.resolve(this);\n    return this.opened;\n  }\n\n  // Reuse parsed url or create a new uri object\n  if(typeof(_url) === \"object\") {\n    uri = _url;\n  } else {\n    uri = core.uri(_url);\n  }\n\n  this.url = uri.href;\n\n  // Find path to the Container\n  if(uri.extension === \"opf\") {\n    // Direct link to package, no container\n    this.packageUrl = uri.href;\n    this.containerUrl = '';\n\n    if(uri.origin) {\n      this.baseUrl = uri.base;\n    } else if(window){\n      location = core.uri(window.location.href);\n      this.baseUrl = core.resolveUrl(location.base, uri.directory);\n    } else {\n      this.baseUrl = uri.directory;\n    }\n\n    epubPackage = this.request(this.packageUrl);\n\n  } else if(this.isArchived(uri)) {\n    // Book is archived\n    this.containerUrl = containerPath;\n    this.url = '';\n\n    epubContainer = this.unarchive(uri.href).\n      then(function() {\n        return this.request(this.containerUrl);\n      }.bind(this));\n\n  }\n  // Find the path to the Package from the container\n  else if (!uri.extension) {\n\n    this.containerUrl = this.url + containerPath;\n\n    epubContainer = this.request(this.containerUrl);\n  }\n\n  if (epubContainer) {\n    epubPackage = epubContainer.\n      then(function(containerXml){\n        return parse.container(containerXml); // Container has path to content\n      }).\n      then(function(paths){\n        var packageUri = core.uri(paths.packagePath);\n        book.packageUrl = book.url + paths.packagePath;\n        book.encoding = paths.encoding;\n\n        // Set Url relative to the content\n        if(packageUri.origin) {\n          book.baseUrl = packageUri.base;\n        } else if(window && book.url){\n          location = core.uri(window.location.href);\n          book.baseUrl = core.resolveUrl(location.base, book.url + packageUri.directory);\n        } else {\n          book.baseUrl = packageUri.directory;\n        }\n\n        return book.request(book.packageUrl);\n      }).catch(function(error) {\n        // handle errors in either of the two requests\n        console.error(\"Could not load book at: \" + (this.packageUrl || this.containerPath));\n        book.trigger(\"book:loadFailed\", (this.packageUrl || this.containerPath));\n        book.opening.reject(error);\n      });\n  }\n\n\n  epubPackage.then(function(packageXml) {\n    // Get package information from epub opf\n    book.unpack(packageXml);\n\n    // Resolve promises\n    book.loading.manifest.resolve(book.package.manifest);\n    book.loading.metadata.resolve(book.package.metadata);\n    book.loading.spine.resolve(book.spine);\n    book.loading.cover.resolve(book.cover);\n\n    book.isOpen = true;\n\n    // Clear queue of any waiting book request\n\n    // Resolve book opened promise\n    book.opening.resolve(book);\n\n  }).catch(function(error) {\n    // handle errors in parsing the book\n    console.error(error.message, error.stack);\n    book.opening.reject(error);\n  });\n\n  return this.opened;\n};\n\nBook.prototype.unpack = function(packageXml){\n  var book = this,\n      parse = new Parser();\n\n  book.package = parse.packageContents(packageXml); // Extract info from contents\n  book.package.baseUrl = book.baseUrl; // Provides a url base for resolving paths\n\n  this.spine.load(book.package);\n\n  book.navigation = new Navigation(book.package, this.request);\n  book.navigation.load().then(function(toc){\n    book.toc = toc;\n    book.loading.navigation.resolve(book.toc);\n  });\n\n  // //-- Set Global Layout setting based on metadata\n  // MOVE TO RENDER\n  // book.globalLayoutProperties = book.parseLayoutProperties(book.package.metadata);\n\n  book.cover = book.url + book.package.coverPath;\n};\n\n// Alias for book.spine.get\nBook.prototype.section = function(target) {\n  return this.spine.get(target);\n};\n\n// Sugar to render a book\nBook.prototype.renderTo = function(element, options) {\n  var renderMethod = (options && options.method) ?\n      options.method :\n      \"rendition\";\n  var Renderer = require('./'+renderMethod);\n\n  this.rendition = new Renderer(this, options);\n  this.rendition.attachTo(element);\n  return this.rendition;\n};\n\nBook.prototype.requestMethod = function(_url) {\n  // Switch request methods\n  if(this.archive) {\n    return this.archive.request(_url);\n  } else {\n    return request(_url, null, this.requestCredentials, this.requestHeaders);\n  }\n\n};\n\nBook.prototype.setRequestCredentials = function(_credentials) {\n  this.requestCredentials = _credentials;\n};\n\nBook.prototype.setRequestHeaders = function(_headers) {\n  this.requestHeaders = _headers;\n};\n\nBook.prototype.unarchive = function(bookUrl){\n\tthis.archive = new Unarchive();\n\treturn this.archive.open(bookUrl);\n};\n\n//-- Checks if url has a .epub or .zip extension, or is ArrayBuffer (of zip/epub)\nBook.prototype.isArchived = function(bookUrl){\n  var uri;\n\n  if (bookUrl instanceof ArrayBuffer) {\n\t\treturn true;\n\t}\n\n  // Reuse parsed url or create a new uri object\n  if(typeof(bookUrl) === \"object\") {\n    uri = bookUrl;\n  } else {\n    uri = core.uri(bookUrl);\n  }\n\n\tif(uri.extension && (uri.extension == \"epub\" || uri.extension == \"zip\")){\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\nmodule.exports = Book;\n\n//-- Enable binding events to book\nRSVP.EventTarget.mixin(Book.prototype);\n\n//-- Handle RSVP Errors\nRSVP.on('error', function(event) {\n  console.error(event);\n});\n\nRSVP.configure('instrument', true); //-- true | will logging out all RSVP rejections\n// RSVP.on('created', listener);\n// RSVP.on('chained', listener);\n// RSVP.on('fulfilled', listener);\nRSVP.on('rejected', function(event){\n  console.error(event.detail.message, event.detail.stack);\n});\n","var RSVP = require('rsvp');\nvar core = require('./core');\nvar Rendition = require('./rendition');\nvar View = require('./view');\n\nfunction Continuous(book, options) {\n\n\tRendition.apply(this, arguments); // call super constructor.\n\n\tthis.settings = core.extend(this.settings || {}, {\n\t\tinfinite: true,\n\t\toverflow: \"auto\",\n\t\taxis: \"vertical\",\n\t\toffset: 500,\n\t\toffsetDelta: 250\n\t});\n\n\tcore.extend(this.settings, options);\n\n\tif(this.settings.hidden) {\n\t\tthis.wrapper = this.wrap(this.container);\n\t}\n\n\n};\n\n// subclass extends superclass\nContinuous.prototype = Object.create(Rendition.prototype);\nContinuous.prototype.constructor = Continuous;\n\nContinuous.prototype.attachListeners = function(){\n\n\t// Listen to window for resize event if width or height is set to a percent\n\tif(!core.isNumber(this.settings.width) ||\n\t\t !core.isNumber(this.settings.height) ) {\n\t\twindow.addEventListener(\"resize\", this.onResized.bind(this), false);\n\t}\n\n\n\tif(this.settings.infinite) {\n\t\tthis.start();\n\t}\n\n\n};\n\nContinuous.prototype.parseTarget = function(target){\n\tif(this.epubcfi.isCfiString(target)) {\n    cfi = this.epubcfi.parse(target);\n    spinePos = cfi.spinePos;\n    section = this.book.spine.get(spinePos);\n  } else {\n    section = this.book.spine.get(target);\n  }\n};\n\nContinuous.prototype.moveTo = function(offset){\n  // var bounds = this.bounds();\n  // var dist = Math.floor(offset.top / bounds.height) * bounds.height;\n  return this.check(\n\t\toffset.left+this.settings.offset,\n\t\toffset.top+this.settings.offset)\n\t\t.then(function(){\n\n\t    if(this.settings.axis === \"vertical\") {\n\t      this.scrollBy(0, offset.top);\n\t    } else {\n\t      this.scrollBy(offset.left, 0);\n\t    }\n\n\t  }.bind(this));\n};\n\nContinuous.prototype.afterDisplayed = function(currView){\n\tvar next = currView.section.next();\n\tvar prev = currView.section.prev();\n\tvar index = this.views.indexOf(currView);\n\tvar prevView, nextView;\n\n\tif(index + 1 === this.views.length && next) {\n\t\tnextView = new View(next, this.viewSettings);\n\t\tthis.q.enqueue(this.append, nextView);\n\t}\n\n\tif(index === 0 && prev) {\n\t\tprevView = new View(prev, this.viewSettings);\n\t\tthis.q.enqueue(this.prepend, prevView);\n\t}\n\n\t// this.removeShownListeners(currView);\n\t// currView.onShown = this.afterDisplayed.bind(this);\n\tthis.trigger(\"added\", currView.section);\n\n};\n\n\n// Remove Previous Listeners if present\nContinuous.prototype.removeShownListeners = function(view){\n\n\t// view.off(\"shown\", this.afterDisplayed);\n\t// view.off(\"shown\", this.afterDisplayedAbove);\n\tview.onDisplayed = function(){};\n\n};\n\nContinuous.prototype.append = function(view){\n\n\t// view.on(\"shown\", this.afterDisplayed.bind(this));\n\tview.onDisplayed = this.afterDisplayed.bind(this);\n\n\tthis.views.append(view);\n\n  //this.q.enqueue(this.check);\n  return this.check();\n};\n\nContinuous.prototype.prepend = function(view){\n\t// view.on(\"shown\", this.afterDisplayedAbove.bind(this));\n\tview.onDisplayed = this.afterDisplayed.bind(this);\n\n\tview.on(\"resized\", this.counter.bind(this));\n\n\tthis.views.prepend(view);\n\n  // this.q.enqueue(this.check);\n  return this.check();\n};\n\nContinuous.prototype.counter = function(bounds){\n\n\tif(this.settings.axis === \"vertical\") {\n\t\tthis.scrollBy(0, bounds.heightDelta, true);\n\t} else {\n\t\tthis.scrollBy(bounds.widthDelta, 0, true);\n\t}\n\n};\n\nContinuous.prototype.check = function(_offset){\n\tvar checking = new RSVP.defer();\n\tvar container = this.bounds();\n  var promises = [];\n  var offset = _offset || this.settings.offset;\n\n\tthis.views.each(function(view){\n\t\tvar visible = this.isVisible(view, offset, offset, container);\n\n\t\tif(visible) {\n\n\t\t\tif(!view.displayed && !view.rendering) {\n          // console.log(\"render\",view.section.index)\n\t\t\t\t\tpromises.push(this.render(view));\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif(view.displayed) {\n        // console.log(\"destroy\", view.section.index)\n        this.q.enqueue(view.destroy.bind(view));\n        // view.destroy();\n        // this.q.enqueue(this.trim);\n        clearTimeout(this.trimTimeout);\n        this.trimTimeout = setTimeout(function(){\n          this.q.enqueue(this.trim);\n        }.bind(this), 250);\n\t\t\t}\n\n\t\t}\n\n\t}.bind(this));\n\n\n  if(promises.length){\n\n    return RSVP.all(promises)\n      .then(function(posts) {\n        // Check to see if anything new is on screen after rendering\n        this.q.enqueue(this.check);\n\n      }.bind(this));\n\n  } else {\n    checking.resolve();\n\n    return checking.promise;\n  }\n\n};\n\nContinuous.prototype.trim = function(){\n  var task = new RSVP.defer();\n  var displayed = this.views.displayed();\n  var first = displayed[0];\n  var last = displayed[displayed.length-1];\n  var firstIndex = this.views.indexOf(first);\n  var lastIndex = this.views.indexOf(last);\n  var above = this.views.slice(0, firstIndex);\n  var below = this.views.slice(lastIndex+1);\n\n  // Erase all but last above\n  for (var i = 0; i < above.length-1; i++) {\n    this.erase(above[i], above);\n  }\n\n  // Erase all except first below\n  for (var j = 1; j < below.length; j++) {\n    this.erase(below[j]);\n  }\n\n  task.resolve();\n  return task.promise;\n};\n\nContinuous.prototype.erase = function(view, above){ //Trim\n\n\tvar prevTop;\n\tvar prevLeft;\n\n\tif(this.settings.height) {\n  \tprevTop = this.container.scrollTop;\n\t\tprevLeft = this.container.scrollLeft;\n  } else {\n  \tprevTop = window.scrollY;\n\t\tprevLeft = window.scrollX;\n  }\n\n\tvar bounds = view.bounds();\n\n\tthis.views.remove(view);\n\n\tif(above) {\n\n\t\tif(this.settings.axis === \"vertical\") {\n\t\t\tthis.scrollTo(0, prevTop - bounds.height, true);\n\t\t} else {\n\t\t\tthis.scrollTo(prevLeft - bounds.width, 0, true);\n\t\t}\n\t}\n\n};\n\nContinuous.prototype.start = function() {\n  var scroller;\n\n  this.tick = core.requestAnimationFrame;\n\n  if(this.settings.height) {\n  \tthis.prevScrollTop = this.container.scrollTop;\n  \tthis.prevScrollLeft = this.container.scrollLeft;\n  } else {\n  \tthis.prevScrollTop = window.scrollY;\n\t\tthis.prevScrollLeft = window.scrollX;\n  }\n\n  this.scrollDeltaVert = 0;\n  this.scrollDeltaHorz = 0;\n\n  if(this.settings.height) {\n  \tscroller = this.container;\n  } else {\n  \tscroller = window;\n  }\n\n  window.addEventListener(\"scroll\", function(e){\n    if(!this.ignore) {\n      this.scrolled = true;\n    } else {\n      this.ignore = false;\n    }\n  }.bind(this));\n\n  window.addEventListener('unload', function(e){\n    this.ignore = true;\n    this.destroy();\n  }.bind(this));\n\n  this.tick.call(window, this.onScroll.bind(this));\n\n  this.scrolled = false;\n\n};\n\nContinuous.prototype.onScroll = function(){\n\n  if(this.scrolled) {\n\n    if(this.settings.height) {\n\t  \tscrollTop = this.container.scrollTop;\n\t  \tscrollLeft = this.container.scrollLeft;\n\t  } else {\n\t  \tscrollTop = window.scrollY;\n\t\t\tscrollLeft = window.scrollX;\n\t  }\n\n    if(!this.ignore) {\n\n\t    if((this.scrollDeltaVert === 0 &&\n\t    \t this.scrollDeltaHorz === 0) ||\n\t    \t this.scrollDeltaVert > this.settings.offsetDelta ||\n\t    \t this.scrollDeltaHorz > this.settings.offsetDelta) {\n\n\t\t\t\tthis.q.enqueue(this.check);\n\n\t\t\t\tthis.scrollDeltaVert = 0;\n\t    \tthis.scrollDeltaHorz = 0;\n\n\t\t\t\tthis.trigger(\"scroll\", {\n\t\t      top: scrollTop,\n\t\t      left: scrollLeft\n\t\t    });\n\n\t\t\t}\n\n\t\t} else {\n\t    this.ignore = false;\n\t\t}\n\n    this.scrollDeltaVert += Math.abs(scrollTop-this.prevScrollTop);\n    this.scrollDeltaHorz += Math.abs(scrollLeft-this.prevScrollLeft);\n\n\t\tthis.prevScrollTop = scrollTop;\n\t\tthis.prevScrollLeft = scrollLeft;\n\n  \tclearTimeout(this.scrollTimeout);\n\t\tthis.scrollTimeout = setTimeout(function(){\n\t\t\tthis.scrollDeltaVert = 0;\n\t    this.scrollDeltaHorz = 0;\n\t\t}.bind(this), 150);\n\n\n    this.scrolled = false;\n  }\n\n  this.tick.call(window, this.onScroll.bind(this));\n\n};\n\n\n Continuous.prototype.resizeView = function(view) {\n\n\tif(this.settings.axis === \"horizontal\") {\n\t\tview.lock(\"height\", this.stage.width, this.stage.height);\n\t} else {\n\t\tview.lock(\"width\", this.stage.width, this.stage.height);\n\t}\n\n};\n\nContinuous.prototype.currentLocation = function(){\n  var visible = this.visible();\n  var startPage, endPage;\n\n  var container = this.container.getBoundingClientRect();\n\n  if(visible.length === 1) {\n    return this.map.page(visible[0]);\n  }\n\n  if(visible.length > 1) {\n\n    startPage = this.map.page(visible[0]);\n    endPage = this.map.page(visible[visible.length-1]);\n\n    return {\n      start: startPage.start,\n      end: endPage.end\n    };\n  }\n\n};\n\n/*\nContinuous.prototype.current = function(what){\n  var view, top;\n  var container = this.container.getBoundingClientRect();\n  var length = this.views.length - 1;\n\n  if(this.settings.axis === \"horizontal\") {\n\n    for (var i = length; i >= 0; i--) {\n      view = this.views[i];\n      left = view.position().left;\n\n      if(left < container.right) {\n\n        if(this._current == view) {\n          break;\n        }\n\n        this._current = view;\n        break;\n      }\n    }\n\n  } else {\n\n    for (var i = length; i >= 0; i--) {\n      view = this.views[i];\n      top = view.bounds().top;\n      if(top < container.bottom) {\n\n        if(this._current == view) {\n          break;\n        }\n\n        this._current = view;\n\n        break;\n      }\n    }\n\n  }\n\n  return this._current;\n};\n*/\n\nmodule.exports = Continuous;\n","var RSVP = require('rsvp');\n\nvar requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n\n//-- Parse the different parts of a url, returning a object\nfunction uri(url){\n  var uri = {\n        protocol : '',\n        host : '',\n        path : '',\n        origin : '',\n        directory : '',\n        base : '',\n        filename : '',\n        extension : '',\n        fragment : '',\n        href : url\n      },\n      doubleSlash = url.indexOf('://'),\n      search = url.indexOf('?'),\n      fragment = url.indexOf(\"#\"),\n      withoutProtocol,\n      dot,\n      firstSlash;\n\n  if(fragment != -1) {\n    uri.fragment = url.slice(fragment + 1);\n    url = url.slice(0, fragment);\n  }\n\n  if(search != -1) {\n    uri.search = url.slice(search + 1);\n    url = url.slice(0, search);\n    href = url;\n  }\n\n  if(doubleSlash != -1) {\n    uri.protocol = url.slice(0, doubleSlash);\n    withoutProtocol = url.slice(doubleSlash+3);\n    firstSlash = withoutProtocol.indexOf('/');\n\n    if(firstSlash === -1) {\n      uri.host = uri.path;\n      uri.path = \"\";\n    } else {\n      uri.host = withoutProtocol.slice(0, firstSlash);\n      uri.path = withoutProtocol.slice(firstSlash);\n    }\n\n\n    uri.origin = uri.protocol + \"://\" + uri.host;\n\n    uri.directory = folder(uri.path);\n\n    uri.base = uri.origin + uri.directory;\n    // return origin;\n  } else {\n    uri.path = url;\n    uri.directory = folder(url);\n    uri.base = uri.directory;\n  }\n\n  //-- Filename\n  uri.filename = url.replace(uri.base, '');\n  dot = uri.filename.lastIndexOf('.');\n  if(dot != -1) {\n    uri.extension = uri.filename.slice(dot+1);\n  }\n  return uri;\n};\n\n//-- Parse out the folder, will return everything before the last slash\nfunction folder(url){\n\n  var lastSlash = url.lastIndexOf('/');\n\n  if(lastSlash == -1) var folder = '';\n\n  folder = url.slice(0, lastSlash + 1);\n\n  return folder;\n\n};\n\nfunction isElement(obj) {\n    return !!(obj && obj.nodeType == 1);\n};\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\nfunction uuid() {\n  var d = new Date().getTime();\n  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      var r = (d + Math.random()*16)%16 | 0;\n      d = Math.floor(d/16);\n      return (c=='x' ? r : (r&0x7|0x8)).toString(16);\n  });\n  return uuid;\n};\n\n// From Lodash\nfunction values(object) {\n  var index = -1,\n      props = Object.keys(object),\n      length = props.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = object[props[index]];\n  }\n  return result;\n};\n\nfunction resolveUrl(base, path) {\n  var url = [],\n    segments = [],\n    baseUri = uri(base),\n    pathUri = uri(path),\n    baseDirectory = baseUri.directory,\n    pathDirectory = pathUri.directory,\n    directories = [],\n    // folders = base.split(\"/\"),\n    paths;\n\n  // if(uri.host) {\n  //   return path;\n  // }\n\n  if(baseDirectory[0] === \"/\") {\n    baseDirectory = baseDirectory.substring(1);\n  }\n\n  if(pathDirectory[pathDirectory.length-1] === \"/\") {\n    baseDirectory = baseDirectory.substring(0, baseDirectory.length-1);\n  }\n\n  if(pathDirectory[0] === \"/\") {\n    pathDirectory = pathDirectory.substring(1);\n  }\n\n  if(pathDirectory[pathDirectory.length-1] === \"/\") {\n    pathDirectory = pathDirectory.substring(0, pathDirectory.length-1);\n  }\n\n  if(baseDirectory) {\n    directories = baseDirectory.split(\"/\");\n  }\n\n  paths = pathDirectory.split(\"/\");\n\n  paths.reverse().forEach(function(part, index){\n    if(part === \"..\"){\n      directories.pop();\n    } else if(part === directories[directories.length-1]) {\n      directories.pop();\n      segments.unshift(part);\n    } else {\n      segments.unshift(part);\n    }\n  });\n\n  url = [baseUri.origin];\n\n  if(directories.length) {\n    url = url.concat(directories);\n  }\n\n  if(segments) {\n    url = url.concat(segments);\n  }\n\n  url = url.concat(pathUri.filename);\n\n  return url.join(\"/\");\n};\n\nfunction documentHeight() {\n  return Math.max(\n      document.documentElement.clientHeight,\n      document.body.scrollHeight,\n      document.documentElement.scrollHeight,\n      document.body.offsetHeight,\n      document.documentElement.offsetHeight\n  );\n};\n\nfunction isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\nfunction prefixed(unprefixed) {\n  var vendors = [\"Webkit\", \"Moz\", \"O\", \"ms\" ],\n    prefixes = ['-Webkit-', '-moz-', '-o-', '-ms-'],\n    upper = unprefixed[0].toUpperCase() + unprefixed.slice(1),\n    length = vendors.length;\n\n  if (typeof(document.body.style[unprefixed]) != 'undefined') {\n    return unprefixed;\n  }\n\n  for ( var i=0; i < length; i++ ) {\n    if (typeof(document.body.style[vendors[i] + upper]) != 'undefined') {\n      return vendors[i] + upper;\n    }\n  }\n\n  return unprefixed;\n};\n\nfunction defaults(obj) {\n  for (var i = 1, length = arguments.length; i < length; i++) {\n    var source = arguments[i];\n    for (var prop in source) {\n      if (obj[prop] === void 0) obj[prop] = source[prop];\n    }\n  }\n  return obj;\n};\n\nfunction extend(target) {\n    var sources = [].slice.call(arguments, 1);\n    sources.forEach(function (source) {\n      if(!source) return;\n      Object.getOwnPropertyNames(source).forEach(function(propName) {\n        Object.defineProperty(target, propName, Object.getOwnPropertyDescriptor(source, propName));\n      });\n    });\n    return target;\n};\n\n// Fast quicksort insert for sorted array -- based on:\n// http://stackoverflow.com/questions/1344500/efficient-way-to-insert-a-number-into-a-sorted-array-of-numbers\nfunction insert(item, array, compareFunction) {\n  var location = locationOf(item, array, compareFunction);\n  array.splice(location, 0, item);\n\n  return location;\n};\n// Returns where something would fit in\nfunction locationOf(item, array, compareFunction, _start, _end) {\n  var start = _start || 0;\n  var end = _end || array.length;\n  var pivot = parseInt(start + (end - start) / 2);\n  var compared;\n  if(!compareFunction){\n    compareFunction = function(a, b) {\n      if(a > b) return 1;\n      if(a < b) return -1;\n      if(a = b) return 0;\n    };\n  }\n  if(end-start <= 0) {\n    return pivot;\n  }\n\n  compared = compareFunction(array[pivot], item);\n  if(end-start === 1) {\n    return compared > 0 ? pivot : pivot + 1;\n  }\n\n  if(compared === 0) {\n    return pivot;\n  }\n  if(compared === -1) {\n    return locationOf(item, array, compareFunction, pivot, end);\n  } else{\n    return locationOf(item, array, compareFunction, start, pivot);\n  }\n};\n// Returns -1 of mpt found\nfunction indexOfSorted(item, array, compareFunction, _start, _end) {\n  var start = _start || 0;\n  var end = _end || array.length;\n  var pivot = parseInt(start + (end - start) / 2);\n  var compared;\n  if(!compareFunction){\n    compareFunction = function(a, b) {\n      if(a > b) return 1;\n      if(a < b) return -1;\n      if(a = b) return 0;\n    };\n  }\n  if(end-start <= 0) {\n    return -1; // Not found\n  }\n\n  compared = compareFunction(array[pivot], item);\n  if(end-start === 1) {\n    return compared === 0 ? pivot : -1;\n  }\n  if(compared === 0) {\n    return pivot; // Found\n  }\n  if(compared === -1) {\n    return indexOfSorted(item, array, compareFunction, pivot, end);\n  } else{\n    return indexOfSorted(item, array, compareFunction, start, pivot);\n  }\n};\n\nfunction bounds(el) {\n\n  var style = window.getComputedStyle(el);\n  var widthProps = [\"width\", \"paddingRight\", \"paddingLeft\", \"marginRight\", \"marginLeft\", \"borderRightWidth\", \"borderLeftWidth\"];\n  var heightProps = [\"height\", \"paddingTop\", \"paddingBottom\", \"marginTop\", \"marginBottom\", \"borderTopWidth\", \"borderBottomWidth\"];\n\n  var width = 0;\n  var height = 0;\n\n  widthProps.forEach(function(prop){\n    width += parseFloat(style[prop]) || 0;\n  });\n\n  heightProps.forEach(function(prop){\n    height += parseFloat(style[prop]) || 0;\n  });\n\n  return {\n    height: height,\n    width: width\n  };\n\n};\n\nfunction borders(el) {\n\n  var style = window.getComputedStyle(el);\n  var widthProps = [\"paddingRight\", \"paddingLeft\", \"marginRight\", \"marginLeft\", \"borderRightWidth\", \"borderLeftWidth\"];\n  var heightProps = [\"paddingTop\", \"paddingBottom\", \"marginTop\", \"marginBottom\", \"borderTopWidth\", \"borderBottomWidth\"];\n\n  var width = 0;\n  var height = 0;\n\n  widthProps.forEach(function(prop){\n    width += parseFloat(style[prop]) || 0;\n  });\n\n  heightProps.forEach(function(prop){\n    height += parseFloat(style[prop]) || 0;\n  });\n\n  return {\n    height: height,\n    width: width\n  };\n\n};\n\nfunction windowBounds() {\n\n  var width = window.innerWidth;\n  var height = window.innerHeight;\n\n  return {\n    top: 0,\n    left: 0,\n    right: width,\n    bottom: height,\n    width: width,\n    height: height\n  };\n\n};\n\n//https://stackoverflow.com/questions/13482352/xquery-looking-for-text-with-single-quote/13483496#13483496\nfunction cleanStringForXpath(str)  {\n    var parts = str.match(/[^'\"]+|['\"]/g);\n    parts = parts.map(function(part){\n        if (part === \"'\")  {\n            return '\\\"\\'\\\"'; // output \"'\"\n        }\n\n        if (part === '\"') {\n            return \"\\'\\\"\\'\"; // output '\"'\n        }\n        return \"\\'\" + part + \"\\'\";\n    });\n    return \"concat(\\'\\',\" + parts.join(\",\") + \")\";\n};\n\nfunction indexOfTextNode(textNode){\n  var parent = textNode.parentNode;\n  var children = parent.childNodes;\n  var sib;\n  var index = -1;\n  for (var i = 0; i < children.length; i++) {\n    sib = children[i];\n    if(sib.nodeType === Node.TEXT_NODE){\n      index++;\n    }\n    if(sib == textNode) break;\n  }\n\n  return index;\n};\n\nfunction isXml(ext) {\n  return ['xml', 'opf', 'ncx'].indexOf(ext) > -1;\n}\n\nmodule.exports = {\n  'uri': uri,\n  'folder': folder,\n  'isElement': isElement,\n  'uuid': uuid,\n  'values': values,\n  'resolveUrl': resolveUrl,\n  'indexOfSorted': indexOfSorted,\n  'documentHeight': documentHeight,\n  'isNumber': isNumber,\n  'prefixed': prefixed,\n  'defaults': defaults,\n  'extend': extend,\n  'insert': insert,\n  'locationOf': locationOf,\n  'indexOfSorted': indexOfSorted,\n  'requestAnimationFrame': requestAnimationFrame,\n  'bounds': bounds,\n  'borders': borders,\n  'windowBounds': windowBounds,\n  'cleanStringForXpath': cleanStringForXpath,\n  'indexOfTextNode': indexOfTextNode,\n  'isXml': isXml\n};\n","var core = require('./core');\n\nfunction EpubCFI(cfiStr){\n  if(cfiStr) return this.parse(cfiStr);\n};\n\nEpubCFI.prototype.generateChapterComponent = function(_spineNodeIndex, _pos, id) {\n  var pos = parseInt(_pos),\n    spineNodeIndex = _spineNodeIndex + 1,\n    cfi = '/'+spineNodeIndex+'/';\n\n  cfi += (pos + 1) * 2;\n\n  if(id) cfi += \"[\" + id + \"]\";\n\n  //cfi += \"!\";\n\n  return cfi;\n};\n\nEpubCFI.prototype.generatePathComponent = function(steps) {\n  var parts = [];\n\n  steps.forEach(function(part){\n    var segment = '';\n    segment += (part.index + 1) * 2;\n\n    if(part.id) {\n      segment += \"[\" + part.id + \"]\";\n    }\n\n    parts.push(segment);\n  });\n\n  return parts.join('/');\n};\n\nEpubCFI.prototype.generateCfiFromElement = function(element, chapter) {\n  var steps = this.pathTo(element);\n  var path = this.generatePathComponent(steps);\n  if(!path.length) {\n    // Start of Chapter\n    return \"epubcfi(\" + chapter + \"!/4/)\";\n  } else {\n    // First Text Node\n    return \"epubcfi(\" + chapter + \"!\" + path + \"/1:0)\";\n  }\n};\n\nEpubCFI.prototype.pathTo = function(node) {\n  var stack = [],\n      children;\n\n  while(node && node.parentNode !== null && node.parentNode.nodeType != 9) {\n    children = node.parentNode.children;\n\n    stack.unshift({\n      'id' : node.id,\n      // 'classList' : node.classList,\n      'tagName' : node.tagName,\n      'index' : children ? Array.prototype.indexOf.call(children, node) : 0\n    });\n\n    node = node.parentNode;\n  }\n\n  return stack;\n};\n\nEpubCFI.prototype.getChapterComponent = function(cfiStr) {\n\n  var splitStr = cfiStr.split(\"!\");\n\n  return splitStr[0];\n};\n\nEpubCFI.prototype.getPathComponent = function(cfiStr) {\n\n  var splitStr = cfiStr.split(\"!\");\n  var pathComponent = splitStr[1] ? splitStr[1].split(\":\") : '';\n\n  return pathComponent[0];\n};\n\nEpubCFI.prototype.getCharecterOffsetComponent = function(cfiStr) {\n  var splitStr = cfiStr.split(\":\");\n  return splitStr[1] || '';\n};\n\n\nEpubCFI.prototype.parse = function(cfiStr) {\n  var cfi = {},\n    chapSegment,\n    chapterComponent,\n    pathComponent,\n    charecterOffsetComponent,\n    assertion,\n    chapId,\n    path,\n    end,\n    endInt,\n    text,\n    parseStep = function(part){\n      var type, index, has_brackets, id;\n\n      type = \"element\";\n      index = parseInt(part) / 2 - 1;\n      has_brackets = part.match(/\\[(.*)\\]/);\n      if(has_brackets && has_brackets[1]){\n        id = has_brackets[1];\n      }\n\n      return {\n        \"type\" : type,\n        'index' : index,\n        'id' : id || false\n      };\n    };\n\n  if(typeof cfiStr !== \"string\") {\n    return {spinePos: -1};\n  }\n\n  cfi.str = cfiStr;\n\n  if(cfiStr.indexOf(\"epubcfi(\") === 0 && cfiStr[cfiStr.length-1] === \")\") {\n    // Remove intial epubcfi( and ending )\n    cfiStr = cfiStr.slice(8, cfiStr.length-1);\n  }\n\n  chapterComponent = this.getChapterComponent(cfiStr);\n  pathComponent = this.getPathComponent(cfiStr) || '';\n  charecterOffsetComponent = this.getCharecterOffsetComponent(cfiStr);\n  // Make sure this is a valid cfi or return\n  if(!chapterComponent) {\n    return {spinePos: -1};\n  }\n\n  // Chapter segment is always the second one\n  chapSegment = chapterComponent.split(\"/\")[2] || '';\n  if(!chapSegment) return {spinePos:-1};\n\n  cfi.spinePos = (parseInt(chapSegment) / 2 - 1 ) || 0;\n\n  chapId = chapSegment.match(/\\[(.*)\\]/);\n\n  cfi.spineId = chapId ? chapId[1] : false;\n\n  if(pathComponent.indexOf(',') != -1) {\n    // Handle ranges -- not supported yet\n    console.warn(\"CFI Ranges are not supported\");\n  }\n\n  path = pathComponent.split('/');\n  end = path.pop();\n\n  cfi.steps = [];\n\n  path.forEach(function(part){\n    var step;\n\n    if(part) {\n      step = parseStep(part);\n      cfi.steps.push(step);\n    }\n  });\n\n  //-- Check if END is a text node or element\n  endInt = parseInt(end);\n  if(!isNaN(endInt)) {\n\n    if(endInt % 2 === 0) { // Even = is an element\n      cfi.steps.push(parseStep(end));\n    } else {\n      cfi.steps.push({\n        \"type\" : \"text\",\n        'index' : (endInt - 1 ) / 2\n      });\n    }\n\n  }\n\n  assertion = charecterOffsetComponent.match(/\\[(.*)\\]/);\n  if(assertion && assertion[1]){\n    cfi.characterOffset = parseInt(charecterOffsetComponent.split('[')[0]);\n    // We arent handling these assertions yet\n    cfi.textLocationAssertion = assertion[1];\n  } else {\n    cfi.characterOffset = parseInt(charecterOffsetComponent);\n  }\n\n  return cfi;\n};\n\nEpubCFI.prototype.addMarker = function(cfi, _doc, _marker) {\n  var doc = _doc || document;\n  var marker = _marker || this.createMarker(doc);\n  var parent;\n  var lastStep;\n  var text;\n  var split;\n\n  if(typeof cfi === 'string') {\n    cfi = this.parse(cfi);\n  }\n  // Get the terminal step\n  lastStep = cfi.steps[cfi.steps.length-1];\n\n  // check spinePos\n  if(cfi.spinePos === -1) {\n    // Not a valid CFI\n    return false;\n  }\n\n  // Find the CFI elements parent\n  parent = this.findParent(cfi, doc);\n\n  if(!parent) {\n    // CFI didn't return an element\n    // Maybe it isnt in the current chapter?\n    return false;\n  }\n\n  if(lastStep && lastStep.type === \"text\") {\n    text = parent.childNodes[lastStep.index];\n    if(cfi.characterOffset){\n      split = text.splitText(cfi.characterOffset);\n      marker.classList.add(\"EPUBJS-CFI-SPLIT\");\n      parent.insertBefore(marker, split);\n    } else {\n      parent.insertBefore(marker, text);\n    }\n  } else {\n    parent.insertBefore(marker, parent.firstChild);\n  }\n\n  return marker;\n};\n\nEpubCFI.prototype.createMarker = function(_doc) {\n  var doc = _doc || document;\n  var element = doc.createElement('span');\n  element.id = \"EPUBJS-CFI-MARKER:\"+ core.uuid();\n  element.classList.add(\"EPUBJS-CFI-MARKER\");\n\n  return element;\n};\n\nEpubCFI.prototype.removeMarker = function(marker, _doc) {\n  var doc = _doc || document;\n  // var id = marker.id;\n\n  // Cleanup textnodes if they were split\n  if(marker.classList.contains(\"EPUBJS-CFI-SPLIT\")){\n    nextSib = marker.nextSibling;\n    prevSib = marker.previousSibling;\n    if(nextSib &&\n        prevSib &&\n        nextSib.nodeType === 3 &&\n        prevSib.nodeType === 3){\n\n      prevSib.textContent += nextSib.textContent;\n      marker.parentNode.removeChild(nextSib);\n    }\n    marker.parentNode.removeChild(marker);\n  } else if(marker.classList.contains(\"EPUBJS-CFI-MARKER\")) {\n    // Remove only elements added as markers\n    marker.parentNode.removeChild(marker);\n  }\n\n};\n\nEpubCFI.prototype.findParent = function(cfi, _doc) {\n  var doc = _doc || document,\n      element = doc.getElementsByTagName('html')[0],\n      children = Array.prototype.slice.call(element.children),\n      num, index, part, sections,\n      text, textBegin, textEnd;\n\n  if(typeof cfi === 'string') {\n    cfi = this.parse(cfi);\n  }\n\n  sections = cfi.steps.slice(0); // Clone steps array\n  if(!sections.length) {\n    return doc.getElementsByTagName('body')[0];\n  }\n\n  while(sections && sections.length > 0) {\n    part = sections.shift();\n    // Find textNodes Parent\n    if(part.type === \"text\") {\n      text = element.childNodes[part.index];\n      element = text.parentNode || element;\n    // Find element by id if present\n    } else if(part.id){\n      element = doc.getElementById(part.id);\n    // Find element in parent\n    }else{\n      element = children[part.index];\n    }\n    // Element can't be found\n    if(typeof element === \"undefined\") {\n      console.error(\"No Element For\", part, cfi.str);\n      return false;\n    }\n    // Get current element children and continue through steps\n    children = Array.prototype.slice.call(element.children);\n  }\n\n  return element;\n};\n\nEpubCFI.prototype.compare = function(cfiOne, cfiTwo) {\n  if(typeof cfiOne === 'string') {\n    cfiOne = new EpubCFI(cfiOne);\n  }\n  if(typeof cfiTwo === 'string') {\n    cfiTwo = new EpubCFI(cfiTwo);\n  }\n  // Compare Spine Positions\n  if(cfiOne.spinePos > cfiTwo.spinePos) {\n    return 1;\n  }\n  if(cfiOne.spinePos < cfiTwo.spinePos) {\n    return -1;\n  }\n\n\n  // Compare Each Step in the First item\n  for (var i = 0; i < cfiOne.steps.length; i++) {\n    if(!cfiTwo.steps[i]) {\n      return 1;\n    }\n    if(cfiOne.steps[i].index > cfiTwo.steps[i].index) {\n      return 1;\n    }\n    if(cfiOne.steps[i].index < cfiTwo.steps[i].index) {\n      return -1;\n    }\n    // Otherwise continue checking\n  }\n\n  // All steps in First present in Second\n  if(cfiOne.steps.length < cfiTwo.steps.length) {\n    return -1;\n  }\n\n  // Compare the charecter offset of the text node\n  if(cfiOne.characterOffset > cfiTwo.characterOffset) {\n    return 1;\n  }\n  if(cfiOne.characterOffset < cfiTwo.characterOffset) {\n    return -1;\n  }\n\n  // CFI's are equal\n  return 0;\n};\n\nEpubCFI.prototype.generateCfiFromHref = function(href, book) {\n  var uri = core.uri(href);\n  var path = uri.path;\n  var fragment = uri.fragment;\n  var spinePos = book.spineIndexByURL[path];\n  var loaded;\n  var deferred = new RSVP.defer();\n  var epubcfi = new EpubCFI();\n  var spineItem;\n\n  if(typeof spinePos !== \"undefined\"){\n    spineItem = book.spine[spinePos];\n    loaded = book.loadXml(spineItem.url);\n    loaded.then(function(doc){\n      var element = doc.getElementById(fragment);\n      var cfi;\n      cfi = epubcfi.generateCfiFromElement(element, spineItem.cfiBase);\n      deferred.resolve(cfi);\n    });\n  }\n\n  return deferred.promise;\n};\n\nEpubCFI.prototype.generateCfiFromTextNode = function(anchor, offset, base) {\n  var parent = anchor.parentNode;\n  var steps = this.pathTo(parent);\n  var path = this.generatePathComponent(steps);\n  var index = 1 + (2 * Array.prototype.indexOf.call(parent.childNodes, anchor));\n  return \"epubcfi(\" + base + \"!\" + path + \"/\"+index+\":\"+(offset || 0)+\")\";\n};\n\nEpubCFI.prototype.generateCfiFromRangeAnchor = function(range, base) {\n  var anchor = range.anchorNode;\n  var offset = range.anchorOffset;\n  return this.generateCfiFromTextNode(anchor, offset, base);\n};\n\nEpubCFI.prototype.generateCfiFromRange = function(range, base) {\n  var start, startElement, startSteps, startPath, startOffset, startIndex;\n  var end, endElement, endSteps, endPath, endOffset, endIndex;\n\n  start = range.startContainer;\n\n  if(start.nodeType === 3) { // text node\n    startElement = start.parentNode;\n    //startIndex = 1 + (2 * Array.prototype.indexOf.call(startElement.childNodes, start));\n    startIndex = 1 + (2 * core.indexOfTextNode(start));\n    startSteps = this.pathTo(startElement);\n  } else if(range.collapsed) {\n    return this.generateCfiFromElement(start, base); // single element\n  } else {\n    startSteps = this.pathTo(start);\n  }\n\n  startPath = this.generatePathComponent(startSteps);\n  startOffset = range.startOffset;\n\n  if(!range.collapsed) {\n    end = range.endContainer;\n\n    if(end.nodeType === 3) { // text node\n      endElement = end.parentNode;\n      // endIndex = 1 + (2 * Array.prototype.indexOf.call(endElement.childNodes, end));\n      endIndex = 1 + (2 * core.indexOfTextNode(end));\n\n      endSteps = this.pathTo(endElement);\n    } else {\n      endSteps = this.pathTo(end);\n    }\n\n    endPath = this.generatePathComponent(endSteps);\n    endOffset = range.endOffset;\n\n    // Remove steps present in startPath\n    endPath = endPath.replace(startPath, '');\n\n    if (endPath.length) {\n      endPath = endPath + \"/\";\n    }\n\n    return \"epubcfi(\" + base + \"!\" + startPath + \"/\" + startIndex + \":\" + startOffset + \",\" + endPath + endIndex + \":\" + endOffset + \")\";\n\n  } else {\n    return \"epubcfi(\" + base + \"!\" + startPath + \"/\"+ startIndex +\":\"+ startOffset +\")\";\n  }\n};\n\nEpubCFI.prototype.generateXpathFromSteps = function(steps) {\n  var xpath = [\".\", \"*\"];\n\n  steps.forEach(function(step){\n    var position = step.index + 1;\n\n    if(step.id){\n      xpath.push(\"*[position()=\" + position + \" and @id='\" + step.id + \"']\");\n    } else if(step.type === \"text\") {\n      xpath.push(\"text()[\" + position + \"]\");\n    } else {\n      xpath.push(\"*[\" + position + \"]\");\n    }\n  });\n\n  return xpath.join(\"/\");\n};\n\nEpubCFI.prototype.generateQueryFromSteps = function(steps) {\n  var query = [\"html\"];\n\n  steps.forEach(function(step){\n    var position = step.index + 1;\n\n    if(step.id){\n      query.push(\"#\" + step.id);\n    } else if(step.type === \"text\") {\n      // unsupported in querySelector\n      // query.push(\"text()[\" + position + \"]\");\n    } else {\n      query.push(\"*:nth-child(\" + position + \")\");\n    }\n  });\n\n  return query.join(\">\");\n};\n\n\nEpubCFI.prototype.generateRangeFromCfi = function(cfi, _doc) {\n  var doc = _doc || document;\n  var range = doc.createRange();\n  var lastStep;\n  var xpath;\n  var startContainer;\n  var textLength;\n  var query;\n  var startContainerParent;\n\n  if(typeof cfi === 'string') {\n    cfi = this.parse(cfi);\n  }\n\n  // check spinePos\n  if(cfi.spinePos === -1) {\n    // Not a valid CFI\n    return false;\n  }\n\n  // Get the terminal step\n  lastStep = cfi.steps[cfi.steps.length-1];\n\n  if(typeof document.evaluate != 'undefined') {\n    xpath = this.generateXpathFromSteps(cfi.steps);\n    startContainer = doc.evaluate(xpath, doc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n  } else {\n      // Get the query string\n      query = this.generateQueryFromSteps(cfi.steps);\n      // Find the containing element\n      startContainerParent = doc.querySelector(query);\n      // Find the text node within that element\n      if(startContainerParent && lastStep.type == \"text\") {\n        startContainer = startContainerParent.childNodes[lastStep.index];\n      }\n  }\n\n  if(!startContainer) {\n    return null;\n  }\n\n  if(startContainer && cfi.characterOffset >= 0) {\n    textLength = startContainer.length;\n\n    if(cfi.characterOffset < textLength) {\n      range.setStart(startContainer, cfi.characterOffset);\n      range.setEnd(startContainer, textLength );\n    } else {\n      console.debug(\"offset greater than length:\", cfi.characterOffset, textLength);\n      range.setStart(startContainer, textLength - 1 );\n      range.setEnd(startContainer, textLength );\n    }\n  } else if(startContainer) {\n    range.selectNode(startContainer);\n  }\n  // doc.defaultView.getSelection().addRange(range);\n  return range;\n};\n\nEpubCFI.prototype.isCfiString = function(target) {\n  if(typeof target === \"string\" &&\n    target.indexOf(\"epubcfi(\") === 0) {\n      return true;\n  }\n\n  return false;\n};\n\nmodule.exports = EpubCFI;\n","var RSVP = require('rsvp');\n\n//-- Hooks allow for injecting functions that must all complete in order before finishing\n//   They will execute in parallel but all must finish before continuing\n//   Functions may return a promise if they are asycn.\n\n// this.content = new EPUBJS.Hook();\n// this.content.register(function(){});\n// this.content.trigger(args).then(function(){});\n\nfunction Hook(context){\n  this.context = context || this;\n  this.hooks = [];\n};\n\n// Adds a function to be run before a hook completes\nHook.prototype.register = function(func){\n  this.hooks.push(func);\n};\n\n// Triggers a hook to run all functions\nHook.prototype.trigger = function(){\n  var args = arguments;\n  var context = this.context;\n  var promises = [];\n\n  this.hooks.forEach(function(task, i) {\n    var executing = task.apply(context, args);\n\n    if(executing && typeof executing[\"then\"] === \"function\") {\n      // Task is a function that returns a promise\n      promises.push(executing);\n    }\n    // Otherwise Task resolves immediately, continue\n  });\n\n\n  return RSVP.all(promises);\n};\n\nmodule.exports = Hook;\n","var core = require('./core');\n\nfunction Reflowable(){\n\n};\n\nReflowable.prototype.calculate = function(_width, _height, _gap, _devisor){\n\n  var divisor = _devisor || 1;\n\n  //-- Check the width and create even width columns\n  var fullWidth = Math.floor(_width);\n  var width = (fullWidth % 2 === 0) ? fullWidth : fullWidth - 1;\n\n  var section = Math.floor(width / 8);\n  var gap = (_gap >= 0) ? _gap : ((section % 2 === 0) ? section : section - 1);\n\n  var colWidth;\n  var spreadWidth;\n  var delta;\n\n  //-- Double Page\n  if(divisor > 1) {\n    colWidth = Math.floor((width - gap) / divisor);\n  } else {\n    colWidth = width;\n  }\n\n  spreadWidth = colWidth * divisor;\n\n  delta = (colWidth + gap) * divisor;\n\n\n\n  this.columnAxis = core.prefixed('columnAxis');\n  this.columnGap = core.prefixed('columnGap');\n  this.columnWidth = core.prefixed('columnWidth');\n  this.columnFill = core.prefixed('columnFill');\n\n  this.width = width;\n  this.height = _height;\n  this.spread = spreadWidth;\n  this.delta = delta;\n\n  this.column = colWidth;\n  this.gap = gap;\n  this.divisor = divisor;\n\n};\n\nReflowable.prototype.format = function(view){\n\n  var $doc = view.document.documentElement;\n  var $body = view.document.body;//view.document.querySelector(\"body\");\n\n  $doc.style.overflow = \"hidden\";\n\n  // Must be set to the new calculated width or the columns will be off\n  // $body.style.width = this.width + \"px\";\n  $doc.style.width = this.width + \"px\";\n\n  //-- Adjust height\n  $body.style.height = this.height + \"px\";\n\n  //-- Add columns\n  $body.style[this.columnAxis] = \"horizontal\";\n  $body.style[this.columnFill] = \"auto\";\n  $body.style[this.columnGap] = this.gap+\"px\";\n  $body.style[this.columnWidth] = this.column+\"px\";\n\n  // Add extra padding for the gap between this and the next view\n  view.iframe.style.marginRight = this.gap+\"px\";\n};\n\nReflowable.prototype.count = function(view) {\n  var totalWidth = view.root().scrollWidth;\n  var spreads = Math.ceil(totalWidth / this.spread);\n\n  return {\n    spreads : spreads,\n    pages : spreads * this.divisor\n  };\n};\n\nfunction Fixed(_width, _height){\n\n};\n\nFixed.prototype.calculate = function(_width, _height){\n\n};\n\nFixed.prototype.format = function(view){\n  var width, height;\n\n  var $doc = view.document.documentElement;\n  var $viewport = documentElement.querySelector(\"[name=viewport\");\n\n  /**\n  * check for the viewport size\n  * <meta name=\"viewport\" content=\"width=1024,height=697\" />\n  */\n  if($viewport && $viewport.hasAttribute(\"content\")) {\n    content = $viewport.getAttribute(\"content\");\n    contents = content.split(',');\n    if(contents[0]){\n      width = contents[0].replace(\"width=\", '');\n    }\n    if(contents[1]){\n      height = contents[1].replace(\"height=\", '');\n    }\n  }\n\n  //-- Adjust width and height\n  // $doc.style.width =  width + \"px\" || \"auto\";\n  // $doc.style.height =  height + \"px\" || \"auto\";\n  view.resize(width, height);\n\n  //-- Scroll\n  $doc.style.overflow = \"auto\";\n\n};\n\nFixed.prototype.count = function(){\n  return {\n    spreads : 1,\n    pages : 1\n  };\n};\n\nfunction Scroll(){\n\n};\n\nScroll.prototype.calculate = function(_width, _height){\n  this.spread = _width;\n  this.column = _width;\n  this.gap = 0;\n};\n\nScroll.prototype.format = function(view){\n\n  var $doc = view.document.documentElement;\n\n  $doc.style.width = \"auto\";\n  $doc.style.height = \"auto\";\n\n};\n\nScroll.prototype.count = function(){\n  return {\n    spreads : 1,\n    pages : 1\n  };\n};\n\nmodule.exports = {\n  'Reflowable': Reflowable,\n  'Fixed': Fixed,\n  'Scroll': Scroll\n};\n","var core = require('./core');\nvar Queue = require('./queue');\nvar EpubCFI = require('./epubcfi');\nvar RSVP = require('rsvp');\n\nfunction Locations(spine, request) {\n  this.spine = spine;\n  this.request = request;\n\n  this.q = new Queue(this);\n  this.epubcfi = new EpubCFI();\n\n  this._locations = [];\n  this.total = 0;\n\n  this.break = 150;\n\n  this._current = 0;\n\n};\n\n// Load all of sections in the book\nLocations.prototype.generate = function(chars) {\n\n  if (chars) {\n    this.break = chars;\n  }\n\n  this.q.pause();\n\n  this.spine.each(function(section) {\n\n    this.q.enqueue(this.process, section);\n\n  }.bind(this));\n\n  return this.q.run().then(function() {\n    this.total = this._locations.length-1;\n\n    if (this._currentCfi) {\n      this.currentLocation = this._currentCfi;\n    }\n\n    return this._locations;\n    // console.log(this.precentage(this.book.rendition.location.start), this.precentage(this.book.rendition.location.end));\n  }.bind(this));\n\n};\n\nLocations.prototype.process = function(section) {\n\n  return section.load(this.request)\n    .then(function(contents) {\n\n      var range;\n      var doc = contents.ownerDocument;\n      var counter = 0;\n\n      this.sprint(contents, function(node) {\n        var len = node.length;\n        var dist;\n        var pos = 0;\n\n        // Start range\n        if (counter == 0) {\n          range = doc.createRange();\n          range.setStart(node, 0);\n        }\n\n        dist = this.break - counter;\n\n        // Node is smaller than a break\n        if(dist > len){\n          counter += len;\n          pos = len;\n        }\n\n        while (pos < len) {\n          counter = this.break;\n          pos += this.break;\n\n          // Gone over\n          if(pos >= len){\n            // Continue counter for next node\n            counter = len - (pos - this.break);\n\n          // At End\n          } else {\n            // End the previous range\n            range.setEnd(node, pos);\n            cfi = section.cfiFromRange(range);\n            this._locations.push(cfi);\n            counter = 0;\n\n            // Start new range\n            pos += 1;\n            range = doc.createRange();\n            range.setStart(node, pos);\n          }\n        }\n\n\n\n      }.bind(this));\n\n      // Close remaining\n      if (range) {\n        range.setEnd(prev, prev.length);\n        cfi = section.cfiFromRange(range);\n        this._locations.push(cfi)\n        counter = 0;\n      }\n\n    }.bind(this));\n\n};\n\nLocations.prototype.sprint = function(root, func) {\n\tvar treeWalker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null, false);\n\n\twhile ((node = treeWalker.nextNode())) {\n\t\tfunc(node);\n\t}\n\n};\n\nLocations.prototype.locationFromCfi = function(cfi){\n  // Check if the location has not been set yet\n\tif(this._locations.length === 0) {\n\t\treturn -1;\n\t}\n\n  return core.locationOf(cfi, this._locations, this.epubcfi.compare);\n};\n\nLocations.prototype.precentageFromCfi = function(cfi) {\n  // Find closest cfi\n  var loc = this.locationFromCfi(cfi);\n  // Get percentage in total\n  return this.precentageFromLocation(loc);\n};\n\nLocations.prototype.percentageFromLocation = function(loc) {\n  if (!loc || !this.total) {\n    return 0;\n  }\n  return (loc / this.total);\n};\n\nLocations.prototype.cfiFromLocation = function(loc){\n\tvar cfi = -1;\n\t// check that pg is an int\n\tif(typeof loc != \"number\"){\n\t\tloc = parseInt(pg);\n\t}\n\n\tif(loc >= 0 && loc < this._locations.length) {\n\t\tcfi = this._locations[loc];\n\t}\n\n\treturn cfi;\n};\n\nLocations.prototype.cfiFromPercentage = function(value){\n  var percentage = (value > 1) ? value / 100 : value; // Normalize value to 0-1\n\tvar loc = Math.ceil(this.total * percentage);\n\n\treturn this.cfiFromLocation(loc);\n};\n\nLocations.prototype.load = function(locations){\n\tthis._locations = JSON.parse(locations);\n  this.total = this._locations.length-1;\n  return this._locations;\n};\n\nLocations.prototype.save = function(json){\n\treturn JSON.stringify(this._locations);\n};\n\nLocations.prototype.getCurrent = function(json){\n\treturn this._current;\n};\n\nLocations.prototype.setCurrent = function(curr){\n  var loc;\n\n  if(typeof curr == \"string\"){\n    this._currentCfi = curr;\n  } else if (typeof curr == \"number\") {\n    this._current = curr;\n  } else {\n    return;\n  }\n\n  if(this._locations.length === 0) {\n    return;\n\t}\n\n  if(typeof curr == \"string\"){\n    loc = this.locationFromCfi(curr);\n    this._current = loc;\n  } else {\n    loc = curr;\n  }\n\n  this.trigger(\"changed\", {\n    percentage: this.precentageFromLocation(loc)\n  });\n};\n\nObject.defineProperty(Locations.prototype, 'currentLocation', {\n  get: function () {\n    return this._current;\n  },\n  set: function (curr) {\n    this.setCurrent(curr);\n  }\n});\n\nRSVP.EventTarget.mixin(Locations.prototype);\n\nmodule.exports = Locations;\n","function Map(layout){\n  this.layout = layout;\n};\n\nMap.prototype.section = function(view) {\n  var ranges = this.findRanges(view);\n  var map = this.rangeListToCfiList(view, ranges);\n\n  return map;\n};\n\nMap.prototype.page = function(view, start, end) {\n  var root = view.document.body;\n  return this.rangePairToCfiPair(view.section, {\n    start: this.findStart(root, start, end),\n    end: this.findEnd(root, start, end)\n  });\n};\n\nMap.prototype.walk = function(root, func) {\n  //var treeWalker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT, null, false);\n  var treeWalker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {\n      acceptNode: function (node) {\n          if ( node.data.trim().length > 0 ) {\n            return NodeFilter.FILTER_ACCEPT;\n          } else {\n            return NodeFilter.FILTER_REJECT;\n          }\n      }\n  }, false);\n  var node;\n  var result;\n  while ((node = treeWalker.nextNode())) {\n    result = func(node);\n    if(result) break;\n  }\n\n  return result;\n};\n\nMap.prototype.findRanges = function(view){\n  var columns = [];\n  var count = this.layout.count(view);\n  var column = this.layout.column;\n  var gap = this.layout.gap;\n  var start, end;\n\n  for (var i = 0; i < count.pages; i++) {\n    start = (column + gap) * i;\n    end = (column * (i+1)) + (gap * i);\n    columns.push({\n      start: this.findStart(view.document.body, start, end),\n      end: this.findEnd(view.document.body, start, end)\n    });\n  }\n\n  return columns;\n};\n\nMap.prototype.findStart = function(root, start, end){\n  var stack = [root];\n  var $el;\n  var found;\n  var $prev = root;\n  while (stack.length) {\n\n    $el = stack.shift();\n\n    found = this.walk($el, function(node){\n      var left, right;\n      var elPos;\n      var elRange;\n\n\n      if(node.nodeType == Node.TEXT_NODE){\n        elRange = document.createRange();\n        elRange.selectNodeContents(node);\n        elPos = elRange.getBoundingClientRect();\n      } else {\n        elPos = node.getBoundingClientRect();\n      }\n\n      left = elPos.left;\n      right = elPos.right;\n\n      if( left >= start && left <= end ) {\n        return node;\n      } else if (right > start) {\n        return node;\n      } else {\n        $prev = node;\n        stack.push(node);\n      }\n\n    });\n\n    if(found) {\n      return this.findTextStartRange(found, start, end);\n    }\n\n  }\n\n  // Return last element\n  return this.findTextStartRange($prev, start, end);\n};\n\nMap.prototype.findEnd = function(root, start, end){\n  var stack = [root];\n  var $el;\n  var $prev = root;\n  var found;\n\n  while (stack.length) {\n\n    $el = stack.shift();\n\n    found = this.walk($el, function(node){\n\n      var left, right;\n      var elPos;\n      var elRange;\n\n\n      if(node.nodeType == Node.TEXT_NODE){\n        elRange = document.createRange();\n        elRange.selectNodeContents(node);\n        elPos = elRange.getBoundingClientRect();\n      } else {\n        elPos = node.getBoundingClientRect();\n      }\n\n      left = elPos.left;\n      right = elPos.right;\n\n      if(left > end && $prev) {\n        return $prev;\n      } else if(right > end) {\n        return node;\n      } else {\n        $prev = node;\n        stack.push(node);\n      }\n\n    });\n\n\n    if(found){\n      return this.findTextEndRange(found, start, end);\n    }\n\n  }\n\n  // end of chapter\n  return this.findTextEndRange($prev, start, end);\n};\n\n\nMap.prototype.findTextStartRange = function(node, start, end){\n  var ranges = this.splitTextNodeIntoRanges(node);\n  var prev;\n  var range;\n  var pos;\n\n  for (var i = 0; i < ranges.length; i++) {\n    range = ranges[i];\n\n    pos = range.getBoundingClientRect();\n\n    if( pos.left >= start ) {\n      return range;\n    }\n\n    prev = range;\n\n  }\n\n  return ranges[0];\n};\n\nMap.prototype.findTextEndRange = function(node, start, end){\n  var ranges = this.splitTextNodeIntoRanges(node);\n  var prev;\n  var range;\n  var pos;\n\n  for (var i = 0; i < ranges.length; i++) {\n    range = ranges[i];\n\n    pos = range.getBoundingClientRect();\n\n    if(pos.left > end && prev) {\n      return prev;\n    } else if(pos.right > end) {\n      return range;\n    }\n\n    prev = range;\n\n  }\n\n  // Ends before limit\n  return ranges[ranges.length-1];\n\n};\n\nMap.prototype.splitTextNodeIntoRanges = function(node, _splitter){\n  var ranges = [];\n  var textContent = node.textContent || \"\";\n  var text = textContent.trim();\n  var range;\n  var rect;\n  var list;\n  var doc = node.ownerDocument;\n  var splitter = _splitter || \" \";\n\n  pos = text.indexOf(splitter);\n\n  if(pos === -1 || node.nodeType != Node.TEXT_NODE) {\n    range = doc.createRange();\n    range.selectNodeContents(node);\n    return [range];\n  }\n\n  range = doc.createRange();\n  range.setStart(node, 0);\n  range.setEnd(node, pos);\n  ranges.push(range);\n  range = false;\n\n  while ( pos != -1 ) {\n\n    pos = text.indexOf(splitter, pos + 1);\n    if(pos > 0) {\n\n      if(range) {\n        range.setEnd(node, pos);\n        ranges.push(range);\n      }\n\n      range = doc.createRange();\n      range.setStart(node, pos+1);\n    }\n  }\n\n  if(range) {\n    range.setEnd(node, text.length);\n    ranges.push(range);\n  }\n\n  return ranges;\n};\n\n\n\nMap.prototype.rangePairToCfiPair = function(section, rangePair){\n\n  var startRange = rangePair.start;\n  var endRange = rangePair.end;\n\n  startRange.collapse(true);\n  endRange.collapse(true);\n\n  startCfi = section.cfiFromRange(startRange);\n  endCfi = section.cfiFromRange(endRange);\n\n  return {\n    start: startCfi,\n    end: endCfi\n  };\n\n};\n\nMap.prototype.rangeListToCfiList = function(view, columns){\n  var map = [];\n  var rangePair, cifPair;\n\n  for (var i = 0; i < columns.length; i++) {\n    cifPair = this.rangePairToCfiPair(view.section, columns[i]);\n\n    map.push(cifPair);\n\n  }\n\n  return map;\n};\n\nmodule.exports = Map;\n","var core = require('./core');\nvar Parser = require('./parser');\nvar RSVP = require('rsvp');\n\nfunction Navigation(_package, _request){\n  var navigation = this;\n  var parse = new Parser();\n  var request = _request || require('./request');\n\n  this.package = _package;\n  this.toc = [];\n  this.tocByHref = {};\n  this.tocById = {};\n\n  if(_package.navPath) {\n    this.navUrl = _package.baseUrl + _package.navPath;\n    this.nav = {};\n\n    this.nav.load = function(_request){\n      var loading = new RSVP.defer();\n      var loaded = loading.promise;\n\n      request(navigation.navUrl, 'xml').then(function(xml){\n        navigation.toc = parse.nav(xml);\n        navigation.loaded(navigation.toc);\n        loading.resolve(navigation.toc);\n      });\n\n      return loaded;\n    };\n\n  }\n\n  if(_package.ncxPath) {\n    this.ncxUrl = _package.baseUrl + _package.ncxPath;\n    this.ncx = {};\n\n    this.ncx.load = function(_request){\n      var loading = new RSVP.defer();\n      var loaded = loading.promise;\n\n      request(navigation.ncxUrl, 'xml').then(function(xml){\n        navigation.toc = parse.ncx(xml);\n        navigation.loaded(navigation.toc);\n        loading.resolve(navigation.toc);\n      });\n\n      return loaded;\n    };\n\n  }\n};\n\n// Load the navigation\nNavigation.prototype.load = function(_request) {\n  var request = _request || require('./request');\n  var loading, loaded;\n\n  if(this.nav) {\n    loading = this.nav.load();\n  } else if(this.ncx) {\n    loading = this.ncx.load();\n  } else {\n    loaded = new RSVP.defer();\n    loaded.resolve([]);\n    loading = loaded.promise;\n  }\n\n  return loading;\n\n};\n\nNavigation.prototype.loaded = function(toc) {\n  var item;\n\n  for (var i = 0; i < toc.length; i++) {\n    item = toc[i];\n    this.tocByHref[item.href] = i;\n    this.tocById[item.id] = i;\n  }\n\n};\n\n// Get an item from the navigation\nNavigation.prototype.get = function(target) {\n  var index;\n\n  if(!target) {\n    return this.toc;\n  }\n\n  if(target.indexOf(\"#\") === 0) {\n    index = this.tocById[target.substring(1)];\n  } else if(target in this.tocByHref){\n    index = this.tocByHref[target];\n  }\n\n  return this.toc[index];\n};\n\nmodule.exports = Navigation;\n","var RSVP = require('rsvp');\nvar core = require('./core');\nvar Continuous = require('./continuous');\nvar Map = require('./map');\nvar Layout = require('./layout');\n\nfunction Paginate(book, options) {\n\n  Continuous.apply(this, arguments);\n\n  this.settings = core.extend(this.settings || {}, {\n    width: 600,\n    height: 400,\n    axis: \"horizontal\",\n    forceSingle: false,\n    minSpreadWidth: 800, //-- overridden by spread: none (never) / both (always)\n    gap: \"auto\", //-- \"auto\" or int\n    overflow: \"hidden\",\n    infinite: false\n  });\n\n  core.extend(this.settings, options);\n\n  this.isForcedSingle = this.settings.forceSingle;\n\n  this.viewSettings = {\n    axis: this.settings.axis\n  };\n\n  this.start();\n};\n\nPaginate.prototype = Object.create(Continuous.prototype);\nPaginate.prototype.constructor = Paginate;\n\n\nPaginate.prototype.determineSpreads = function(cutoff){\n  if(this.isForcedSingle || !cutoff || this.bounds().width < cutoff) {\n    return 1; //-- Single Page\n  }else{\n    return 2; //-- Double Page\n  }\n};\n\nPaginate.prototype.forceSingle = function(bool){\n  if(bool === false) {\n    this.isForcedSingle = false;\n    // this.spreads = false;\n  } else {\n    this.isForcedSingle = true;\n    // this.spreads = this.determineSpreads(this.minSpreadWidth);\n  }\n  this.applyLayoutMethod();\n};\n\n/**\n* Uses the settings to determine which Layout Method is needed\n* Triggers events based on the method choosen\n* Takes: Layout settings object\n* Returns: String of appropriate for EPUBJS.Layout function\n*/\n// Paginate.prototype.determineLayout = function(settings){\n//   // Default is layout: reflowable & spread: auto\n//   var spreads = this.determineSpreads(this.settings.minSpreadWidth);\n//   console.log(\"spreads\", spreads, this.settings.minSpreadWidth)\n//   var layoutMethod = spreads ? \"ReflowableSpreads\" : \"Reflowable\";\n//   var scroll = false;\n//\n//   if(settings.layout === \"pre-paginated\") {\n//     layoutMethod = \"Fixed\";\n//     scroll = true;\n//     spreads = false;\n//   }\n//\n//   if(settings.layout === \"reflowable\" && settings.spread === \"none\") {\n//     layoutMethod = \"Reflowable\";\n//     scroll = false;\n//     spreads = false;\n//   }\n//\n//   if(settings.layout === \"reflowable\" && settings.spread === \"both\") {\n//     layoutMethod = \"ReflowableSpreads\";\n//     scroll = false;\n//     spreads = true;\n//   }\n//\n//   this.spreads = spreads;\n//\n//   return layoutMethod;\n// };\n\nPaginate.prototype.start = function(){\n  // On display\n  // this.layoutSettings = this.reconcileLayoutSettings(globalLayout, chapter.properties);\n  // this.layoutMethod = this.determineLayout(this.layoutSettings);\n  // this.layout = new EPUBJS.Layout[this.layoutMethod]();\n  //this.hooks.display.register(this.registerLayoutMethod.bind(this));\n  // this.hooks.display.register(this.reportLocation);\n  this.on('displayed', this.reportLocation.bind(this));\n\n  // this.hooks.content.register(this.adjustImages.bind(this));\n\n  this.currentPage = 0;\n\n  window.addEventListener('unload', function(e){\n    this.ignore = true;\n    this.destroy();\n  }.bind(this));\n\n};\n\n// EPUBJS.Rendition.prototype.createView = function(section) {\n//   var view = new EPUBJS.View(section, this.viewSettings);\n\n\n//   return view;\n// };\n\nPaginate.prototype.applyLayoutMethod = function() {\n  //var task = new RSVP.defer();\n\n  // this.spreads = this.determineSpreads(this.settings.minSpreadWidth);\n\n  this.layout = new Layout.Reflowable();\n\n  this.updateLayout();\n\n  // Set the look ahead offset for what is visible\n\n  this.map = new Map(this.layout);\n\n  // this.hooks.layout.register(this.layout.format.bind(this));\n\n  //task.resolve();\n  //return task.promise;\n  // return layout;\n};\n\nPaginate.prototype.updateLayout = function() {\n\n  this.spreads = this.determineSpreads(this.settings.minSpreadWidth);\n\n  this.layout.calculate(\n    this.stage.width,\n    this.stage.height,\n    this.settings.gap,\n    this.spreads\n  );\n\n  this.settings.offset = this.layout.delta;\n\n};\n\nPaginate.prototype.moveTo = function(offset){\n  var dist = Math.floor(offset.left / this.layout.delta) * this.layout.delta;\n  return this.check(0, dist+this.settings.offset).then(function(){\n    this.scrollBy(dist, 0);\n  }.bind(this));\n};\n\nPaginate.prototype.page = function(pg){\n\n  // this.currentPage = pg;\n  // this.renderer.infinite.scrollTo(this.currentPage * this.formated.pageWidth, 0);\n  //-- Return false if page is greater than the total\n  // return false;\n};\n\nPaginate.prototype.next = function(){\n\n  return this.q.enqueue(function(){\n    // console.log(this.container.scrollWidth, this.container.scrollLeft + this.container.offsetWidth + this.layout.delta)\n    if(this.container.scrollLeft +\n       this.container.offsetWidth +\n       this.layout.delta < this.container.scrollWidth) {\n      this.scrollBy(this.layout.delta, 0);\n    } else {\n      this.scrollTo(this.container.scrollWidth - this.layout.delta, 0);\n    }\n    this.reportLocation();\n    return this.check();\n  });\n\n  // return this.page(this.currentPage + 1);\n};\n\nPaginate.prototype.prev = function(){\n\n  return this.q.enqueue(function(){\n    this.scrollBy(-this.layout.delta, 0);\n    this.reportLocation();\n    return this.check();\n  });\n  // return this.page(this.currentPage - 1);\n};\n\n// Paginate.prototype.reportLocation = function(){\n//   return this.q.enqueue(function(){\n//     this.location = this.currentLocation();\n//     this.trigger(\"locationChanged\", this.location);\n//   }.bind(this));\n// };\n\nPaginate.prototype.currentLocation = function(){\n  var visible = this.visible();\n  var startA, startB, endA, endB;\n  var pageLeft, pageRight;\n  var container = this.container.getBoundingClientRect();\n\n  if(visible.length === 1) {\n    startA = container.left - visible[0].position().left;\n    endA = startA + this.layout.spread;\n\n    return this.map.page(visible[0], startA, endA);\n  }\n\n  if(visible.length > 1) {\n\n    // Left Col\n    startA = container.left - visible[0].position().left;\n    endA = startA + this.layout.column;\n\n    // Right Col\n    startB = container.left + this.layout.spread - visible[visible.length-1].position().left;\n    endB = startB + this.layout.column;\n\n    pageLeft = this.map.page(visible[0], startA, endA);\n    pageRight = this.map.page(visible[visible.length-1], startB, endB);\n\n    return {\n      start: pageLeft.start,\n      end: pageRight.end\n    };\n  }\n};\n\nPaginate.prototype.resize = function(width, height){\n  // Clear the queue\n  this.q.clear();\n\n  this.stageSize(width, height);\n\n  this.updateLayout();\n\n  if(this.location) {\n    this.display(this.location.start);\n  }\n\n  this.trigger(\"resized\", {\n    width: this.stage.width,\n    height: this.stage.height\n  });\n\n};\n\nPaginate.prototype.onResized = function(e) {\n\n  this.views.clear();\n\n  clearTimeout(this.resizeTimeout);\n  this.resizeTimeout = setTimeout(function(){\n    this.resize();\n  }.bind(this), 150);\n};\n\nPaginate.prototype.adjustImages = function(view) {\n\n  view.addStylesheetRules([\n      [\"img\",\n        [\"max-width\", (this.layout.spread) + \"px\"],\n        [\"max-height\", (this.layout.height) + \"px\"]\n      ]\n  ]);\n  return new RSVP.Promise(function(resolve, reject){\n    // Wait to apply\n    setTimeout(function() {\n      resolve();\n    }, 1);\n  });\n};\n\n// Paginate.prototype.display = function(what){\n//   return this.display(what);\n// };\n\nmodule.exports = Paginate;\n","var core = require('./core');\nvar EpubCFI = require('./epubcfi');\n\nfunction Parser(){};\n\nParser.prototype.container = function(containerXml){\n    //-- <rootfile full-path=\"OPS/package.opf\" media-type=\"application/oebps-package+xml\"/>\n    var rootfile, fullpath, folder, encoding;\n\n    if(!containerXml) {\n      console.error(\"Container File Not Found\");\n      return;\n    }\n\n    rootfile = containerXml.querySelector(\"rootfile\");\n\n    if(!rootfile) {\n      console.error(\"No RootFile Found\");\n      return;\n    }\n\n    fullpath = rootfile.getAttribute('full-path');\n    folder = core.uri(fullpath).directory;\n    encoding = containerXml.xmlEncoding;\n\n    //-- Now that we have the path we can parse the contents\n    return {\n      'packagePath' : fullpath,\n      'basePath' : folder,\n      'encoding' : encoding\n    };\n};\n\nParser.prototype.identifier = function(packageXml){\n  var metadataNode;\n\n  if(!packageXml) {\n    console.error(\"Package File Not Found\");\n    return;\n  }\n\n  metadataNode = packageXml.querySelector(\"metadata\");\n\n  if(!metadataNode) {\n    console.error(\"No Metadata Found\");\n    return;\n  }\n\n  return this.getElementText(metadataNode, \"identifier\");\n};\n\nParser.prototype.packageContents = function(packageXml){\n  var parse = this;\n  var metadataNode, manifestNode, spineNode;\n  var manifest, navPath, ncxPath, coverPath;\n  var spineNodeIndex;\n  var spine;\n  var spineIndexByURL;\n  var metadata;\n\n  if(!packageXml) {\n    console.error(\"Package File Not Found\");\n    return;\n  }\n\n  metadataNode = packageXml.querySelector(\"metadata\");\n  if(!metadataNode) {\n    console.error(\"No Metadata Found\");\n    return;\n  }\n\n  manifestNode = packageXml.querySelector(\"manifest\");\n  if(!manifestNode) {\n    console.error(\"No Manifest Found\");\n    return;\n  }\n\n  spineNode = packageXml.querySelector(\"spine\");\n  if(!spineNode) {\n    console.error(\"No Spine Found\");\n    return;\n  }\n\n  manifest = parse.manifest(manifestNode);\n  navPath = parse.findNavPath(manifestNode);\n  ncxPath = parse.findNcxPath(manifestNode, spineNode);\n  coverPath = parse.findCoverPath(packageXml);\n\n  spineNodeIndex = Array.prototype.indexOf.call(spineNode.parentNode.childNodes, spineNode);\n\n  spine = parse.spine(spineNode, manifest);\n\n  metadata = parse.metadata(metadataNode);\n\n\tmetadata.direction = spineNode.getAttribute(\"page-progression-direction\");\n\n  return {\n    'metadata' : metadata,\n    'spine'    : spine,\n    'manifest' : manifest,\n    'navPath'  : navPath,\n    'ncxPath'  : ncxPath,\n    'coverPath': coverPath,\n    'spineNodeIndex' : spineNodeIndex\n  };\n};\n\n//-- Find TOC NAV\nParser.prototype.findNavPath = function(manifestNode){\n\t// Find item with property 'nav'\n\t// Should catch nav irregardless of order\n  var node = manifestNode.querySelector(\"item[properties$='nav'], item[properties^='nav '], item[properties*=' nav ']\");\n  return node ? node.getAttribute('href') : false;\n};\n\n//-- Find TOC NCX: media-type=\"application/x-dtbncx+xml\" href=\"toc.ncx\"\nParser.prototype.findNcxPath = function(manifestNode, spineNode){\n\tvar node = manifestNode.querySelector(\"item[media-type='application/x-dtbncx+xml']\");\n\tvar tocId;\n\n\t// If we can't find the toc by media-type then try to look for id of the item in the spine attributes as\n\t// according to http://www.idpf.org/epub/20/spec/OPF_2.0.1_draft.htm#Section2.4.1.2,\n\t// \"The item that describes the NCX must be referenced by the spine toc attribute.\"\n\tif (!node) {\n\t\ttocId = spineNode.getAttribute(\"toc\");\n\t\tif(tocId) {\n\t\t\tnode = manifestNode.querySelector(\"item[id='\" + tocId + \"']\");\n\t\t}\n\t}\n\n\treturn node ? node.getAttribute('href') : false;\n};\n\n//-- Expanded to match Readium web components\nParser.prototype.metadata = function(xml){\n  var metadata = {},\n      p = this;\n\n  metadata.title = p.getElementText(xml, 'title');\n  metadata.creator = p.getElementText(xml, 'creator');\n  metadata.description = p.getElementText(xml, 'description');\n\n  metadata.pubdate = p.getElementText(xml, 'date');\n\n  metadata.publisher = p.getElementText(xml, 'publisher');\n\n  metadata.identifier = p.getElementText(xml, \"identifier\");\n  metadata.language = p.getElementText(xml, \"language\");\n  metadata.rights = p.getElementText(xml, \"rights\");\n\n  metadata.modified_date = p.querySelectorText(xml, \"meta[property='dcterms:modified']\");\n  metadata.layout = p.querySelectorText(xml, \"meta[property='rendition:layout']\");\n  metadata.orientation = p.querySelectorText(xml, \"meta[property='rendition:orientation']\");\n  metadata.spread = p.querySelectorText(xml, \"meta[property='rendition:spread']\");\n  // metadata.page_prog_dir = packageXml.querySelector(\"spine\").getAttribute(\"page-progression-direction\");\n\n  return metadata;\n};\n\n//-- Find Cover: <item properties=\"cover-image\" id=\"ci\" href=\"cover.svg\" media-type=\"image/svg+xml\" />\n//-- Fallback for Epub 2.0\nParser.prototype.findCoverPath = function(packageXml){\n\n\tvar epubVersion = packageXml.querySelector('package').getAttribute('version');\n\n\tif (epubVersion === '2.0') {\n\t\tvar metaCover = packageXml.querySelector('meta[name=\"cover\"]');\n\t\tif (metaCover) {\n\t\t\tvar coverId = metaCover.getAttribute('content');\n\t\t\tvar cover = packageXml.querySelector(\"item[id='\" + coverId + \"']\");\n\t\t\treturn cover ? cover.getAttribute('href') : false;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\tvar node = packageXml.querySelector(\"item[properties='cover-image']\");\n\t\treturn node ? node.getAttribute('href') : false;\n\t}\n};\n\nParser.prototype.getElementText = function(xml, tag){\n  var found = xml.getElementsByTagNameNS(\"http://purl.org/dc/elements/1.1/\", tag),\n    el;\n\n  if(!found || found.length === 0) return '';\n\n  el = found[0];\n\n  if(el.childNodes.length){\n    return el.childNodes[0].nodeValue;\n  }\n\n  return '';\n\n};\n\nParser.prototype.querySelectorText = function(xml, q){\n  var el = xml.querySelector(q);\n\n  if(el && el.childNodes.length){\n    return el.childNodes[0].nodeValue;\n  }\n\n  return '';\n};\n\nParser.prototype.manifest = function(manifestXml){\n  var manifest = {};\n\n  //-- Turn items into an array\n  var selected = manifestXml.querySelectorAll(\"item\"),\n    items = Array.prototype.slice.call(selected);\n\n  //-- Create an object with the id as key\n  items.forEach(function(item){\n    var id = item.getAttribute('id'),\n        href = item.getAttribute('href') || '',\n        type = item.getAttribute('media-type') || '',\n        properties = item.getAttribute('properties') || '';\n\n    manifest[id] = {\n      'href' : href,\n      // 'url' : href,\n      'type' : type,\n      'properties' : properties.length ? properties.split(' ') : []\n    };\n\n  });\n\n  return manifest;\n\n};\n\nParser.prototype.spine = function(spineXml, manifest){\n  var spine = [];\n\n  var selected = spineXml.getElementsByTagName(\"itemref\"),\n      items = Array.prototype.slice.call(selected);\n\n  var epubcfi = new EpubCFI();\n\n  //-- Add to array to mantain ordering and cross reference with manifest\n  items.forEach(function(item, index){\n    var idref = item.getAttribute('idref');\n    // var cfiBase = epubcfi.generateChapterComponent(spineNodeIndex, index, Id);\n    var props = item.getAttribute('properties') || '';\n    var propArray = props.length ? props.split(' ') : [];\n    // var manifestProps = manifest[Id].properties;\n    // var manifestPropArray = manifestProps.length ? manifestProps.split(' ') : [];\n\n    var itemref = {\n      'idref' : idref,\n      'linear' : item.getAttribute('linear') || '',\n      'properties' : propArray,\n      // 'href' : manifest[Id].href,\n      // 'url' :  manifest[Id].url,\n      'index' : index\n      // 'cfiBase' : cfiBase\n    };\n    spine.push(itemref);\n  });\n\n  return spine;\n};\n\nParser.prototype.querySelectorByType = function(html, element, type){\n\tvar query = html.querySelector(element+'[*|type=\"'+type+'\"]');\n\t// Handle IE not supporting namespaced epub:type in querySelector\n\tif(query === null || query.length === 0) {\n\t\tquery = html.querySelectorAll(element);\n\t\tfor (var i = 0; i < query.length; i++) {\n\t\t\tif(query[i].getAttributeNS(\"http://www.idpf.org/2007/ops\", \"type\") === type) {\n\t\t\t\treturn query[i];\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn query;\n\t}\n};\n\nParser.prototype.nav = function(navHtml, spineIndexByURL, bookSpine){\n\tvar navElement = this.querySelectorByType(navHtml, \"nav\", \"toc\");\n\tvar navItems = navElement ? navElement.querySelectorAll(\"ol li\") : [];\n\tvar length = navItems.length;\n\tvar i;\n\tvar toc = {};\n\tvar list = [];\n\tvar item, parent;\n\n\tif(!navItems || length === 0) return list;\n\n\tfor (i = 0; i < length; ++i) {\n\t\titem = this.navItem(navItems[i], spineIndexByURL, bookSpine);\n\t\ttoc[item.id] = item;\n\t\tif(!item.parent) {\n\t\t\tlist.push(item);\n\t\t} else {\n\t\t\tparent = toc[item.parent];\n\t\t\tparent.subitems.push(item);\n\t\t}\n\t}\n\n\treturn list;\n};\n\nParser.prototype.navItem = function(item, spineIndexByURL, bookSpine){\n\tvar id = item.getAttribute('id') || false,\n\t\t\tcontent = item.querySelector(\"a, span\"),\n\t\t\tsrc = content.getAttribute('href') || '',\n\t\t\ttext = content.textContent || \"\",\n\t\t\tsplit = src.split(\"#\"),\n\t\t\tbaseUrl = split[0],\n\t\t\t// spinePos = spineIndexByURL[baseUrl],\n\t\t\t// spineItem = bookSpine[spinePos],\n\t\t\tsubitems = [],\n\t\t\tparentNode = item.parentNode,\n\t\t\tparent;\n\t\t\t// cfi = spineItem ? spineItem.cfi : '';\n\n\tif(parentNode && parentNode.nodeName === \"navPoint\") {\n\t\tparent = parentNode.getAttribute('id');\n\t}\n\n  /*\n\tif(!id) {\n\t\tif(spinePos) {\n\t\t\tspineItem = bookSpine[spinePos];\n\t\t\tid = spineItem.id;\n\t\t\tcfi = spineItem.cfi;\n\t\t} else {\n\t\t\tid = 'epubjs-autogen-toc-id-' + EPUBJS.core.uuid();\n\t\t\titem.setAttribute('id', id);\n\t\t}\n\t}\n  */\n\n\treturn {\n\t\t\"id\": id,\n\t\t\"href\": src,\n\t\t\"label\": text,\n\t\t\"subitems\" : subitems,\n\t\t\"parent\" : parent\n\t};\n};\n\nParser.prototype.toc = function(tocXml, spineIndexByURL, bookSpine){\n\tvar navPoints = tocXml.querySelectorAll(\"navMap navPoint\");\n\tvar length = navPoints.length;\n\tvar i;\n\tvar toc = {};\n\tvar list = [];\n\tvar item, parent;\n\n\tif(!navPoints || length === 0) return list;\n\n\tfor (i = 0; i < length; ++i) {\n\t\titem = this.tocItem(navPoints[i], spineIndexByURL, bookSpine);\n\t\ttoc[item.id] = item;\n\t\tif(!item.parent) {\n\t\t\tlist.push(item);\n\t\t} else {\n\t\t\tparent = toc[item.parent];\n\t\t\tparent.subitems.push(item);\n\t\t}\n\t}\n\n\treturn list;\n};\n\nParser.prototype.tocItem = function(item, spineIndexByURL, bookSpine){\n\tvar id = item.getAttribute('id') || false,\n\t\t\tcontent = item.querySelector(\"content\"),\n\t\t\tsrc = content.getAttribute('src'),\n\t\t\tnavLabel = item.querySelector(\"navLabel\"),\n\t\t\ttext = navLabel.textContent ? navLabel.textContent : \"\",\n\t\t\tsplit = src.split(\"#\"),\n\t\t\tbaseUrl = split[0],\n\t\t\t// spinePos = spineIndexByURL[baseUrl],\n\t\t\t// spineItem = bookSpine[spinePos],\n\t\t\tsubitems = [],\n\t\t\tparentNode = item.parentNode,\n\t\t\tparent;\n\t\t\t// cfi = spineItem ? spineItem.cfi : '';\n\n\tif(parentNode && parentNode.nodeName === \"navPoint\") {\n\t\tparent = parentNode.getAttribute('id');\n\t}\n\n  /*\n\tif(!id) {\n\t\tif(spinePos) {\n\t\t\tspineItem = bookSpine[spinePos];\n\t\t\tid = spineItem.id;\n\t\t\tcfi = spineItem.cfi;\n\t\t} else {\n\t\t\tid = 'epubjs-autogen-toc-id-' + EPUBJS.core.uuid();\n\t\t\titem.setAttribute('id', id);\n\t\t}\n\t}\n  */\n\n\treturn {\n\t\t\"id\": id,\n\t\t\"href\": src,\n\t\t\"label\": text,\n\t\t\"subitems\" : subitems,\n\t\t\"parent\" : parent\n\t};\n};\n\nParser.prototype.pageList = function(navHtml, spineIndexByURL, bookSpine){\n\tvar navElement = this.querySelectorByType(navHtml, \"nav\", \"page-list\");\n\tvar navItems = navElement ? navElement.querySelectorAll(\"ol li\") : [];\n\tvar length = navItems.length;\n\tvar i;\n\tvar toc = {};\n\tvar list = [];\n\tvar item;\n\n\tif(!navItems || length === 0) return list;\n\n\tfor (i = 0; i < length; ++i) {\n\t\titem = this.pageListItem(navItems[i], spineIndexByURL, bookSpine);\n\t\tlist.push(item);\n\t}\n\n\treturn list;\n};\n\nParser.prototype.pageListItem = function(item, spineIndexByURL, bookSpine){\n\tvar id = item.getAttribute('id') || false,\n\t\tcontent = item.querySelector(\"a\"),\n\t\thref = content.getAttribute('href') || '',\n\t\ttext = content.textContent || \"\",\n\t\tpage = parseInt(text),\n\t\tisCfi = href.indexOf(\"epubcfi\"),\n\t\tsplit,\n\t\tpackageUrl,\n\t\tcfi;\n\n\tif(isCfi != -1) {\n\t\tsplit = href.split(\"#\");\n\t\tpackageUrl = split[0];\n\t\tcfi = split.length > 1 ? split[1] : false;\n\t\treturn {\n\t\t\t\"cfi\" : cfi,\n\t\t\t\"href\" : href,\n\t\t\t\"packageUrl\" : packageUrl,\n\t\t\t\"page\" : page\n\t\t};\n\t} else {\n\t\treturn {\n\t\t\t\"href\" : href,\n\t\t\t\"page\" : page\n\t\t};\n\t}\n};\n\nmodule.exports = Parser;\n","var RSVP = require('rsvp');\nvar core = require('./core');\n\nfunction Queue(_context){\n  this._q = [];\n  this.context = _context;\n  this.tick = core.requestAnimationFrame;\n  this.running = false;\n  this.paused = false;\n};\n\n// Add an item to the queue\nQueue.prototype.enqueue = function() {\n  var deferred, promise;\n  var queued;\n  var task = [].shift.call(arguments);\n  var args = arguments;\n\n  // Handle single args without context\n  // if(args && !Array.isArray(args)) {\n  //   args = [args];\n  // }\n  if(!task) {\n    return console.error(\"No Task Provided\");\n  }\n\n  if(typeof task === \"function\"){\n\n    deferred = new RSVP.defer();\n    promise = deferred.promise;\n\n    queued = {\n      \"task\" : task,\n      \"args\"     : args,\n      //\"context\"  : context,\n      \"deferred\" : deferred,\n      \"promise\" : promise\n    };\n\n  } else {\n    // Task is a promise\n    queued = {\n      \"promise\" : task\n    };\n\n  }\n\n  this._q.push(queued);\n\n  // Wait to start queue flush\n  if (this.paused == false && !this.running) {\n    // setTimeout(this.flush.bind(this), 0);\n    // this.tick.call(window, this.run.bind(this));\n    this.run();\n  }\n\n  return queued.promise;\n};\n\n// Run one item\nQueue.prototype.dequeue = function(){\n  var inwait, task, result;\n\n  if(this._q.length) {\n    inwait = this._q.shift();\n    task = inwait.task;\n    if(task){\n      // console.log(task)\n\n      result = task.apply(this.context, inwait.args);\n\n      if(result && typeof result[\"then\"] === \"function\") {\n        // Task is a function that returns a promise\n        return result.then(function(){\n          inwait.deferred.resolve.apply(this.context, arguments);\n        }.bind(this));\n      } else {\n        // Task resolves immediately\n        inwait.deferred.resolve.apply(this.context, result);\n        return inwait.promise;\n      }\n\n\n\n    } else if(inwait.promise) {\n      // Task is a promise\n      return inwait.promise;\n    }\n\n  } else {\n    inwait = new RSVP.defer();\n    inwait.deferred.resolve();\n    return inwait.promise;\n  }\n\n};\n\n// Run All Immediately\nQueue.prototype.dump = function(){\n  while(this._q.length) {\n    this.dequeue();\n  }\n};\n\n// Run all sequentially, at convince\n\nQueue.prototype.run = function(){\n\n  if(!this.running){\n    this.running = true;\n    this.defered = new RSVP.defer();\n  }\n\n  this.tick.call(window, function() {\n\n    if(this._q.length) {\n\n      this.dequeue()\n        .then(function(){\n          this.run();\n        }.bind(this));\n\n    } else {\n      this.defered.resolve();\n      this.running = undefined;\n    }\n\n  }.bind(this));\n\n  // Unpause\n  if(this.paused == true) {\n    this.paused = false;\n  }\n\n  return this.defered.promise;\n};\n\n// Flush all, as quickly as possible\nQueue.prototype.flush = function(){\n\n  if(this.running){\n    return this.running;\n  }\n\n  if(this._q.length) {\n    this.running = this.dequeue()\n      .then(function(){\n        this.running = undefined;\n        return this.flush();\n      }.bind(this));\n\n    return this.running;\n  }\n\n};\n\n// Clear all items in wait\nQueue.prototype.clear = function(){\n  this._q = [];\n  this.running = false;\n};\n\nQueue.prototype.length = function(){\n  return this._q.length;\n};\n\nQueue.prototype.pause = function(){\n  this.paused = true;\n};\n\n// Create a new task from a callback\nfunction Task(task, args, context){\n\n  return function(){\n    var toApply = arguments || [];\n\n    return new RSVP.Promise(function(resolve, reject) {\n      var callback = function(value){\n        resolve(value);\n      };\n      // Add the callback to the arguments list\n      toApply.push(callback);\n\n      // Apply all arguments to the functions\n      task.apply(this, toApply);\n\n  }.bind(this));\n\n  };\n\n};\n\nmodule.exports = Queue;\n","var RSVP = require('rsvp');\nvar core = require('./core');\nvar replace = require('./replacements');\nvar Hook = require('./hook');\nvar EpubCFI = require('./epubcfi');\nvar Queue = require('./queue');\nvar View = require('./view');\nvar Views = require('./views');\nvar Layout = require('./layout');\nvar Map = require('./map');\n\nfunction Rendition(book, options) {\n\n\tthis.settings = core.extend(this.settings || {}, {\n\t\tinfinite: true,\n\t\thidden: false,\n\t\twidth: false,\n\t\theight: null,\n\t\tlayoutOveride : null, // Default: { spread: 'reflowable', layout: 'auto', orientation: 'auto'},\n\t\taxis: \"vertical\"\n\t});\n\n\tcore.extend(this.settings, options);\n\n\tthis.viewSettings = {};\n\n\tthis.book = book;\n\n\tthis.views = null;\n\n\t//-- Adds Hook methods to the Rendition prototype\n\tthis.hooks = {};\n\tthis.hooks.display = new Hook(this);\n\tthis.hooks.content = new Hook(this);\n\tthis.hooks.layout = new Hook(this);\n\tthis.hooks.render = new Hook(this);\n\tthis.hooks.show = new Hook(this);\n\n\tthis.hooks.content.register(replace.links.bind(this));\n\tthis.hooks.content.register(this.passViewEvents.bind(this));\n\n\t// this.hooks.display.register(this.afterDisplay.bind(this));\n\n  this.epubcfi = new EpubCFI();\n\n\tthis.q = new Queue(this);\n\n\tthis.q.enqueue(this.book.opened);\n\n\tthis.q.enqueue(this.parseLayoutProperties);\n\n};\n\n/**\n* Creates an element to render to.\n* Resizes to passed width and height or to the elements size\n*/\nRendition.prototype.initialize = function(_options){\n\tvar options = _options || {};\n\tvar height  = options.height;// !== false ? options.height : \"100%\";\n\tvar width   = options.width;// !== false ? options.width : \"100%\";\n\tvar hidden  = options.hidden || false;\n\tvar container;\n\tvar wrapper;\n\n\tif(options.height && core.isNumber(options.height)) {\n\t\theight = options.height + \"px\";\n\t}\n\n\tif(options.width && core.isNumber(options.width)) {\n\t\twidth = options.width + \"px\";\n\t}\n\n\t// Create new container element\n\tcontainer = document.createElement(\"div\");\n\n\tcontainer.id = \"epubjs-container:\" + core.uuid();\n\tcontainer.classList.add(\"epub-container\");\n\n\t// Style Element\n\tcontainer.style.fontSize = \"0\";\n\tcontainer.style.wordSpacing = \"0\";\n\tcontainer.style.lineHeight = \"0\";\n\tcontainer.style.verticalAlign = \"top\";\n\n\tif(this.settings.axis === \"horizontal\") {\n\t\tcontainer.style.whiteSpace = \"nowrap\";\n\t}\n\n\tif(width){\n\t\tcontainer.style.width = width;\n\t}\n\n\tif(height){\n\t\tcontainer.style.height = height;\n\t}\n\n\tcontainer.style.overflow = this.settings.overflow;\n\n\treturn container;\n};\n\nRendition.wrap = function(container) {\n\tvar wrapper = document.createElement(\"div\");\n\n\twrapper.style.visibility = \"hidden\";\n\twrapper.style.overflow = \"hidden\";\n\twrapper.style.width = \"0\";\n\twrapper.style.height = \"0\";\n\n\twrapper.appendChild(container);\n\treturn wrapper;\n};\n\n// Call to attach the container to an element in the dom\n// Container must be attached before rendering can begin\nRendition.prototype.attachTo = function(_element){\n\tvar bounds;\n\n\tthis.container = this.initialize({\n\t\t\"width\"  : this.settings.width,\n\t\t\"height\" : this.settings.height\n\t});\n\n\tif(core.isElement(_element)) {\n\t\tthis.element = _element;\n\t} else if (typeof _element === \"string\") {\n\t\tthis.element = document.getElementById(_element);\n\t}\n\n\tif(!this.element){\n\t\tconsole.error(\"Not an Element\");\n\t\treturn;\n\t}\n\n\tif(this.settings.hidden) {\n\t\tthis.wrapper = this.wrap(this.container);\n\t\tthis.element.appendChild(this.wrapper);\n\t} else {\n\t\tthis.element.appendChild(this.container);\n\t}\n\n\tthis.views = new Views(this.container);\n\n\t// Attach Listeners\n\tthis.attachListeners();\n\n\t// Calculate Stage Size\n\tthis.stageSize();\n\n\t// Add Layout method\n\tthis.applyLayoutMethod();\n\n\t// Trigger Attached\n\tthis.trigger(\"attached\");\n\n\t// Start processing queue\n\t// this.q.run();\n\n};\n\nRendition.prototype.attachListeners = function(){\n\n\t// Listen to window for resize event if width or height is set to 100%\n\tif(!core.isNumber(this.settings.width) ||\n\t\t !core.isNumber(this.settings.height) ) {\n\t\twindow.addEventListener(\"resize\", this.onResized.bind(this), false);\n\t}\n\n};\n\nRendition.prototype.bounds = function() {\n\treturn this.container.getBoundingClientRect();\n};\n\nRendition.prototype.display = function(target){\n\n\treturn this.q.enqueue(this._display, target);\n\n};\n\nRendition.prototype._display = function(target){\n\n\tvar displaying = new RSVP.defer();\n\tvar displayed = displaying.promise;\n\n\tvar section;\n  var view;\n  var offset;\n\tvar fragment;\n\tvar cfi = this.epubcfi.isCfiString(target);\n\n\tvar visible;\n\n\tsection = this.book.spine.get(target);\n\n\tif(!section){\n\t\tdisplaying.reject(new Error(\"No Section Found\"));\n\t\treturn displayed;\n\t}\n\n\t// Check to make sure the section we want isn't already shown\n\tvisible = this.views.find(section);\n\n\tif(visible) {\n\t\toffset = view.locationOf(target);\n\t\tdisplayed = this.moveTo(offset)\n\t\t\t.then(function(){\n\t\t\t\treturn this.check();\n\t\t\t});\n\t} else {\n\n\t\t// Hide all current views\n\t\tthis.views.hide();\n\n\t\t// Create a new view\n\t\tview = new View(section, this.viewSettings);\n\n\t\t// This will clear all previous views\n\t\tdisplayed = this.fill(view)\n\t\t\t.then(function(){\n\n\t\t\t\t// Parse the target fragment\n\t\t\t\tif(typeof target === \"string\" &&\n\t\t\t\t\ttarget.indexOf(\"#\") > -1) {\n\t\t\t\t\t\tfragment = target.substring(target.indexOf(\"#\")+1);\n\t\t\t\t}\n\n\t\t\t\t// Move to correct place within the section, if needed\n\t\t\t\tif(cfi || fragment) {\n\t\t\t\t\toffset = view.locationOf(target);\n\t\t\t\t\treturn this.moveTo(offset);\n\t\t\t\t}\n\n\t\t\t\tif(typeof this.check === 'function') {\n\t\t\t\t\treturn this.check();\n\t\t\t\t}\n\t\t\t}.bind(this))\n\t\t\t.then(function(){\n\t\t\t\treturn this.hooks.display.trigger(view);\n\t\t\t}.bind(this))\n\t\t\t.then(function(){\n\t\t\t\tthis.views.show();\n\t\t\t}.bind(this));\n\t}\n\n\tdisplayed.then(function(){\n\n\t\tthis.trigger(\"displayed\", section);\n\n\t}.bind(this));\n\n\n\treturn displayed;\n};\n\n// Takes a cfi, fragment or page?\nRendition.prototype.moveTo = function(offset){\n\tthis.scrollBy(offset.left, offset.top);\n};\n\nRendition.prototype.render = function(view, show) {\n\n\tview.create();\n\n\tview.onLayout = this.layout.format.bind(this.layout);\n\n\t// Fit to size of the container, apply padding\n\tthis.resizeView(view);\n\n\t// Render Chain\n\treturn view.render(this.book.request)\n\t\t.then(function(){\n\t\t\treturn this.hooks.content.trigger(view, this);\n\t\t}.bind(this))\n\t\t.then(function(){\n\t\t\treturn this.hooks.layout.trigger(view, this);\n\t\t}.bind(this))\n\t\t.then(function(){\n\t\t\treturn view.display();\n\t\t}.bind(this))\n\t\t.then(function(){\n\t\t\treturn this.hooks.render.trigger(view, this);\n\t\t}.bind(this))\n\t\t.then(function(){\n\t\t\tif(show !== false && this.views.hidden === false) {\n\t\t\t\tthis.q.enqueue(function(view){\n\t\t\t\t\tview.show();\n\t\t\t\t}, view);\n\t\t\t}\n\n\n\t\t\t// this.map = new Map(view, this.layout);\n\t\t\tthis.hooks.show.trigger(view, this);\n\t\t\tthis.trigger(\"rendered\", view.section);\n\n\t\t}.bind(this))\n\t\t.catch(function(e){\n\t\t\tthis.trigger(\"loaderror\", e);\n\t\t}.bind(this));\n\n};\n\n\nRendition.prototype.afterDisplayed = function(view){\n\tthis.trigger(\"added\", view.section);\n};\n\nRendition.prototype.fill = function(view){\n\n\tthis.views.clear();\n\n\tthis.views.append(view);\n\n\t// view.on(\"shown\", this.afterDisplayed.bind(this));\n\tview.onDisplayed = this.afterDisplayed.bind(this);\n\n\treturn this.render(view);\n};\n\nRendition.prototype.resizeView = function(view) {\n\n\tif(this.globalLayoutProperties.layout === \"pre-paginated\") {\n\t\tview.lock(\"both\", this.stage.width, this.stage.height);\n\t} else {\n\t\tview.lock(\"width\", this.stage.width, this.stage.height);\n\t}\n\n};\n\nRendition.prototype.stageSize = function(_width, _height){\n\tvar bounds;\n\tvar width = _width || this.settings.width;\n\tvar height = _height || this.settings.height;\n\n\t// If width or height are set to false, inherit them from containing element\n\tif(width === false) {\n\t\tbounds = this.element.getBoundingClientRect();\n\n\t\tif(bounds.width) {\n\t\t\twidth = bounds.width;\n\t\t\tthis.container.style.width = bounds.width + \"px\";\n\t\t}\n\t}\n\n\tif(height === false) {\n\t\tbounds = bounds || this.element.getBoundingClientRect();\n\n\t\tif(bounds.height) {\n\t\t\theight = bounds.height;\n\t\t\tthis.container.style.height = bounds.height + \"px\";\n\t\t}\n\n\t}\n\n\tif(width && !core.isNumber(width)) {\n\t\tbounds = this.container.getBoundingClientRect();\n\t\twidth = bounds.width;\n\t\t//height = bounds.height;\n\t}\n\n\tif(height && !core.isNumber(height)) {\n\t\tbounds = bounds || this.container.getBoundingClientRect();\n\t\t//width = bounds.width;\n\t\theight = bounds.height;\n\t}\n\n\n\tthis.containerStyles = window.getComputedStyle(this.container);\n\tthis.containerPadding = {\n\t\tleft: parseFloat(this.containerStyles[\"padding-left\"]) || 0,\n\t\tright: parseFloat(this.containerStyles[\"padding-right\"]) || 0,\n\t\ttop: parseFloat(this.containerStyles[\"padding-top\"]) || 0,\n\t\tbottom: parseFloat(this.containerStyles[\"padding-bottom\"]) || 0\n\t};\n\n\tthis.stage = {\n\t\twidth: width -\n\t\t\t\t\t\tthis.containerPadding.left -\n\t\t\t\t\t\tthis.containerPadding.right,\n\t\theight: height -\n\t\t\t\t\t\tthis.containerPadding.top -\n\t\t\t\t\t\tthis.containerPadding.bottom\n\t};\n\n\treturn this.stage;\n\n};\n\nRendition.prototype.applyLayoutMethod = function() {\n\n\tthis.layout = new Layout.Scroll();\n\tthis.updateLayout();\n\n\tthis.map = new Map(this.layout);\n};\n\nRendition.prototype.updateLayout = function() {\n\n\tthis.layout.calculate(this.stage.width, this.stage.height);\n\n};\n\nRendition.prototype.resize = function(width, height){\n\n\tthis.stageSize(width, height);\n\n\tthis.updateLayout();\n\n\tthis.views.each(this.resizeView.bind(this));\n\n\tthis.trigger(\"resized\", {\n\t\twidth: this.stage.width,\n\t\theight: this.stage.height\n\t});\n\n};\n\nRendition.prototype.onResized = function(e) {\n\tthis.resize();\n};\n\nRendition.prototype.createView = function(section) {\n\treturn new View(section, this.viewSettings);\n};\n\nRendition.prototype.next = function(){\n\n\treturn this.q.enqueue(function(){\n\n\t\tvar next;\n\t\tvar view;\n\n\t\tif(!this.views.length) return;\n\n\t\tnext = this.views.last().section.next();\n\n\t\tif(next) {\n\t\t\tview = this.createView(next);\n\t\t\treturn this.fill(view);\n\t\t}\n\n\t});\n\n};\n\nRendition.prototype.prev = function(){\n\n\treturn this.q.enqueue(function(){\n\n\t\tvar prev;\n\t\tvar view;\n\n\t\tif(!this.views.length) return;\n\n\t\tprev = this.views.first().section.prev();\n\t\tif(prev) {\n\t\t\tview = this.createView(prev);\n\t\t\treturn this.fill(view);\n\t\t}\n\n\t});\n\n};\n\n//-- http://www.idpf.org/epub/fxl/\nRendition.prototype.parseLayoutProperties = function(_metadata){\n\tvar metadata = _metadata || this.book.package.metadata;\n\tvar layout = (this.layoutOveride && this.layoutOveride.layout) || metadata.layout || \"reflowable\";\n\tvar spread = (this.layoutOveride && this.layoutOveride.spread) || metadata.spread || \"auto\";\n\tvar orientation = (this.layoutOveride && this.layoutOveride.orientation) || metadata.orientation || \"auto\";\n\tthis.globalLayoutProperties = {\n\t\tlayout : layout,\n\t\tspread : spread,\n\t\torientation : orientation\n\t};\n\treturn this.globalLayoutProperties;\n};\n\n\nRendition.prototype.current = function(){\n\tvar visible = this.visible();\n\tif(visible.length){\n\t\t// Current is the last visible view\n\t\treturn visible[visible.length-1];\n\t}\n  return null;\n};\n\nRendition.prototype.isVisible = function(view, offsetPrev, offsetNext, _container){\n\tvar position = view.position();\n\tvar container = _container || this.container.getBoundingClientRect();\n\n\tif(this.settings.axis === \"horizontal\" &&\n\t\tposition.right > container.left - offsetPrev &&\n\t\tposition.left < container.right + offsetNext) {\n\n\t\treturn true;\n\n  } else if(this.settings.axis === \"vertical\" &&\n  \tposition.bottom > container.top - offsetPrev &&\n\t\tposition.top < container.bottom + offsetNext) {\n\n\t\treturn true;\n  }\n\n\treturn false;\n\n};\n\nRendition.prototype.visible = function(){\n\tvar container = this.bounds();\n\tvar displayedViews = this.views.displayed();\n  var visible = [];\n  var isVisible;\n  var view;\n\n  for (var i = 0; i < displayedViews.length; i++) {\n    view = displayedViews[i];\n    isVisible = this.isVisible(view, 0, 0, container);\n\n    if(isVisible === true) {\n      visible.push(view);\n    }\n\n  }\n  return visible;\n\n};\n\nRendition.prototype.bounds = function(func) {\n  var bounds;\n\n  if(!this.settings.height) {\n    bounds = core.windowBounds();\n  } else {\n    bounds = this.container.getBoundingClientRect();\n  }\n\n  return bounds;\n};\n\nRendition.prototype.destroy = function(){\n  // Clear the queue\n\tthis.q.clear();\n\n\tthis.views.clear();\n\n\tclearTimeout(this.trimTimeout);\n\tif(this.settings.hidden) {\n\t\tthis.element.removeChild(this.wrapper);\n\t} else {\n\t\tthis.element.removeChild(this.container);\n\t}\n\n};\n\nRendition.prototype.reportLocation = function(){\n  return this.q.enqueue(function(){\n    this.location = this.currentLocation();\n    this.trigger(\"locationChanged\", this.location);\n  }.bind(this));\n};\n\nRendition.prototype.currentLocation = function(){\n  var view;\n  var start, end;\n\n  if(this.views.length) {\n  \tview = this.views.first();\n    // start = container.left - view.position().left;\n    // end = start + this.layout.spread;\n\n    return this.map.page(view);\n  }\n\n};\n\nRendition.prototype.scrollBy = function(x, y, silent){\n  if(silent) {\n    this.ignore = true;\n  }\n\n  if(this.settings.height) {\n\n    if(x) this.container.scrollLeft += x;\n  \tif(y) this.container.scrollTop += y;\n\n  } else {\n  \twindow.scrollBy(x,y);\n  }\n  // console.log(\"scrollBy\", x, y);\n  this.scrolled = true;\n};\n\nRendition.prototype.scrollTo = function(x, y, silent){\n  if(silent) {\n    this.ignore = true;\n  }\n\n  if(this.settings.height) {\n  \tthis.container.scrollLeft = x;\n  \tthis.container.scrollTop = y;\n  } else {\n  \twindow.scrollTo(x,y);\n  }\n  // console.log(\"scrollTo\", x, y);\n  this.scrolled = true;\n  // if(this.container.scrollLeft != x){\n  //   setTimeout(function() {\n  //     this.scrollTo(x, y, silent);\n  //   }.bind(this), 10);\n  //   return;\n  // };\n };\n\nRendition.prototype.passViewEvents = function(view){\n  view.listenedEvents.forEach(function(e){\n\t\tview.on(e, this.triggerViewEvent.bind(this));\n\t}.bind(this));\n};\n\nRendition.prototype.triggerViewEvent = function(e){\n  this.trigger(e.type, e);\n};\n\n//-- Enable binding events to Renderer\nRSVP.EventTarget.mixin(Rendition.prototype);\n\nmodule.exports = Rendition;\n","var core = require('./core');\n\nfunction links(view, renderer) {\n\n  var links = view.document.querySelectorAll(\"a[href]\");\n  var replaceLinks = function(link){\n    var href = link.getAttribute(\"href\");\n    var uri = new core.uri(href);\n\n\n    if(uri.protocol){\n\n      link.setAttribute(\"target\", \"_blank\");\n\n    }else{\n\n      // relative = core.resolveUrl(directory, href);\n      // if(uri.fragment && !base) {\n      //   link.onclick = function(){\n      //     renderer.fragment(href);\n      //     return false;\n      //   };\n      // } else {\n\n      //}\n\n      if(href.indexOf(\"#\") === 0) {\n        // do nothing with fragment yet\n      } else {\n        link.onclick = function(){\n          renderer.display(href);\n          return false;\n        };\n      }\n\n    }\n  };\n\n  for (var i = 0; i < links.length; i++) {\n    replaceLinks(links[i]);\n  }\n\n\n};\n\nmodule.exports = {\n  'links': links\n};\n","var RSVP = require('rsvp');\nvar core = require('./core');\n\nfunction request(url, type, withCredentials, headers) {\n  var supportsURL = window.URL;\n  var BLOB_RESPONSE = supportsURL ? \"blob\" : \"arraybuffer\";\n  var uri;\n\n  var deferred = new RSVP.defer();\n\n  var xhr = new XMLHttpRequest();\n\n  //-- Check from PDF.js:\n  //   https://github.com/mozilla/pdf.js/blob/master/web/compatibility.js\n  var xhrPrototype = XMLHttpRequest.prototype;\n\n  var header;\n\n  if (!('overrideMimeType' in xhrPrototype)) {\n    // IE10 might have response, but not overrideMimeType\n    Object.defineProperty(xhrPrototype, 'overrideMimeType', {\n      value: function xmlHttpRequestOverrideMimeType(mimeType) {}\n    });\n  }\n  if(withCredentials) {\n    xhr.withCredentials = true;\n  }\n\n  xhr.open(\"GET\", url, true);\n\n  for(header in headers) {\n    xhr.setRequestHeader(header, headers[header]);\n  }\n\n  xhr.onreadystatechange = handler;\n\n  // If type isn't set, determine it from the file extension\n\tif(!type) {\n\t\turi = core.uri(url);\n\t\ttype = uri.extension;\n\t}\n\n  if(type == 'blob'){\n    xhr.responseType = BLOB_RESPONSE;\n  }\n\n  if(type == \"json\") {\n    xhr.setRequestHeader(\"Accept\", \"application/json\");\n  }\n\n  if(core.isXml(type)) {\n\t\txhr.responseType = \"document\";\n\t\txhr.overrideMimeType('text/xml'); // for OPF parsing\n\t}\n\n\tif(type == 'xhtml') {\n\t\txhr.responseType = \"document\";\n\t}\n\n\tif(type == 'html' || type == 'htm') {\n\t\txhr.responseType = \"document\";\n \t}\n\n  if(type == \"binary\") {\n    xhr.responseType = \"arraybuffer\";\n  }\n\n  xhr.send();\n\n  function handler() {\n    if (this.readyState === this.DONE) {\n      if (this.status === 200 || this.responseXML ) { //-- Firefox is reporting 0 for blob urls\n        var r;\n\n        if((this.responseType == '' || this.responseType == 'document')\n            && this.responseXML){\n          r = this.responseXML;\n        } else\n        if(core.isXml(type)){\n          // If this.responseXML wasn't set, try to parse using a DOMParser from text\n          r = new DOMParser().parseFromString(this.response, \"text/xml\");\n        }else\n        if(type == 'xhtml'){\n          r = new DOMParser().parseFromString(this.response, \"application/xhtml+xml\");\n        }else\n        if(type == 'html' || type == 'htm'){\n          r = new DOMParser().parseFromString(this.response, \"text/html\");\n        }else\n        if(type == 'json'){\n          r = JSON.parse(this.response);\n        }else\n        if(type == 'blob'){\n\n          if(supportsURL) {\n            r = this.response;\n          } else {\n            //-- Safari doesn't support responseType blob, so create a blob from arraybuffer\n            r = new Blob([this.response]);\n          }\n\n        }else{\n          r = this.response;\n        }\n\n        deferred.resolve(r);\n      } else {\n        deferred.reject({\n          status: this.status,\n          message : this.response,\n          stack : new Error().stack\n        });\n      }\n    }\n  }\n\n  return deferred.promise;\n};\n\nmodule.exports = request;\n","var RSVP = require('rsvp');\nvar core = require('./core');\nvar EpubCFI = require('./epubcfi');\nvar Hook = require('./hook');\n\nfunction Section(item){\n    this.idref = item.idref;\n    this.linear = item.linear;\n    this.properties = item.properties;\n    this.index = item.index;\n    this.href = item.href;\n    this.url = item.url;\n    this.next = item.next;\n    this.prev = item.prev;\n\n    this.epubcfi = new EpubCFI();\n    this.cfiBase = item.cfiBase;\n\n    this.hooks = {};\n    this.hooks.replacements = new Hook(this);\n\n    // Register replacements\n    this.hooks.replacements.register(this.replacements);\n};\n\n\nSection.prototype.load = function(_request){\n  var request = _request || this.request || require('./request');\n  var loading = new RSVP.defer();\n  var loaded = loading.promise;\n\n  if(this.contents) {\n    loading.resolve(this.contents);\n  } else {\n    request(this.url)\n      .then(function(xml){\n        var base;\n        var directory = core.folder(this.url);\n\n        this.document = xml;\n        this.contents = xml.documentElement;\n\n        return this.hooks.replacements.trigger(this.document);\n      }.bind(this))\n      .then(function(){\n        loading.resolve(this.contents);\n      }.bind(this))\n      .catch(function(error){\n        loading.reject(error);\n      });\n  }\n\n  return loaded;\n};\n\nSection.prototype.replacements = function(_document){\n    var task = new RSVP.defer();\n    var base = _document.createElement(\"base\"); // TODO: check if exists\n    var head;\n\n    base.setAttribute(\"href\", this.url);\n\n    if(_document) {\n      head = _document.querySelector(\"head\");\n    }\n    if(head) {\n      head.insertBefore(base, head.firstChild);\n      task.resolve();\n    } else {\n      task.reject(new Error(\"No head to insert into\"));\n    }\n\n\n    return task.promise;\n};\n\nSection.prototype.beforeSectionLoad = function(){\n  // Stub for a hook - replace me for now\n};\n\nSection.prototype.render = function(_request){\n  var rendering = new RSVP.defer();\n  var rendered = rendering.promise;\n\n  this.load(_request).then(function(contents){\n    var serializer = new XMLSerializer();\n    var output = serializer.serializeToString(contents);\n    rendering.resolve(output);\n  })\n  .catch(function(error){\n    rendering.reject(error);\n  });\n\n  return rendered;\n};\n\nSection.prototype.find = function(_query){\n\n};\n\n/**\n* Reconciles the current chapters layout properies with\n* the global layout properities.\n* Takes: global layout settings object, chapter properties string\n* Returns: Object with layout properties\n*/\nSection.prototype.reconcileLayoutSettings = function(global){\n  //-- Get the global defaults\n  var settings = {\n    layout : global.layout,\n    spread : global.spread,\n    orientation : global.orientation\n  };\n\n  //-- Get the chapter's display type\n  this.properties.forEach(function(prop){\n    var rendition = prop.replace(\"rendition:\", '');\n    var split = rendition.indexOf(\"-\");\n    var property, value;\n\n    if(split != -1){\n      property = rendition.slice(0, split);\n      value = rendition.slice(split+1);\n\n      settings[property] = value;\n    }\n  });\n return settings;\n};\n\nSection.prototype.cfiFromRange = function(_range) {\n  return this.epubcfi.generateCfiFromRange(_range, this.cfiBase);\n};\n\nSection.prototype.cfiFromElement = function(el) {\n  return this.epubcfi.generateCfiFromElement(el, this.cfiBase);\n};\n\nmodule.exports = Section;\n","var RSVP = require('rsvp');\nvar core = require('./core');\nvar EpubCFI = require('./epubcfi');\nvar Section = require('./section');\n\nfunction Spine(_request){\n  this.request = _request;\n  this.spineItems = [];\n  this.spineByHref = {};\n  this.spineById = {};\n\n};\n\nSpine.prototype.load = function(_package) {\n\n  this.items = _package.spine;\n  this.manifest = _package.manifest;\n  this.spineNodeIndex = _package.spineNodeIndex;\n  this.baseUrl = _package.baseUrl || '';\n  this.length = this.items.length;\n  this.epubcfi = new EpubCFI();\n\n  this.items.forEach(function(item, index){\n    var href, url;\n    var manifestItem = this.manifest[item.idref];\n    var spineItem;\n    item.cfiBase = this.epubcfi.generateChapterComponent(this.spineNodeIndex, item.index, item.idref);\n\n    if(manifestItem) {\n      item.href = manifestItem.href;\n      item.url = this.baseUrl + item.href;\n\n\n      if(manifestItem.properties.length){\n        item.properties.push.apply(item.properties, manifestItem.properties);\n      }\n    }\n\n    // if(index > 0) {\n      item.prev = function(){ return this.get(index-1); }.bind(this);\n    // }\n\n    // if(index+1 < this.items.length) {\n      item.next = function(){ return this.get(index+1); }.bind(this);\n    // }\n\n    spineItem = new Section(item);\n    this.append(spineItem);\n\n\n  }.bind(this));\n\n};\n\n// book.spine.get();\n// book.spine.get(1);\n// book.spine.get(\"chap1.html\");\n// book.spine.get(\"#id1234\");\nSpine.prototype.get = function(target) {\n  var index = 0;\n\n  if(this.epubcfi.isCfiString(target)) {\n    cfi = this.epubcfi.parse(target);\n    index = cfi.spinePos;\n  } else if(target && (typeof target === \"number\" || isNaN(target) === false)){\n    index = target;\n  } else if(target && target.indexOf(\"#\") === 0) {\n    index = this.spineById[target.substring(1)];\n  } else if(target) {\n    // Remove fragments\n    target = target.split(\"#\")[0];\n    index = this.spineByHref[target];\n  }\n\n  return this.spineItems[index] || null;\n};\n\nSpine.prototype.append = function(section) {\n  var index = this.spineItems.length;\n  section.index = index;\n\n  this.spineItems.push(section);\n\n  this.spineByHref[section.href] = index;\n  this.spineById[section.idref] = index;\n\n  return index;\n};\n\nSpine.prototype.prepend = function(section) {\n  var index = this.spineItems.unshift(section);\n  this.spineByHref[section.href] = 0;\n  this.spineById[section.idref] = 0;\n\n  // Re-index\n  this.spineItems.forEach(function(item, index){\n    item.index = index;\n  });\n\n  return 0;\n};\n\nSpine.prototype.insert = function(section, index) {\n\n};\n\nSpine.prototype.remove = function(section) {\n  var index = this.spineItems.indexOf(section);\n\n  if(index > -1) {\n    delete this.spineByHref[section.href];\n    delete this.spineById[section.idref];\n\n    return this.spineItems.splice(index, 1);\n  }\n};\n\nSpine.prototype.each = function() {\n\treturn this.spineItems.forEach.apply(this.spineItems, arguments);\n};\n\nmodule.exports = Spine;\n","var RSVP = require('rsvp');\nvar core = require('./core');\nvar request = require('./request');\nvar mime = require('../libs/mime/mime');\n\nfunction Unarchive() {\n  try {\n    if (typeof JSZip !== 'undefined') {\n      this.zip = new JSZip();\n    } else {\n      JSZip = require('jszip');\n      this.zip = new JSZip();\n    }\n  } catch (e) {\n    console.error(\"JSZip lib not loaded\");\n  }\n}\n\nUnarchive.prototype.open = function(zipUrl){\n\tif (zipUrl instanceof ArrayBuffer) {\n    return new RSVP.Promise(function(resolve, reject) {\n      this.zip = new JSZip(zipUrl);\n      resolve(this.zip);\n    });\n\t} else {\n\t\treturn request(zipUrl, \"binary\")\n      .then(function(data){\n\t\t\t  this.zip = new JSZip(data);\n        return this.zip;\n\t\t  }.bind(this));\n\t}\n};\n\nUnarchive.prototype.request = function(url, type){\n  var deferred = new RSVP.defer();\n  var response;\n  var r;\n\n  // If type isn't set, determine it from the file extension\n\tif(!type) {\n\t\turi = core.uri(url);\n\t\ttype = uri.extension;\n\t}\n\n  if(type == 'blob'){\n    response = this.getBlob(url);\n  } else {\n    response = this.getText(url);\n  }\n\n  if (response) {\n    r = this.handleResponse(response, type);\n    deferred.resolve(r);\n  } else {\n    deferred.reject({\n      message : \"File not found in the epub: \" + url,\n      stack : new Error().stack\n    });\n  }\n  return deferred.promise;\n};\n\nUnarchive.prototype.handleResponse = function(response, type){\n  var r;\n\n  if(type == \"json\") {\n    r = JSON.parse(response);\n  }\n  else\n  if(core.isXml(type)) {\n    r = new DOMParser().parseFromString(response, \"text/xml\");\n\t}\n  else\n\tif(type == 'xhtml') {\n    r = new DOMParser().parseFromString(response, \"application/xhtml+xml\");\n\t}\n  else\n\tif(type == 'html' || type == 'htm') {\n    r = new DOMParser().parseFromString(response, \"text/html\");\n \t} else {\n \t  r = response;\n \t}\n\n  return r;\n};\n\nUnarchive.prototype.getBlob = function(url, _mimeType){\n\tvar decodededUrl = window.decodeURIComponent(url);\n\tvar entry = this.zip.file(decodededUrl);\n  var mimeType;\n\n\tif(entry) {\n    mimeType = _mimeType || mime.lookup(entry.name);\n    return new Blob([entry.asUint8Array()], {type : mimeType});\n\t}\n};\n\nUnarchive.prototype.getText = function(url, encoding){\n\tvar decodededUrl = window.decodeURIComponent(url);\n\tvar entry = this.zip.file(decodededUrl);\n\n\tif(entry) {\n    return entry.asText();\n\t}\n};\n\nUnarchive.prototype.createUrl = function(url, mime){\n\tvar deferred = new RSVP.defer();\n\tvar _URL = window.URL || window.webkitURL || window.mozURL;\n\tvar tempUrl;\n\tvar blob;\n\n\tif(url in this.urlCache) {\n\t\tdeferred.resolve(this.urlCache[url]);\n\t\treturn deferred.promise;\n\t}\n\n\tblob = this.getText(url);\n\n  if (blob) {\n    tempUrl = _URL.createObjectURL(blob);\n    deferred.resolve(tempUrl);\n    this.urlCache[url] = tempUrl;\n  } else {\n    deferred.reject({\n      message : \"File not found in the epub: \" + url,\n      stack : new Error().stack\n    });\n  }\n\n\treturn deferred.promise;\n};\n\nUnarchive.prototype.revokeUrl = function(url){\n\tvar _URL = window.URL || window.webkitURL || window.mozURL;\n\tvar fromCache = this.urlCache[url];\n\tif(fromCache) _URL.revokeObjectURL(fromCache);\n};\n\nmodule.exports = Unarchive;\n","var RSVP = require('rsvp');\nvar core = require('./core');\nvar EpubCFI = require('./epubcfi');\n\nfunction View(section, options) {\n  this.settings = options || {};\n\n  this.id = \"epubjs-view:\" + core.uuid();\n  this.section = section;\n  this.index = section.index;\n\n  this.element = document.createElement('div');\n  this.element.classList.add(\"epub-view\");\n\n\n  // this.element.style.minHeight = \"100px\";\n  this.element.style.height = \"0px\";\n  this.element.style.width = \"0px\";\n  this.element.style.overflow = \"hidden\";\n\n  this.added = false;\n  this.displayed = false;\n  this.rendered = false;\n\n  //this.width  = 0;\n  //this.height = 0;\n\n  // Blank Cfi for Parsing\n  this.epubcfi = new EpubCFI();\n\n  if(this.settings.axis && this.settings.axis == \"horizontal\"){\n    this.element.style.display = \"inline-block\";\n  } else {\n    this.element.style.display = \"block\";\n  }\n\n  // Dom events to listen for\n  this.listenedEvents = [\"keydown\", \"keyup\", \"keypressed\", \"mouseup\", \"mousedown\", \"click\", \"touchend\", \"touchstart\"];\n\n};\n\nView.prototype.create = function() {\n\n  if(this.iframe) {\n    return this.iframe;\n  }\n\n  this.iframe = document.createElement('iframe');\n  this.iframe.id = this.id;\n  this.iframe.scrolling = \"no\"; // Might need to be removed: breaks ios width calculations\n  this.iframe.style.overflow = \"hidden\";\n  this.iframe.seamless = \"seamless\";\n  // Back up if seamless isn't supported\n  this.iframe.style.border = \"none\";\n\n  this.resizing = true;\n\n  // this.iframe.style.display = \"none\";\n  this.element.style.visibility = \"hidden\";\n  this.iframe.style.visibility = \"hidden\";\n\n  this.iframe.style.width = \"0\";\n  this.iframe.style.height = \"0\";\n  this._width = 0;\n  this._height = 0;\n\n  this.element.appendChild(this.iframe);\n  this.added = true;\n\n  this.elementBounds = core.bounds(this.element);\n\n  // if(width || height){\n  //   this.resize(width, height);\n  // } else if(this.width && this.height){\n  //   this.resize(this.width, this.height);\n  // } else {\n  //   this.iframeBounds = core.bounds(this.iframe);\n  // }\n\n  // Firefox has trouble with baseURI and srcdoc\n  // Disabled for now\n  /*\n  if(!!(\"srcdoc\" in this.iframe)) {\n    this.supportsSrcdoc = true;\n  } else {\n    this.supportsSrcdoc = false;\n  }\n  */\n  this.supportsSrcdoc = false;\n\n  return this.iframe;\n};\n\n\nView.prototype.lock = function(what, width, height) {\n\n  var elBorders = core.borders(this.element);\n  var iframeBorders;\n\n  if(this.iframe) {\n    iframeBorders = core.borders(this.iframe);\n  } else {\n    iframeBorders = {width: 0, height: 0};\n  }\n\n  if(what == \"width\" && core.isNumber(width)){\n    this.lockedWidth = width - elBorders.width - iframeBorders.width;\n    this.resize(this.lockedWidth, width); //  width keeps ratio correct\n  }\n\n  if(what == \"height\" && core.isNumber(height)){\n    this.lockedHeight = height - elBorders.height - iframeBorders.height;\n    this.resize(width, this.lockedHeight);\n  }\n\n  if(what === \"both\" &&\n     core.isNumber(width) &&\n     core.isNumber(height)){\n\n    this.lockedWidth = width - elBorders.width - iframeBorders.width;\n    this.lockedHeight = height - elBorders.height - iframeBorders.height;\n\n    this.resize(this.lockedWidth, this.lockedHeight);\n  }\n\n  if(this.displayed && this.iframe) {\n\n      this.layout();\n      this.expand();\n\n  }\n\n\n\n};\n\nView.prototype.expand = function(force) {\n  var width = this.lockedWidth;\n  var height = this.lockedHeight;\n\n  var textWidth, textHeight;\n  // console.log(\"expanding a\")\n  if(!this.iframe || this._expanding) return;\n\n  this._expanding = true;\n\n  // Expand Horizontally\n  if(height && !width) {\n    // Get the width of the text\n    textWidth = this.textWidth();\n    // Check if the textWidth has changed\n    if(textWidth != this._textWidth){\n      // Get the contentWidth by resizing the iframe\n      // Check with a min reset of the textWidth\n      width = this.contentWidth(textWidth);\n      // Save the textWdith\n      this._textWidth = textWidth;\n      // Save the contentWidth\n      this._contentWidth = width;\n    } else {\n      // Otherwise assume content height hasn't changed\n      width = this._contentWidth;\n    }\n  }\n\n  // Expand Vertically\n  if(width && !height) {\n    textHeight = this.textHeight();\n    if(textHeight != this._textHeight){\n      height = this.contentHeight(textHeight);\n      this._textHeight = textHeight;\n      this._contentHeight = height;\n    } else {\n      height = this._contentHeight;\n    }\n  }\n\n  // Only Resize if dimensions have changed or\n  // if Frame is still hidden, so needs reframing\n  if(this._needsReframe || width != this._width || height != this._height){\n    this.resize(width, height);\n  }\n\n  this._expanding = false;\n};\n\nView.prototype.contentWidth = function(min) {\n  var prev;\n  var width;\n\n  // Save previous width\n  prev = this.iframe.style.width;\n  // Set the iframe size to min, width will only ever be greater\n  // Will preserve the aspect ratio\n  this.iframe.style.width = (min || 0) + \"px\";\n  // Get the scroll overflow width\n  width = this.document.body.scrollWidth;\n  // Reset iframe size back\n  this.iframe.style.width = prev;\n  return width;\n};\n\nView.prototype.contentHeight = function(min) {\n  var prev;\n  var height;\n\n  prev = this.iframe.style.height;\n  this.iframe.style.height = (min || 0) + \"px\";\n  height = this.document.body.scrollHeight;\n  this.iframe.style.height = prev;\n  return height;\n};\n\nView.prototype.textWidth = function() {\n  var width;\n  var range = this.document.createRange();\n\n  // Select the contents of frame\n  range.selectNodeContents(this.document.body);\n\n  // get the width of the text content\n  width = range.getBoundingClientRect().width;\n  return width;\n\n};\n\nView.prototype.textHeight = function() {\n  var height;\n  var range = this.document.createRange();\n\n  range.selectNodeContents(this.document.body);\n\n  height = range.getBoundingClientRect().height;\n  return height;\n};\n\nView.prototype.resize = function(width, height) {\n\n  if(!this.iframe) return;\n\n  if(core.isNumber(width)){\n    this.iframe.style.width = width + \"px\";\n    this._width = width;\n  }\n\n  if(core.isNumber(height)){\n    this.iframe.style.height = height + \"px\";\n    this._height = height;\n  }\n\n  this.iframeBounds = core.bounds(this.iframe);\n\n  this.reframe(this.iframeBounds.width, this.iframeBounds.height);\n\n};\n\nView.prototype.reframe = function(width, height) {\n  //var prevBounds;\n\n  if(!this.displayed) {\n    this._needsReframe = true;\n    return;\n  }\n\n  if(core.isNumber(width)){\n    this.element.style.width = width + \"px\";\n  }\n\n  if(core.isNumber(height)){\n    this.element.style.height = height + \"px\";\n  }\n\n  this.prevBounds = this.elementBounds;\n\n  this.elementBounds = core.bounds(this.element);\n\n  this.trigger(\"resized\", {\n    width: this.elementBounds.width,\n    height: this.elementBounds.height,\n    widthDelta: this.elementBounds.width - this.prevBounds.width,\n    heightDelta: this.elementBounds.height - this.prevBounds.height,\n  });\n\n};\n\nView.prototype.resized = function(e) {\n  /*\n  if (!this.resizing) {\n    if(this.iframe) {\n      // this.expand();\n    }\n  } else {\n    this.resizing = false;\n  }*/\n\n};\n\nView.prototype.render = function(_request) {\n\n  // if(this.rendering){\n  //   return this.displayed;\n  // }\n\n  this.rendering = true;\n  // this.displayingDefer = new RSVP.defer();\n  // this.displayedPromise = this.displaying.promise;\n\n  return this.section.render(_request)\n    .then(function(contents){\n      return this.load(contents);\n    }.bind(this));\n};\n\nView.prototype.load = function(contents) {\n  var loading = new RSVP.defer();\n  var loaded = loading.promise;\n\n  if(!this.iframe) {\n    loading.reject(new Error(\"No Iframe Available\"));\n    return loaded;\n  }\n\n  this.iframe.onload = function(event) {\n\n    this.window = this.iframe.contentWindow;\n    this.document = this.iframe.contentDocument;\n    this.rendering = false;\n    loading.resolve(this);\n\n  }.bind(this);\n\n  if(this.supportsSrcdoc){\n    this.iframe.srcdoc = contents;\n  } else {\n\n    this.document = this.iframe.contentDocument;\n\n    if(!this.document) {\n      loading.reject(new Error(\"No Document Available\"));\n      return loaded;\n    }\n\n    this.document.open();\n    this.document.write(contents);\n    this.document.close();\n\n  }\n\n  return loaded;\n};\n\n\nView.prototype.layout = function(layoutFunc) {\n\n  this.iframe.style.display = \"inline-block\";\n\n  // Reset Body Styles\n  this.document.body.style.margin = \"0\";\n  //this.document.body.style.display = \"inline-block\";\n  //this.document.documentElement.style.width = \"auto\";\n\n  if(layoutFunc){\n    layoutFunc(this);\n  }\n\n  this.onLayout(this);\n\n};\n\nView.prototype.onLayout = function(view) {\n  // stub\n};\n\nView.prototype.listeners = function() {\n  /*\n  setTimeout(function(){\n    this.window.addEventListener(\"resize\", this.resized.bind(this), false);\n  }.bind(this), 10); // Wait to listen for resize events\n  */\n\n  // Wait for fonts to load to finish\n  // http://dev.w3.org/csswg/css-font-loading/\n  // Not implemented fully except in chrome\n\n  if(this.document.fonts && this.document.fonts.status === \"loading\") {\n    // console.log(\"fonts unloaded\");\n    this.document.fonts.onloadingdone = function(){\n      // console.log(\"loaded fonts\");\n      this.expand();\n    }.bind(this);\n  }\n\n  if(this.section.properties.indexOf(\"scripted\") > -1){\n    this.observer = this.observe(this.document.body);\n  }\n\n  this.imageLoadListeners();\n\n  this.mediaQueryListeners();\n\n  // this.resizeListenters();\n\n  this.addEventListeners();\n\n  this.addSelectionListeners();\n};\n\nView.prototype.removeListeners = function() {\n\n  this.removeEventListeners();\n\n  this.removeSelectionListeners();\n};\n\nView.prototype.resizeListenters = function() {\n  // Test size again\n  clearTimeout(this.expanding);\n  this.expanding = setTimeout(this.expand.bind(this), 350);\n};\n\n//https://github.com/tylergaw/media-query-events/blob/master/js/mq-events.js\nView.prototype.mediaQueryListeners = function() {\n    var sheets = this.document.styleSheets;\n    var mediaChangeHandler = function(m){\n      if(m.matches && !this._expanding) {\n        setTimeout(this.expand.bind(this), 1);\n        // this.expand();\n      }\n    }.bind(this);\n\n    for (var i = 0; i < sheets.length; i += 1) {\n        var rules = sheets[i].cssRules;\n        if(!rules) return; // Stylesheets changed\n        for (var j = 0; j < rules.length; j += 1) {\n            //if (rules[j].constructor === CSSMediaRule) {\n            if(rules[j].media){\n                var mql = this.window.matchMedia(rules[j].media.mediaText);\n                mql.addListener(mediaChangeHandler);\n                //mql.onchange = mediaChangeHandler;\n            }\n        }\n    }\n};\n\nView.prototype.observe = function(target) {\n  var renderer = this;\n\n  // create an observer instance\n  var observer = new MutationObserver(function(mutations) {\n    if(renderer._expanding) {\n      renderer.expand();\n    }\n    // mutations.forEach(function(mutation) {\n    //   console.log(mutation);\n    // });\n  });\n\n  // configuration of the observer:\n  var config = { attributes: true, childList: true, characterData: true, subtree: true };\n\n  // pass in the target node, as well as the observer options\n  observer.observe(target, config);\n\n  return observer;\n};\n\n// View.prototype.appendTo = function(element) {\n//   this.element = element;\n//   this.element.appendChild(this.iframe);\n// };\n//\n// View.prototype.prependTo = function(element) {\n//   this.element = element;\n//   element.insertBefore(this.iframe, element.firstChild);\n// };\n\nView.prototype.imageLoadListeners = function(target) {\n  var images = this.document.body.querySelectorAll(\"img\");\n  var img;\n  for (var i = 0; i < images.length; i++) {\n    img = images[i];\n\n    if (typeof img.naturalWidth !== \"undefined\" &&\n        img.naturalWidth === 0) {\n      img.onload = this.expand.bind(this);\n    }\n  }\n};\n\nView.prototype.display = function() {\n  var displayed = new RSVP.defer();\n\n  this.displayed = true;\n\n  this.layout();\n\n  this.listeners();\n\n  this.expand();\n\n  this.trigger(\"displayed\", this);\n  this.onDisplayed(this);\n\n  displayed.resolve(this);\n\n  return displayed.promise;\n};\n\nView.prototype.show = function() {\n\n  this.element.style.visibility = \"visible\";\n\n  if(this.iframe){\n    this.iframe.style.visibility = \"visible\";\n  }\n\n  this.trigger(\"shown\", this);\n};\n\nView.prototype.hide = function() {\n  // this.iframe.style.display = \"none\";\n  this.element.style.visibility = \"hidden\";\n  this.iframe.style.visibility = \"hidden\";\n\n  this.stopExpanding = true;\n  this.trigger(\"hidden\", this);\n};\n\nView.prototype.position = function() {\n  return this.element.getBoundingClientRect();\n};\n\nView.prototype.onDisplayed = function(view) {\n  // Stub, override with a custom functions\n};\n\nView.prototype.bounds = function() {\n  if(!this.elementBounds) {\n    this.elementBounds = core.bounds(this.element);\n  }\n  return this.elementBounds;\n};\n\nView.prototype.destroy = function() {\n  // Stop observing\n  if(this.observer) {\n    this.observer.disconnect();\n  }\n\n  if(this.displayed){\n    this.removeListeners();\n\n    this.stopExpanding = true;\n    this.element.removeChild(this.iframe);\n    this.displayed = false;\n    this.iframe = null;\n\n    this._textWidth = null;\n    this._textHeight = null;\n    this._width = null;\n    this._height = null;\n  }\n  // this.element.style.height = \"0px\";\n  // this.element.style.width = \"0px\";\n};\n\nView.prototype.root = function() {\n  if(!this.document) return null;\n  return this.document.documentElement;\n};\n\nView.prototype.locationOf = function(target) {\n  var parentPos = this.iframe.getBoundingClientRect();\n  var targetPos = {\"left\": 0, \"top\": 0};\n\n  if(!this.document) return;\n\n  if(this.epubcfi.isCfiString(target)) {\n    cfi = this.epubcfi.parse(target);\n\n    if(typeof document.evaluate === 'undefined') {\n      marker = this.epubcfi.addMarker(cfi, this.document);\n      if(marker) {\n        // Must Clean up Marker before going to page\n        this.epubcfi.removeMarker(marker, this.document);\n\n        targetPos = marker.getBoundingClientRect();\n      }\n    } else {\n      range = this.epubcfi.generateRangeFromCfi(cfi, this.document);\n      if(range) {\n        targetPos = range.getBoundingClientRect();\n      }\n    }\n  } else if(typeof target === \"string\" &&\n    target.indexOf(\"#\") > -1) {\n\n    id = target.substring(target.indexOf(\"#\")+1);\n    el = this.document.getElementById(id);\n\n    if(el) {\n      targetPos = el.getBoundingClientRect();\n    }\n  }\n\n  return {\n    \"left\": window.scrollX + parentPos.left + targetPos.left,\n    \"top\": window.scrollY + parentPos.top + targetPos.top\n  };\n};\n\nView.prototype.addCss = function(src) {\n  return new RSVP.Promise(function(resolve, reject){\n    var $stylesheet;\n    var ready = false;\n\n    if(!this.document) {\n      resolve(false);\n      return;\n    }\n\n    $stylesheet = this.document.createElement('link');\n    $stylesheet.type = 'text/css';\n    $stylesheet.rel = \"stylesheet\";\n    $stylesheet.href = src;\n    $stylesheet.onload = $stylesheet.onreadystatechange = function() {\n      if ( !ready && (!this.readyState || this.readyState == 'complete') ) {\n        ready = true;\n        // Let apply\n        setTimeout(function(){\n          resolve(true);\n        }, 1);\n      }\n    };\n\n    this.document.head.appendChild($stylesheet);\n\n  }.bind(this));\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/insertRule\nView.prototype.addStylesheetRules = function(rules) {\n  var styleEl;\n  var styleSheet;\n\n  if(!this.document) return;\n\n  styleEl = this.document.createElement('style');\n\n  // Append style element to head\n  this.document.head.appendChild(styleEl);\n\n  // Grab style sheet\n  styleSheet = styleEl.sheet;\n\n  for (var i = 0, rl = rules.length; i < rl; i++) {\n    var j = 1, rule = rules[i], selector = rules[i][0], propStr = '';\n    // If the second argument of a rule is an array of arrays, correct our variables.\n    if (Object.prototype.toString.call(rule[1][0]) === '[object Array]') {\n      rule = rule[1];\n      j = 0;\n    }\n\n    for (var pl = rule.length; j < pl; j++) {\n      var prop = rule[j];\n      propStr += prop[0] + ':' + prop[1] + (prop[2] ? ' !important' : '') + ';\\n';\n    }\n\n    // Insert CSS Rule\n    styleSheet.insertRule(selector + '{' + propStr + '}', styleSheet.cssRules.length);\n  }\n};\n\nView.prototype.addScript = function(src) {\n\n  return new RSVP.Promise(function(resolve, reject){\n    var $script;\n    var ready = false;\n\n    if(!this.document) {\n      resolve(false);\n      return;\n    }\n\n    $script = this.document.createElement('script');\n    $script.type = 'text/javascript';\n    $script.async = true;\n    $script.src = src;\n    $script.onload = $script.onreadystatechange = function() {\n      if ( !ready && (!this.readyState || this.readyState == 'complete') ) {\n        ready = true;\n        setTimeout(function(){\n          resolve(true);\n        }, 1);\n      }\n    };\n\n    this.document.head.appendChild($script);\n\n  }.bind(this));\n};\n\nView.prototype.addEventListeners = function(){\n  if(!this.document) {\n    return;\n  }\n  this.listenedEvents.forEach(function(eventName){\n    this.document.addEventListener(eventName, this.triggerEvent.bind(this), false);\n  }, this);\n\n};\n\nView.prototype.removeEventListeners = function(){\n  if(!this.document) {\n    return;\n  }\n  this.listenedEvents.forEach(function(eventName){\n    this.document.removeEventListener(eventName, this.triggerEvent, false);\n  }, this);\n\n};\n\n// Pass browser events\nView.prototype.triggerEvent = function(e){\n  this.trigger(e.type, e);\n};\n\nView.prototype.addSelectionListeners = function(){\n  if(!this.document) {\n    return;\n  }\n  this.document.addEventListener(\"selectionchange\", this.onSelectionChange.bind(this), false);\n};\n\nView.prototype.removeSelectionListeners = function(){\n  if(!this.document) {\n    return;\n  }\n  this.document.removeEventListener(\"selectionchange\", this.onSelectionChange, false);\n};\n\nView.prototype.onSelectionChange = function(e){\n  if (this.selectionEndTimeout) {\n    clearTimeout(this.selectionEndTimeout);\n  }\n  this.selectionEndTimeout = setTimeout(function() {\n    this.selectedRange = this.window.getSelection();\n    this.trigger(\"selected\", this.selectedRange);\n  }.bind(this), 500);\n};\n\nRSVP.EventTarget.mixin(View.prototype);\n\nmodule.exports = View;\n","function Views(container) {\n  this.container = container;\n  this._views = [];\n  this.length = 0;\n  this.hidden = false;\n};\n\nViews.prototype.first = function() {\n\treturn this._views[0];\n};\n\nViews.prototype.last = function() {\n\treturn this._views[this._views.length-1];\n};\n\nViews.prototype.each = function() {\n\treturn this._views.forEach.apply(this._views, arguments);\n};\n\nViews.prototype.indexOf = function(view) {\n\treturn this._views.indexOf(view);\n};\n\nViews.prototype.slice = function() {\n\treturn this._views.slice.apply(this._views, arguments);\n};\n\nViews.prototype.get = function(i) {\n\treturn this._views[i];\n};\n\nViews.prototype.append = function(view){\n\tthis._views.push(view);\n\tthis.container.appendChild(view.element);\n  this.length++;\n  return view;\n};\n\nViews.prototype.prepend = function(view){\n\tthis._views.unshift(view);\n\tthis.container.insertBefore(view.element, this.container.firstChild);\n  this.length++;\n  return view;\n};\n\nViews.prototype.insert = function(view, index) {\n\tthis._views.splice(index, 0, view);\n\n\tif(index < this.container.children.length){\n\t\tthis.container.insertBefore(view.element, this.container.children[index]);\n\t} else {\n\t\tthis.container.appendChild(view.element);\n\t}\n  this.length++;\n  return view;\n};\n\nViews.prototype.remove = function(view) {\n\tvar index = this._views.indexOf(view);\n\n\tif(index > -1) {\n\t\tthis._views.splice(index, 1);\n\t}\n\n\n\tthis.destroy(view);\n\n  this.length--;\n};\n\nViews.prototype.destroy = function(view) {\n\tview.off(\"resized\");\n\n\tif(view.displayed){\n\t\tview.destroy();\n\t}\n\n\tthis.container.removeChild(view.element);\n\tview = null;\n};\n\n// Iterators\n\nViews.prototype.clear = function(){\n\t// Remove all views\n  var view;\n  var len = this.length;\n\n  if(!this.length) return;\n\n  for (var i = 0; i < len; i++) {\n    view = this._views[i];\n\t\tthis.destroy(view);\n  }\n\n  this._views = [];\n  this.length = 0;\n};\n\nViews.prototype.find = function(section){\n\n  var view;\n  var len = this.length;\n\n  for (var i = 0; i < len; i++) {\n    view = this._views[i];\n\t\tif(view.displayed && view.section.index == section.index) {\n\t\t\treturn view;\n\t\t}\n  }\n\n};\n\nViews.prototype.displayed = function(){\n  var displayed = [];\n  var view;\n  var len = this.length;\n\n  for (var i = 0; i < len; i++) {\n    view = this._views[i];\n    if(view.displayed){\n      displayed.push(view);\n    }\n  }\n  return displayed;\n};\n\nViews.prototype.show = function(){\n  var view;\n  var len = this.length;\n\n  for (var i = 0; i < len; i++) {\n    view = this._views[i];\n    if(view.displayed){\n      view.show();\n    }\n  }\n  this.hidden = false;\n};\n\nViews.prototype.hide = function(){\n  var view;\n  var len = this.length;\n\n  for (var i = 0; i < len; i++) {\n    view = this._views[i];\n    if(view.displayed){\n      view.hide();\n    }\n  }\n  this.hidden = true;\n};\n\nmodule.exports = Views;\n","if (typeof EPUBJS === 'undefined') {\n\t(typeof window !== 'undefined' ? window : global).EPUBJS = {};\n}\n\nEPUBJS.VERSION = \"0.3.0\";\n\nvar Book = require('./book');\n\nfunction ePub(_url) {\n\treturn new Book(_url);\n};\n\nmodule.exports = ePub;\n"]}