// Generated by CoffeeScript 1.6.3
var B64, base64Encode, base64UrlEncode, makeToken;

Date.prototype.toISO8601String = DateToISO8601String;

B64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

base64Encode = function(data) {
  var ac, bits, enc, h1, h2, h3, h4, i, o1, o2, o3, r, tmp_arr;
  if (typeof btoa !== "undefined" && btoa !== null) {
    return btoa(data);
  } else {
    i = 0;
    ac = 0;
    enc = "";
    tmp_arr = [];
    if (!data) {
      return data;
    }
    data += '';
    while (i < data.length) {
      o1 = data.charCodeAt(i++);
      o2 = data.charCodeAt(i++);
      o3 = data.charCodeAt(i++);
      bits = o1 << 16 | o2 << 8 | o3;
      h1 = bits >> 18 & 0x3f;
      h2 = bits >> 12 & 0x3f;
      h3 = bits >> 6 & 0x3f;
      h4 = bits & 0x3f;
      tmp_arr[ac++] = B64.charAt(h1) + B64.charAt(h2) + B64.charAt(h3) + B64.charAt(h4);
    }
    enc = tmp_arr.join('');
    r = data.length % 3;
    return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);
  }
};

base64UrlEncode = function(data) {
  var chop;
  data = base64Encode(data);
  chop = data.indexOf('=');
  if (chop !== -1) {
    data = data.slice(0, chop);
  }
  data = data.replace(/\+/g, '-');
  data = data.replace(/\//g, '_');
  return data;
};

makeToken = function() {
  var rawToken;
  rawToken = {
    consumerKey: "key",
    issuedAt: new Date().toISO8601String(),
    ttl: 300,
    userId: "testUser"
  };
  return {
    rawToken: rawToken,
    encodedToken: 'header.' + base64UrlEncode(JSON.stringify(rawToken)) + '.signature'
  };
};

describe('Annotator.Plugin.Auth', function() {
  var encodedToken, mock, mockAuth, rawToken;
  mock = null;
  rawToken = null;
  encodedToken = null;
  mockAuth = function(options) {
    var a, el;
    el = $('<div></div>')[0];
    a = new Annotator.Plugin.Auth(el, options);
    return {
      elem: el,
      auth: a
    };
  };
  beforeEach(function() {
    var _ref;
    _ref = makeToken(), rawToken = _ref.rawToken, encodedToken = _ref.encodedToken;
    return mock = mockAuth({
      token: encodedToken,
      autoFetch: false
    });
  });
  it("uses token supplied in options by default", function() {
    return assert.equal(mock.auth.token, encodedToken);
  });
  xit("makes an ajax request to tokenUrl to retrieve token otherwise");
  it("sets annotator:headers data on its element with token data", function() {
    var data;
    data = $(mock.elem).data('annotator:headers');
    assert.isNotNull(data);
    return assert.equal(data['x-annotator-auth-token'], encodedToken);
  });
  it("should call callbacks given to #withToken immediately if it has a valid token", function() {
    var callback;
    callback = sinon.spy();
    mock.auth.withToken(callback);
    return assert.isTrue(callback.calledWith(rawToken));
  });
  xit("should call callbacks given to #withToken after retrieving a token");
  return describe("#haveValidToken", function() {
    it("returns true when the current token is valid", function() {
      return assert.isTrue(mock.auth.haveValidToken());
    });
    it("returns false when the current token is missing a consumerKey", function() {
      delete mock.auth._unsafeToken.consumerKey;
      return assert.isFalse(mock.auth.haveValidToken());
    });
    it("returns false when the current token is missing an issuedAt", function() {
      delete mock.auth._unsafeToken.issuedAt;
      return assert.isFalse(mock.auth.haveValidToken());
    });
    it("returns false when the current token is missing a ttl", function() {
      delete mock.auth._unsafeToken.ttl;
      return assert.isFalse(mock.auth.haveValidToken());
    });
    return it("returns false when the current token expires in the past", function() {
      mock.auth._unsafeToken.ttl = 0;
      assert.isFalse(mock.auth.haveValidToken());
      mock.auth._unsafeToken.ttl = 86400;
      mock.auth._unsafeToken.issuedAt = "1970-01-01T00:00";
      return assert.isFalse(mock.auth.haveValidToken());
    });
  });
});

/*
//@ sourceMappingURL=auth_spec.map
*/
